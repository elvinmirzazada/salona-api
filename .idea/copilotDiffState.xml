<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/alembic/versions/add_membership_tables.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic/versions/add_membership_tables.py" />
              <option name="originalContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/api.py" />
              <option name="originalContent" value="from fastapi import APIRouter&#10;from app.api.api_v1.endpoints import customers, users, companies, services, bookings, notifications, memberships, integrations&#10;&#10;api_router = APIRouter()&#10;api_router.include_router(users.router, prefix=&quot;/users&quot;, tags=[&quot;users&quot;])&#10;api_router.include_router(companies.router, prefix=&quot;/companies&quot;, tags=[&quot;companies&quot;])&#10;api_router.include_router(services.router, prefix=&quot;/services&quot;, tags=[&quot;services&quot;])&#10;api_router.include_router(customers.router, prefix=&quot;/customers&quot;, tags=[&quot;customers&quot;])&#10;api_router.include_router(bookings.router, prefix=&quot;/bookings&quot;, tags=[&quot;bookings&quot;])&#10;api_router.include_router(notifications.router, prefix=&quot;/notifications&quot;, tags=[&quot;notifications&quot;])&#10;api_router.include_router(memberships.router, prefix=&quot;/memberships&quot;, tags=[&quot;memberships&quot;])&#10;api_router.include_router(integrations.router, prefix=&quot;/integrations&quot;, tags=[&quot;integrations&quot;])" />
              <option name="updatedContent" value="from fastapi import APIRouter&#10;from app.api.api_v1.endpoints import customers, users, companies, services, bookings, notifications, memberships, integrations&#10;&#10;api_router = APIRouter()&#10;api_router.include_router(users.router, prefix=&quot;/users&quot;, tags=[&quot;users&quot;])&#10;api_router.include_router(companies.router, prefix=&quot;/companies&quot;, tags=[&quot;companies&quot;])&#10;api_router.include_router(services.router, prefix=&quot;/services&quot;, tags=[&quot;services&quot;])&#10;api_router.include_router(customers.router, prefix=&quot;/customers&quot;, tags=[&quot;customers&quot;])&#10;api_router.include_router(bookings.router, prefix=&quot;/bookings&quot;, tags=[&quot;bookings&quot;])&#10;api_router.include_router(notifications.router, prefix=&quot;/notifications&quot;, tags=[&quot;notifications&quot;])&#10;api_router.include_router(memberships.router, prefix=&quot;/memberships&quot;, tags=[&quot;memberships&quot;])&#10;api_router.include_router(integrations.router, prefix=&quot;/integrations&quot;, tags=[&quot;integrations&quot;])" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/companies.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/companies.py" />
              <option name="originalContent" value="import uuid&#10;from typing import List&#10;from datetime import date, timedelta, datetime&#10;from fastapi import APIRouter, Depends, HTTPException, status, Query, Response&#10;from sqlalchemy.orm import Session&#10;from app.api.dependencies import (&#10;    get_current_active_user,&#10;    get_current_active_customer,&#10;    get_current_company_id,&#10;    require_admin_or_owner,&#10;    require_owner,&#10;    require_staff_or_higher,&#10;    get_current_user_role&#10;)&#10;from app.db.session import get_db&#10;from app.models import CompanyAddresses&#10;from app.models.models import Users, CompanyUsers&#10;from app.models.enums import CompanyRoleType, StatusType, InvitationStatus&#10;from app.schemas import (&#10;    CompanyCreate, User, Company, AvailabilityResponse, AvailabilityType, CompanyUser, CompanyUserUpdate,&#10;    CategoryServiceResponse, CompanyCategoryWithServicesResponse, Customer, TimeOff, CompanyUpdate,&#10;    CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, CompanyPhone, UserCreate,&#10;    Invitation, InvitationCreate, InvitationAccept, CompanyAddressResponse&#10;)&#10;from app.schemas.responses import DataResponse&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import customer as crud_customer&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import user_availability as crud_user_availability&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_user_time_off&#10;from app.services.crud import invitation as crud_invitation&#10;from app.services.email_service import email_service&#10;from app.services.auth import hash_password&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Company], status_code=status.HTTP_201_CREATED)&#10;async def create_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_in: CompanyCreate,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new company.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.create(db=db, obj_in=company_in, current_user=current_user)&#10;    return DataResponse.success_response(&#10;        data=company,&#10;        message=&quot;Company created successfully&quot;,&#10;        status_code=status.HTTP_201_CREATED&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}/users/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get user's regular availability&#10;        availabilities = crud_company.get_company_user_availabilities(db, user_id=user_id, company_id=company_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = crud_company.get_company_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, and existing bookings&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/{company_id}/availabilities&quot;, response_model=DataResponse[list[AvailabilityResponse]])&#10;async def get_company_all_users_availabilities(&#10;        *,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[list[AvailabilityResponse]]:&#10;    &quot;&quot;&quot;&#10;    Get availabilities for all users for a specific time range. Optimized to fetch all data in bulk and group bookings by user via BookingServices.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_users = crud_company.get_company_users(db, company_id)&#10;        if not company_users:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No users found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        # Bulk fetch all related data&#10;        availabilities = crud_company.get_company_all_users_availabilities(db, company_id)&#10;        time_offs = crud_company.get_company_all_users_time_offs(&#10;            db,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        booking_tuples = crud_booking.get_all_bookings_in_range(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        # Group data by user&#10;        avail_map = {}&#10;        for a in availabilities:&#10;            avail_map.setdefault(str(a.user_id), []).append(a)&#10;        timeoff_map = {}&#10;        for t in time_offs:&#10;            timeoff_map.setdefault(str(t.user_id), []).append(t)&#10;        booking_map = {}&#10;        for booking, user_id in booking_tuples:&#10;            booking_map.setdefault(str(user_id), []).append(booking)&#10;        results = []&#10;        for user in company_users:&#10;            user_id = str(user.user_id)&#10;            user_avails = avail_map.get(user_id, [])&#10;            if not user_avails:&#10;                continue&#10;            user_timeoffs = timeoff_map.get(user_id, [])&#10;            user_bookings = booking_map.get(user_id, [])&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=user_avails,&#10;                time_offs=user_timeoffs,&#10;                bookings=user_bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;            results.append(availability)&#10;        if not results:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availabilities found for any user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        return DataResponse.success_response(&#10;            data=results,&#10;            message=&quot;Availabilities retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availabilities: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/users&quot;, response_model=DataResponse[List[CompanyUser]])&#10;async def get_company_users(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can list staff&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all staff/users in the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        return DataResponse.error_response(&#10;            message=&quot;No company associated with the current user&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;    users = crud_company.get_company_users(&#10;        db=db, company_id=company_id&#10;    )&#10;    return DataResponse.success_response(&#10;        data=users,&#10;        message=&quot;Company users retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;/services&quot;, response_model=DataResponse[List[CompanyCategoryWithServicesResponse]])&#10;async def get_company_services(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all businesses owned by the authenticated professional.&#10;    &quot;&quot;&quot;&#10;    services = crud_service.get_company_services(&#10;        db=db, company_id=company_id&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=services,&#10;        message=&quot;Company services retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/customers', response_model=DataResponse[List[Customer]])&#10;async def get_company_customers(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)  # Staff and above can view customers&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all customers who have bookings with the company.&#10;    Requires staff, admin, or owner role.&#10;    &quot;&quot;&quot;&#10;    customers = crud_customer.get_company_customers(&#10;        db=db, company_id=company_id&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=customers,&#10;        message=&quot;Company customers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/user-time-offs', response_model=DataResponse[List[TimeOff]])&#10;async def get_company_user_time_offs(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all user time offs for the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    start_date = date_from&#10;    end_date = date_from + timedelta(&#10;        days=1 if availability_type == AvailabilityType.DAILY else&#10;        7 if availability_type == AvailabilityType.WEEKLY else 31&#10;    )&#10;    time_offs = crud_user_time_off.get_company_user_time_offs(&#10;        db=db, company_id=company_id, start_date=start_date, end_date=end_date&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=time_offs,&#10;        message=&quot;Company user time offs retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[Company])&#10;async def get_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}&quot;, response_model=DataResponse[Company])&#10;async def get_company_by_id(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;@router.get(&quot;/{company_id}/address&quot;, response_model=DataResponse[CompanyAddressResponse])&#10;async def get_company_address(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get the company's address by company_id.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        address = db.query(CompanyAddresses).filter(&#10;            CompanyAddresses.company_id == company_id&#10;        ).first()&#10;&#10;        if not address:&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Company address not found&quot;&#10;            )&#10;&#10;        # Convert ORM object to Pydantic response schema&#10;        address_response = CompanyAddressResponse.model_validate(address)&#10;&#10;        return DataResponse.success_response(&#10;            data=address_response,&#10;            message=&quot;Company address retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve company address: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;&quot;, response_model=DataResponse[Company])&#10;async def update_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_in: CompanyUpdate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can update company&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update company information.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;&#10;    try:&#10;        updated_company = crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=company_in.model_dump(exclude_unset=True)&#10;        )&#10;        return DataResponse.success_response(&#10;            data=updated_company,&#10;            message=&quot;Company information updated successfully&quot;&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company information: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/emails&quot;, response_model=DataResponse, status_code=status.HTTP_201_CREATED)&#10;async def add_company_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    email_in: CompanyEmailCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add a new email address to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        email_in.company_id = company_id&#10;        crud_company.create_company_email(db=db, obj_in=email_in)&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Emails added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add emails: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/emails&quot;, response_model=DataResponse[List[CompanyEmail]])&#10;async def get_company_emails(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all email addresses associated with the company.&#10;    &quot;&quot;&quot;&#10;    emails = crud_company.get_company_emails(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=emails,&#10;        message=&quot;Company emails retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/emails/{email_id}&quot;, response_model=DataResponse)&#10;async def delete_company_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    email_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete an email address from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = crud_company.delete_company_email(db=db, email_id=email_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Email not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Email deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/phones&quot;, response_model=DataResponse[List[CompanyPhone]], status_code=status.HTTP_201_CREATED)&#10;async def add_company_phone(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    phone_in: CompanyPhoneCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add new phone numbers to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Set the company ID from the authenticated user's context&#10;        phone_in.company_id = company_id&#10;        phones = crud_company.create_company_phone(db=db, obj_in=phone_in)&#10;&#10;        return DataResponse.success_response(&#10;            data=phones,&#10;            message=&quot;Phone numbers added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add phone numbers: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/phones&quot;, response_model=DataResponse[List[CompanyPhone]])&#10;async def get_company_phones(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers associated with the company.&#10;    &quot;&quot;&quot;&#10;    phones = crud_company.get_company_phones(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=phones,&#10;        message=&quot;Company phone numbers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/phones/{phone_id}&quot;, response_model=DataResponse)&#10;async def delete_company_phone(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    phone_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a phone number from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = crud_company.delete_company_phone(db=db, phone_id=phone_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Phone number not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Phone number deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;@router.post(&quot;/members&quot;, response_model=DataResponse[CompanyUser], status_code=status.HTTP_201_CREATED)&#10;async def add_company_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_in: UserCreate,&#10;    role: CompanyRoleType = Query(..., description=&quot;Role to assign to the user in the company&quot;),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can add members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to the company with a specified role.&#10;    If a user with the email already exists, they will be added to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_user = crud_company.create_company_member(&#10;            db=db,&#10;            user_in=user_in,&#10;            company_id=company_id,&#10;            role=role&#10;        )&#10;        return DataResponse.success_response(&#10;            data=company_user,&#10;            message=&quot;Member added to company successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add member to company: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/members/{user_id}&quot;, response_model=DataResponse[CompanyUser])&#10;async def update_company_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_update: CompanyUserUpdate,&#10;    _: None = Depends(require_admin_or_owner)  # Only admin or owner can update members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update a company member's role or status.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Validate that the update data is not empty&#10;        update_data = user_update.model_dump(exclude_unset=True)&#10;        if not update_data:&#10;            return DataResponse.error_response(&#10;                message=&quot;No fields to update&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the company user&#10;        updated_company_user = crud_company.update_company_user(&#10;            db=db,&#10;            company_id=company_id,&#10;            user_id=user_id,&#10;            obj_in=update_data&#10;        )&#10;&#10;        if not updated_company_user:&#10;            return DataResponse.error_response(&#10;                message=&quot;Company user not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get the updated company user with user details&#10;        company_user = crud_company.get_company_user(db=db, company_id=company_id, user_id=user_id)&#10;&#10;        return DataResponse.success_response(&#10;            data=company_user,&#10;            message=&quot;Company member updated successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/members/{user_id}&quot;, response_model=DataResponse)&#10;async def remove_company_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    _: None = Depends(require_admin_or_owner)  # Only admin or owner can remove members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Remove a member from the company (soft delete by setting status to inactive).&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if the user exists in the company first&#10;        existing_user = crud_company.get_company_user(db=db, company_id=company_id, user_id=user_id)&#10;        if not existing_user:&#10;            return DataResponse.error_response(&#10;                message=&quot;Company user not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Remove the user from the company&#10;        success = crud_company.delete_company_user(&#10;            db=db,&#10;            company_id=company_id,&#10;            user_id=user_id&#10;        )&#10;&#10;        if not success:&#10;            return DataResponse.error_response(&#10;                message=&quot;Failed to remove user from company&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Company member removed successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to remove company member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;# ============== STAFF INVITATION ENDPOINTS ==============&#10;&#10;@router.post(&quot;/invitations&quot;, response_model=DataResponse[Invitation], status_code=status.HTTP_201_CREATED)&#10;async def invite_staff_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    invitation_in: InvitationCreate,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Invite a staff member to the company.&#10;&#10;    If the invited email is not registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with sign-up link&#10;&#10;    If the invited email is already registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with acceptance link&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if email is already registered&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation_in.email.lower())&#10;        is_existing_user = existing_user is not None&#10;&#10;        # Set default role to staff if not provided&#10;        role = invitation_in.role or CompanyRoleType.staff&#10;&#10;        # Create invitation&#10;        invitation = crud_invitation.create_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation_in.email.lower(),&#10;            role=role&#10;        )&#10;&#10;        # Get company details for email&#10;        company = crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                detail=&quot;Company not found&quot;&#10;            )&#10;&#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=invitation.email,&#10;            invitation_token=invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;&#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation created but failed to send email. Please try again.&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(invitation),&#10;            message=&quot;Staff member invited successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to invite staff member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/accept&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def accept_invitation(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    invitation_in: InvitationAccept,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Accept a staff invitation.&#10;&#10;    If the user doesn't exist (new user):&#10;    - Create user account with provided details&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role&#10;    - Activate company_users record&#10;&#10;    If the user already exists (existing user):&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role (or update if already exists)&#10;    - Activate company_users record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation&#10;        invitation = crud_invitation.get_invitation_by_token(db=db, token=invitation_in.token)&#10;&#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if user exists&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation.email)&#10;&#10;        if not existing_user:&#10;            # Create new user&#10;            if not invitation_in.password:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;Password is required for new user registration&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST&#10;                )&#10;&#10;            # Hash password&#10;            hashed_password = hash_password(invitation_in.password)&#10;&#10;            # Create user&#10;            user_create_data = {&#10;                &quot;first_name&quot;: invitation_in.first_name,&#10;                &quot;last_name&quot;: invitation_in.last_name,&#10;                &quot;email&quot;: invitation.email,&#10;                &quot;password&quot;: hashed_password,&#10;                &quot;phone&quot;: invitation_in.phone&#10;            }&#10;&#10;            from app.schemas.schemas import UserCreate as UserCreateSchema&#10;            user_in = UserCreateSchema(**user_create_data)&#10;            new_user = crud_user.create(db=db, obj_in=user_in)&#10;            user_id = new_user.id&#10;        else:&#10;            # Use existing user&#10;            user_id = existing_user.id&#10;&#10;        # Accept invitation (mark as USED and add to company)&#10;        crud_invitation.accept_invitation(&#10;            db=db,&#10;            invitation=invitation,&#10;            user_id=user_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Invitation accepted successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to accept invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/{token}/resend&quot;, response_model=DataResponse[Invitation])&#10;async def resend_invitation(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    token: str,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation to a staff member.&#10;&#10;    This generates a new token and resets the invitation to PENDING status.&#10;    Only works for expired or pending invitations.&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.models import Invitations&#10;&#10;        # Get the invitation by current token&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.company_id == company_id&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Resend invitation&#10;        resent_invitation = crud_invitation.resend_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation.email&#10;        )&#10;&#10;        if not resent_invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or cannot be resent&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get company details for email&#10;        company = crud_company.get(db=db, id=company_id)&#10;&#10;        # Check if user exists for email&#10;        existing_user = crud_user.get_by_email(db=db, email=resent_invitation.email)&#10;        is_existing_user = existing_user is not None&#10;&#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=resent_invitation.email,&#10;            invitation_token=resent_invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;&#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation updated but failed to send email&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(resent_invitation),&#10;            message=&quot;Invitation resent successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to resend invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/invitations&quot;, response_model=DataResponse[List[Invitation]])&#10;async def get_company_invitations(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    status_filter: str = Query(None, description=&quot;Filter by status: pending, used, expired, declined&quot;),&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company.&#10;&#10;    Optional status filter: pending, used, expired, declined&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.enums import InvitationStatus&#10;&#10;        # Parse status filter&#10;        status_enum = None&#10;        if status_filter:&#10;            status_enum = InvitationStatus(status_filter.upper())&#10;&#10;        invitations = crud_invitation.get_company_invitations(&#10;            db=db,&#10;            company_id=company_id,&#10;            status=status_enum&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=[Invitation.model_validate(inv) for inv in invitations],&#10;            message=&quot;Company invitations retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except ValueError:&#10;        return DataResponse.error_response(&#10;            message=&quot;Invalid status filter&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve invitations: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/{token}/check-and-join&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def check_invitation_and_join(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    token: str,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Check if the email from invitation is registered.&#10;    If registered, add user to company and return status.&#10;    If not registered, return different status so UI knows to show signup form.&#10;&#10;    Returns:&#10;    - status: &quot;user_exists&quot; - User is registered, added to company, ready to accept&#10;    - status: &quot;user_not_found&quot; - User not registered, show signup form&#10;    - status: &quot;invitation_expired&quot; - Invitation has expired&#10;    - status: &quot;already_member&quot; - User already a member of this company&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation by token&#10;        invitation = crud_invitation.get_invitation_by_token(db=db, token=token)&#10;&#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                data={&quot;status&quot;: &quot;invitation_expired&quot;}&#10;            )&#10;&#10;        # Check if user exists with this email&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation.email)&#10;&#10;        if not existing_user:&#10;            # User doesn't exist - return status for UI to show signup form&#10;            return DataResponse.success_response(&#10;                message=&quot;Email not registered. Please sign up.&quot;,&#10;                status_code=status.HTTP_200_OK,&#10;                data={&#10;                    &quot;status&quot;: &quot;user_not_found&quot;,&#10;                    &quot;email&quot;: invitation.email,&#10;                    &quot;company_id&quot;: str(invitation.company_id),&#10;                    &quot;role&quot;: invitation.role,&#10;                    &quot;token&quot;: token&#10;                }&#10;            )&#10;&#10;        # Check if user is already a member of this company&#10;        existing_company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == invitation.company_id&#10;        ).first()&#10;&#10;        if existing_company_user:&#10;            # User already a member&#10;            if existing_company_user.status == StatusType.active:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;User is already a member of this company&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST,&#10;                    data={&quot;status&quot;: &quot;already_member&quot;}&#10;                )&#10;            else:&#10;                # Update status to active and role based on invitation&#10;                existing_company_user.status = StatusType.active&#10;                existing_company_user.role = invitation.role&#10;                db.add(existing_company_user)&#10;&#10;                # Mark invitation as used&#10;                invitation.status = InvitationStatus.USED&#10;                invitation.updated_at = datetime.now()&#10;                db.add(invitation)&#10;                db.commit()&#10;&#10;                return DataResponse.success_response(&#10;                    message=&quot;User successfully joined the company&quot;,&#10;                    status_code=status.HTTP_200_OK,&#10;                    data={&#10;                        &quot;status&quot;: &quot;user_exists&quot;,&#10;                        &quot;user_id&quot;: str(existing_user.id),&#10;                        &quot;email&quot;: existing_user.email,&#10;                        &quot;first_name&quot;: existing_user.first_name,&#10;                        &quot;last_name&quot;: existing_user.last_name,&#10;                        &quot;company_id&quot;: str(invitation.company_id),&#10;                        &quot;role&quot;: invitation.role,&#10;                        &quot;message&quot;: &quot;Rejoined the company&quot;&#10;                    }&#10;                )&#10;&#10;        # User exists but not yet a member - add them to company&#10;        company_user = CompanyUsers(&#10;            id=uuid.uuid4(),&#10;            user_id=existing_user.id,&#10;            company_id=invitation.company_id,&#10;            role=invitation.role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;&#10;        # Mark invitation as used&#10;        # invitation.status = InvitationStatus.USED&#10;        invitation.updated_at = datetime.now()&#10;        db.add(invitation)&#10;        db.commit()&#10;&#10;        # User exists and has been added to company&#10;        return DataResponse.success_response(&#10;            message=&quot;Registered user added to company successfully&quot;,&#10;            status_code=status.HTTP_200_OK,&#10;            data={&#10;                &quot;status&quot;: &quot;user_exists&quot;,&#10;                &quot;user_id&quot;: str(existing_user.id),&#10;                &quot;email&quot;: existing_user.email,&#10;                &quot;first_name&quot;: existing_user.first_name,&#10;                &quot;last_name&quot;: existing_user.last_name,&#10;                &quot;company_id&quot;: str(invitation.company_id),&#10;                &quot;role&quot;: invitation.role,&#10;                &quot;message&quot;: &quot;User joined the company&quot;&#10;            }&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to process invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;" />
              <option name="updatedContent" value="import uuid&#10;from typing import List&#10;from datetime import date, timedelta, datetime&#10;from fastapi import APIRouter, Depends, HTTPException, status, Query, Response&#10;from sqlalchemy.orm import Session&#10;from app.api.dependencies import (&#10;    get_current_active_user,&#10;    get_current_active_customer,&#10;    get_current_company_id,&#10;    require_admin_or_owner,&#10;    require_owner,&#10;    require_staff_or_higher,&#10;    get_current_user_role&#10;)&#10;from app.db.session import get_db&#10;from app.models import CompanyAddresses&#10;from app.models.models import Users, CompanyUsers&#10;from app.models.enums import CompanyRoleType, StatusType, InvitationStatus&#10;from app.schemas import (&#10;    CompanyCreate, User, Company, AvailabilityResponse, AvailabilityType, CompanyUser, CompanyUserUpdate,&#10;    CategoryServiceResponse, CompanyCategoryWithServicesResponse, Customer, TimeOff, CompanyUpdate,&#10;    CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, CompanyPhone, UserCreate,&#10;    Invitation, InvitationCreate, InvitationAccept, CompanyAddressResponse&#10;)&#10;from app.schemas.responses import DataResponse&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import customer as crud_customer&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import user_availability as crud_user_availability&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_user_time_off&#10;from app.services.crud import invitation as crud_invitation&#10;from app.services.email_service import email_service&#10;from app.services.auth import hash_password&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Company], status_code=status.HTTP_201_CREATED)&#10;async def create_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_in: CompanyCreate,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new company.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.create(db=db, obj_in=company_in, current_user=current_user)&#10;    return DataResponse.success_response(&#10;        data=company,&#10;        message=&quot;Company created successfully&quot;,&#10;        status_code=status.HTTP_201_CREATED&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}/users/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get user's regular availability&#10;        availabilities = crud_company.get_company_user_availabilities(db, user_id=user_id, company_id=company_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = crud_company.get_company_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, and existing bookings&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/{company_id}/availabilities&quot;, response_model=DataResponse[list[AvailabilityResponse]])&#10;async def get_company_all_users_availabilities(&#10;        *,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[list[AvailabilityResponse]]:&#10;    &quot;&quot;&quot;&#10;    Get availabilities for all users for a specific time range. Optimized to fetch all data in bulk and group bookings by user via BookingServices.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_users = crud_company.get_company_users(db, company_id)&#10;        if not company_users:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No users found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        # Bulk fetch all related data&#10;        availabilities = crud_company.get_company_all_users_availabilities(db, company_id)&#10;        time_offs = crud_company.get_company_all_users_time_offs(&#10;            db,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        booking_tuples = crud_booking.get_all_bookings_in_range(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        # Group data by user&#10;        avail_map = {}&#10;        for a in availabilities:&#10;            avail_map.setdefault(str(a.user_id), []).append(a)&#10;        timeoff_map = {}&#10;        for t in time_offs:&#10;            timeoff_map.setdefault(str(t.user_id), []).append(t)&#10;        booking_map = {}&#10;        for booking, user_id in booking_tuples:&#10;            booking_map.setdefault(str(user_id), []).append(booking)&#10;        results = []&#10;        for user in company_users:&#10;            user_id = str(user.user_id)&#10;            user_avails = avail_map.get(user_id, [])&#10;            if not user_avails:&#10;                continue&#10;            user_timeoffs = timeoff_map.get(user_id, [])&#10;            user_bookings = booking_map.get(user_id, [])&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=user_avails,&#10;                time_offs=user_timeoffs,&#10;                bookings=user_bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;            results.append(availability)&#10;        if not results:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availabilities found for any user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        return DataResponse.success_response(&#10;            data=results,&#10;            message=&quot;Availabilities retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availabilities: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/users&quot;, response_model=DataResponse[List[CompanyUser]])&#10;async def get_company_users(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can list staff&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all staff/users in the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        return DataResponse.error_response(&#10;            message=&quot;No company associated with the current user&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;    users = crud_company.get_company_users(&#10;        db=db, company_id=company_id&#10;    )&#10;    return DataResponse.success_response(&#10;        data=users,&#10;        message=&quot;Company users retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;/services&quot;, response_model=DataResponse[List[CompanyCategoryWithServicesResponse]])&#10;async def get_company_services(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all businesses owned by the authenticated professional.&#10;    &quot;&quot;&quot;&#10;    services = crud_service.get_company_services(&#10;        db=db, company_id=company_id&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=services,&#10;        message=&quot;Company services retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/customers', response_model=DataResponse[List[Customer]])&#10;async def get_company_customers(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)  # Staff and above can view customers&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all customers who have bookings with the company.&#10;    Requires staff, admin, or owner role.&#10;    &quot;&quot;&quot;&#10;    customers = crud_customer.get_company_customers(&#10;        db=db, company_id=company_id&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=customers,&#10;        message=&quot;Company customers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/user-time-offs', response_model=DataResponse[List[TimeOff]])&#10;async def get_company_user_time_offs(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all user time offs for the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    start_date = date_from&#10;    end_date = date_from + timedelta(&#10;        days=1 if availability_type == AvailabilityType.DAILY else&#10;        7 if availability_type == AvailabilityType.WEEKLY else 31&#10;    )&#10;    time_offs = crud_user_time_off.get_company_user_time_offs(&#10;        db=db, company_id=company_id, start_date=start_date, end_date=end_date&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=time_offs,&#10;        message=&quot;Company user time offs retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[Company])&#10;async def get_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}&quot;, response_model=DataResponse[Company])&#10;async def get_company_by_id(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;@router.get(&quot;/{company_id}/address&quot;, response_model=DataResponse[CompanyAddressResponse])&#10;async def get_company_address(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get the company's address by company_id.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        address = db.query(CompanyAddresses).filter(&#10;            CompanyAddresses.company_id == company_id&#10;        ).first()&#10;&#10;        if not address:&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Company address not found&quot;&#10;            )&#10;&#10;        # Convert ORM object to Pydantic response schema&#10;        address_response = CompanyAddressResponse.model_validate(address)&#10;&#10;        return DataResponse.success_response(&#10;            data=address_response,&#10;            message=&quot;Company address retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve company address: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;&quot;, response_model=DataResponse[Company])&#10;async def update_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_in: CompanyUpdate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can update company&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update company information.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;&#10;    try:&#10;        updated_company = crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=company_in.model_dump(exclude_unset=True)&#10;        )&#10;        return DataResponse.success_response(&#10;            data=updated_company,&#10;            message=&quot;Company information updated successfully&quot;&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company information: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/emails&quot;, response_model=DataResponse, status_code=status.HTTP_201_CREATED)&#10;async def add_company_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    email_in: CompanyEmailCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add a new email address to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        email_in.company_id = company_id&#10;        crud_company.create_company_email(db=db, obj_in=email_in)&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Emails added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add emails: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/emails&quot;, response_model=DataResponse[List[CompanyEmail]])&#10;async def get_company_emails(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all email addresses associated with the company.&#10;    &quot;&quot;&quot;&#10;    emails = crud_company.get_company_emails(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=emails,&#10;        message=&quot;Company emails retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/emails/{email_id}&quot;, response_model=DataResponse)&#10;async def delete_company_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    email_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete an email address from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = crud_company.delete_company_email(db=db, email_id=email_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Email not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Email deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/phones&quot;, response_model=DataResponse[List[CompanyPhone]], status_code=status.HTTP_201_CREATED)&#10;async def add_company_phone(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    phone_in: CompanyPhoneCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add new phone numbers to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Set the company ID from the authenticated user's context&#10;        phone_in.company_id = company_id&#10;        phones = crud_company.create_company_phone(db=db, obj_in=phone_in)&#10;&#10;        return DataResponse.success_response(&#10;            data=phones,&#10;            message=&quot;Phone numbers added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add phone numbers: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/phones&quot;, response_model=DataResponse[List[CompanyPhone]])&#10;async def get_company_phones(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers associated with the company.&#10;    &quot;&quot;&quot;&#10;    phones = crud_company.get_company_phones(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=phones,&#10;        message=&quot;Company phone numbers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/phones/{phone_id}&quot;, response_model=DataResponse)&#10;async def delete_company_phone(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    phone_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a phone number from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = crud_company.delete_company_phone(db=db, phone_id=phone_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Phone number not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Phone number deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;@router.post(&quot;/members&quot;, response_model=DataResponse[CompanyUser], status_code=status.HTTP_201_CREATED)&#10;async def add_company_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_in: UserCreate,&#10;    role: CompanyRoleType = Query(..., description=&quot;Role to assign to the user in the company&quot;),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can add members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to the company with a specified role.&#10;    If a user with the email already exists, they will be added to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_user = crud_company.create_company_member(&#10;            db=db,&#10;            user_in=user_in,&#10;            company_id=company_id,&#10;            role=role&#10;        )&#10;        return DataResponse.success_response(&#10;            data=company_user,&#10;            message=&quot;Member added to company successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add member to company: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/members/{user_id}&quot;, response_model=DataResponse[CompanyUser])&#10;async def update_company_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_update: CompanyUserUpdate,&#10;    _: None = Depends(require_admin_or_owner)  # Only admin or owner can update members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update a company member's role or status.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Validate that the update data is not empty&#10;        update_data = user_update.model_dump(exclude_unset=True)&#10;        if not update_data:&#10;            return DataResponse.error_response(&#10;                message=&quot;No fields to update&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the company user&#10;        updated_company_user = crud_company.update_company_user(&#10;            db=db,&#10;            company_id=company_id,&#10;            user_id=user_id,&#10;            obj_in=update_data&#10;        )&#10;&#10;        if not updated_company_user:&#10;            return DataResponse.error_response(&#10;                message=&quot;Company user not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get the updated company user with user details&#10;        company_user = crud_company.get_company_user(db=db, company_id=company_id, user_id=user_id)&#10;&#10;        return DataResponse.success_response(&#10;            data=company_user,&#10;            message=&quot;Company member updated successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/members/{user_id}&quot;, response_model=DataResponse)&#10;async def remove_company_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    _: None = Depends(require_admin_or_owner)  # Only admin or owner can remove members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Remove a member from the company (soft delete by setting status to inactive).&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if the user exists in the company first&#10;        existing_user = crud_company.get_company_user(db=db, company_id=company_id, user_id=user_id)&#10;        if not existing_user:&#10;            return DataResponse.error_response(&#10;                message=&quot;Company user not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Remove the user from the company&#10;        success = crud_company.delete_company_user(&#10;            db=db,&#10;            company_id=company_id,&#10;            user_id=user_id&#10;        )&#10;&#10;        if not success:&#10;            return DataResponse.error_response(&#10;                message=&quot;Failed to remove user from company&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Company member removed successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to remove company member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;# ============== STAFF INVITATION ENDPOINTS ==============&#10;&#10;@router.post(&quot;/invitations&quot;, response_model=DataResponse[Invitation], status_code=status.HTTP_201_CREATED)&#10;async def invite_staff_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    invitation_in: InvitationCreate,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Invite a staff member to the company.&#10;&#10;    If the invited email is not registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with sign-up link&#10;&#10;    If the invited email is already registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with acceptance link&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if email is already registered&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation_in.email.lower())&#10;        is_existing_user = existing_user is not None&#10;&#10;        # Set default role to staff if not provided&#10;        role = invitation_in.role or CompanyRoleType.staff&#10;&#10;        # Create invitation&#10;        invitation = crud_invitation.create_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation_in.email.lower(),&#10;            role=role&#10;        )&#10;&#10;        # Get company details for email&#10;        company = crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                detail=&quot;Company not found&quot;&#10;            )&#10;&#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=invitation.email,&#10;            invitation_token=invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;&#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation created but failed to send email. Please try again.&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(invitation),&#10;            message=&quot;Staff member invited successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to invite staff member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/accept&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def accept_invitation(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    invitation_in: InvitationAccept,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Accept a staff invitation.&#10;&#10;    If the user doesn't exist (new user):&#10;    - Create user account with provided details&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role&#10;    - Activate company_users record&#10;&#10;    If the user already exists (existing user):&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role (or update if already exists)&#10;    - Activate company_users record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation&#10;        invitation = crud_invitation.get_invitation_by_token(db=db, token=invitation_in.token)&#10;&#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if user exists&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation.email)&#10;&#10;        if not existing_user:&#10;            # Create new user&#10;            if not invitation_in.password:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;Password is required for new user registration&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST&#10;                )&#10;&#10;            # Hash password&#10;            hashed_password = hash_password(invitation_in.password)&#10;&#10;            # Create user&#10;            user_create_data = {&#10;                &quot;first_name&quot;: invitation_in.first_name,&#10;                &quot;last_name&quot;: invitation_in.last_name,&#10;                &quot;email&quot;: invitation.email,&#10;                &quot;password&quot;: hashed_password,&#10;                &quot;phone&quot;: invitation_in.phone&#10;            }&#10;&#10;            from app.schemas.schemas import UserCreate as UserCreateSchema&#10;            user_in = UserCreateSchema(**user_create_data)&#10;            new_user = crud_user.create(db=db, obj_in=user_in)&#10;            user_id = new_user.id&#10;        else:&#10;            # Use existing user&#10;            user_id = existing_user.id&#10;&#10;        # Accept invitation (mark as USED and add to company)&#10;        crud_invitation.accept_invitation(&#10;            db=db,&#10;            invitation=invitation,&#10;            user_id=user_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Invitation accepted successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to accept invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/{token}/resend&quot;, response_model=DataResponse[Invitation])&#10;async def resend_invitation(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    token: str,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation to a staff member.&#10;&#10;    This generates a new token and resets the invitation to PENDING status.&#10;    Only works for expired or pending invitations.&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.models import Invitations&#10;&#10;        # Get the invitation by current token&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.company_id == company_id&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Resend invitation&#10;        resent_invitation = crud_invitation.resend_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation.email&#10;        )&#10;&#10;        if not resent_invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or cannot be resent&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get company details for email&#10;        company = crud_company.get(db=db, id=company_id)&#10;&#10;        # Check if user exists for email&#10;        existing_user = crud_user.get_by_email(db=db, email=resent_invitation.email)&#10;        is_existing_user = existing_user is not None&#10;&#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=resent_invitation.email,&#10;            invitation_token=resent_invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;&#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation updated but failed to send email&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(resent_invitation),&#10;            message=&quot;Invitation resent successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to resend invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/invitations&quot;, response_model=DataResponse[List[Invitation]])&#10;async def get_company_invitations(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    status_filter: str = Query(None, description=&quot;Filter by status: pending, used, expired, declined&quot;),&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company.&#10;&#10;    Optional status filter: pending, used, expired, declined&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.enums import InvitationStatus&#10;&#10;        # Parse status filter&#10;        status_enum = None&#10;        if status_filter:&#10;            status_enum = InvitationStatus(status_filter.upper())&#10;&#10;        invitations = crud_invitation.get_company_invitations(&#10;            db=db,&#10;            company_id=company_id,&#10;            status=status_enum&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=[Invitation.model_validate(inv) for inv in invitations],&#10;            message=&quot;Company invitations retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except ValueError:&#10;        return DataResponse.error_response(&#10;            message=&quot;Invalid status filter&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve invitations: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/{token}/check-and-join&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def check_invitation_and_join(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    token: str,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Check if the email from invitation is registered.&#10;    If registered, add user to company and return status.&#10;    If not registered, return different status so UI knows to show signup form.&#10;&#10;    Returns:&#10;    - status: &quot;user_exists&quot; - User is registered, added to company, ready to accept&#10;    - status: &quot;user_not_found&quot; - User not registered, show signup form&#10;    - status: &quot;invitation_expired&quot; - Invitation has expired&#10;    - status: &quot;already_member&quot; - User already a member of this company&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation by token&#10;        invitation = crud_invitation.get_invitation_by_token(db=db, token=token)&#10;&#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                data={&quot;status&quot;: &quot;invitation_expired&quot;}&#10;            )&#10;&#10;        # Check if user exists with this email&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation.email)&#10;&#10;        if not existing_user:&#10;            # User doesn't exist - return status for UI to show signup form&#10;            return DataResponse.success_response(&#10;                message=&quot;Email not registered. Please sign up.&quot;,&#10;                status_code=status.HTTP_200_OK,&#10;                data={&#10;                    &quot;status&quot;: &quot;user_not_found&quot;,&#10;                    &quot;email&quot;: invitation.email,&#10;                    &quot;company_id&quot;: str(invitation.company_id),&#10;                    &quot;role&quot;: invitation.role,&#10;                    &quot;token&quot;: token&#10;                }&#10;            )&#10;&#10;        # Check if user is already a member of this company&#10;        existing_company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == invitation.company_id&#10;        ).first()&#10;&#10;        if existing_company_user:&#10;            # User already a member&#10;            if existing_company_user.status == StatusType.active:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;User is already a member of this company&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST,&#10;                    data={&quot;status&quot;: &quot;already_member&quot;}&#10;                )&#10;            else:&#10;                # Update status to active and role based on invitation&#10;                existing_company_user.status = StatusType.active&#10;                existing_company_user.role = invitation.role&#10;                db.add(existing_company_user)&#10;&#10;                # Mark invitation as used&#10;                invitation.status = InvitationStatus.USED&#10;                invitation.updated_at = datetime.now()&#10;                db.add(invitation)&#10;                db.commit()&#10;&#10;                return DataResponse.success_response(&#10;                    message=&quot;User successfully joined the company&quot;,&#10;                    status_code=status.HTTP_200_OK,&#10;                    data={&#10;                        &quot;status&quot;: &quot;user_exists&quot;,&#10;                        &quot;user_id&quot;: str(existing_user.id),&#10;                        &quot;email&quot;: existing_user.email,&#10;                        &quot;first_name&quot;: existing_user.first_name,&#10;                        &quot;last_name&quot;: existing_user.last_name,&#10;                        &quot;company_id&quot;: str(invitation.company_id),&#10;                        &quot;role&quot;: invitation.role,&#10;                        &quot;message&quot;: &quot;Rejoined the company&quot;&#10;                    }&#10;                )&#10;&#10;        # User exists but not yet a member - add them to company&#10;        company_user = CompanyUsers(&#10;            id=uuid.uuid4(),&#10;            user_id=existing_user.id,&#10;            company_id=invitation.company_id,&#10;            role=invitation.role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;&#10;        # Mark invitation as used&#10;        # invitation.status = InvitationStatus.USED&#10;        invitation.updated_at = datetime.now()&#10;        db.add(invitation)&#10;        db.commit()&#10;&#10;        # User exists and has been added to company&#10;        return DataResponse.success_response(&#10;            message=&quot;Registered user added to company successfully&quot;,&#10;            status_code=status.HTTP_200_OK,&#10;            data={&#10;                &quot;status&quot;: &quot;user_exists&quot;,&#10;                &quot;user_id&quot;: str(existing_user.id),&#10;                &quot;email&quot;: existing_user.email,&#10;                &quot;first_name&quot;: existing_user.first_name,&#10;                &quot;last_name&quot;: existing_user.last_name,&#10;                &quot;company_id&quot;: str(invitation.company_id),&#10;                &quot;role&quot;: invitation.role,&#10;                &quot;message&quot;: &quot;User joined the company&quot;&#10;            }&#10;        )&#10;&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to process invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/users.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/users.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from datetime import datetime, timedelta&#10;import logging&#10;from fastapi.responses import RedirectResponse, JSONResponse&#10;&#10;from app.api.dependencies import get_current_active_user, get_current_company_id&#10;from app.db.session import get_db&#10;from app.models import AvailabilityType&#10;from app.models.models import Users&#10;from app.schemas import User&#10;from app.schemas.auth import (&#10;    LoginRequest, TokenResponse, VerificationRequest,&#10;    GoogleAuthorizationResponse, GoogleCallbackRequest, GoogleOAuthResponse&#10;)&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import ResponseMessage, TimeOffCreate, TimeOff, TimeOffUpdate, UserUpdate&#10;from app.schemas.schemas import UserCreate&#10;from app.services.auth import hash_password, verify_password, create_token_pair, verify_token&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_time_off&#10;from app.services.crud import company as crud_company&#10;from app.services.email_service import email_service, create_verification_token&#10;from app.services.google_oauth import GoogleOAuthService&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;&#10;logger = logging.getLogger()&#10;router = APIRouter()&#10;&#10;&#10;# Helper function to create a new user (reused by both signup and Google OAuth)&#10;async def _create_new_user(&#10;    db: Session,&#10;    user_in: UserCreate,&#10;    send_verification_email: bool = True&#10;) -&gt; tuple[Users, str]:&#10;    &quot;&quot;&quot;&#10;    Internal helper to create a new user.&#10;&#10;    Returns:&#10;        Tuple of (new_user, message)&#10;    &quot;&quot;&quot;&#10;    user_in.email = user_in.email.lower()&#10;&#10;    # Check if user already exists&#10;    existing_user = crud_user.get_by_email(db=db, email=user_in.email)&#10;    if existing_user:&#10;        raise ValueError(&quot;User with this email already exists&quot;)&#10;&#10;    # Hash password&#10;    user_in.password = hash_password(user_in.password)&#10;    new_user = crud_user.create(db=db, obj_in=user_in)&#10;&#10;    # Create verification token&#10;    verification_record = create_verification_token(&#10;        db=db,&#10;        entity_id=new_user.id,&#10;        verification_type=VerificationType.EMAIL,&#10;        entity_type=&quot;user&quot;,&#10;        expires_in_hours=24&#10;    )&#10;&#10;    if send_verification_email:&#10;        # Send verification email&#10;        user_name = f&quot;{new_user.first_name} {new_user.last_name}&quot;&#10;        email_sent = email_service.send_verification_email(&#10;            to_email=new_user.email,&#10;            verification_token=verification_record.token,&#10;            user_name=user_name&#10;        )&#10;&#10;        if not email_sent:&#10;            raise Exception(f&quot;Warning: Failed to send verification email to {new_user.email}&quot;)&#10;&#10;        message = &quot;User created successfully. Please check your email to verify your account.&quot;&#10;    else:&#10;        # Auto-verify email for OAuth users&#10;        crud_user.verify_token(db=db, db_obj=verification_record)&#10;        message = &quot;User created successfully via Google OAuth&quot;&#10;&#10;    return new_user, message&#10;&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=ResponseMessage, status_code=status.HTTP_201_CREATED)&#10;async def create_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    user_in: UserCreate&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Register a new user and send email verification.&#10;    &quot;&quot;&quot;&#10;&#10;    try:&#10;        new_user, message = await _create_new_user(db, user_in, send_verification_email=True)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return ResponseMessage(message=message, status=&quot;success&quot;)&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return ResponseMessage(message=str(e), status=&quot;error&quot;)&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=DataResponse)&#10;async def verify_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify user email with token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_user.get_verification_token(&#10;            db=db,&#10;            token=verification_in.token,&#10;            type=VerificationType.EMAIL&#10;        )&#10;&#10;        if not token:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Verification token not found&quot;&#10;            )&#10;&#10;        if token.status != VerificationStatus.PENDING or token.expires_at &lt; datetime.now():&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Token has expired or is invalid&quot;&#10;            )&#10;&#10;        result = crud_user.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return DataResponse.success_response(&#10;                message=&quot;Email verified successfully&quot;&#10;            )&#10;&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=&quot;Email verification failed&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Verification process failed: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=DataResponse[TokenResponse])&#10;async def user_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Login professional using mobile number or email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;&#10;    # Try to get professional by mobile number first&#10;    user = crud_user.get_by_email(db, email=login_data.email)&#10;&#10;    if not user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Verify password&#10;    if not verify_password(login_data.password, user.password):&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;    company = crud_user.get_company_by_user(db, user.id)&#10;&#10;    # Create token pair&#10;    tokens = create_token_pair(user.id, user.email, actor=&quot;user&quot;, ver=&quot;1&quot;, company_id=str(company.company_id) if company else '')&#10;&#10;    response.set_cookie(&#10;        key=&quot;refresh_token&quot;,&#10;        value=tokens[&quot;refresh_token&quot;],&#10;        max_age=tokens['rt_expires_in'],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;none&quot;&#10;    )&#10;    response.set_cookie(&#10;        key=&quot;access_token&quot;,&#10;        value=tokens[&quot;access_token&quot;],&#10;        max_age=tokens['at_expires_in'],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;none&quot;&#10;    )&#10;&#10;    return DataResponse.success_response(data = TokenResponse(**tokens))&#10;&#10;&#10;@router.put(&quot;/auth/logout&quot;)&#10;async def logout_user(response: Response):&#10;    &quot;&quot;&quot;&#10;    Logout professional by clearing the refresh token cookie&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        # Determine cookie domain - must match the domain used when setting cookies&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;&#10;        # Delete cookies with the same parameters used when setting them&#10;        response.delete_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            domain=cookie_domain,&#10;            secure=is_production,&#10;            httponly=True,&#10;            samesite=&quot;lax&quot;&#10;        )&#10;        response.delete_cookie(&#10;            key=&quot;access_token&quot;,&#10;            domain=cookie_domain,&#10;            secure=is_production,&#10;            httponly=True,&#10;            samesite=&quot;lax&quot;&#10;        )&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.get(&quot;/me&quot;, response_model=DataResponse)&#10;async def get_current_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get current logged-in user. Returns CompanyUser if user belongs to a company, otherwise returns User.&#10;    &quot;&quot;&quot;&#10;    # Check if user belongs to a company&#10;    if current_user.company_id:&#10;        try:&#10;            # Get company user details&#10;            company_user = crud_company.get_company_user(&#10;                db=db, &#10;                user_id=str(current_user.id), &#10;                company_id=str(current_user.company_id)&#10;            )&#10;            if company_user:&#10;                return DataResponse.success_response(data=company_user)&#10;        except Exception as e:&#10;            print(f&quot;Error fetching company user: {str(e)}&quot;)&#10;            # Fall through to return basic user if company user fetch fails&#10;    &#10;    # Return basic user if no company association - convert SQLAlchemy model to Pydantic schema&#10;    user_schema = User.model_validate(current_user)&#10;    return DataResponse.success_response(data=user_schema)&#10;&#10;&#10;@router.put(&quot;/me&quot;, response_model=DataResponse[User], status_code=status.HTTP_200_OK)&#10;async def update_current_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_in: UserUpdate,&#10;    response: Response,&#10;    current_user: Users = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update current user's information (first_name, last_name, email, phone).&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Update the user&#10;        updated_user = crud_user.update(&#10;            db=db,&#10;            db_obj=current_user,&#10;            obj_in=user_in&#10;        )&#10;        &#10;        # Convert to Pydantic schema for response&#10;        user_schema = User.model_validate(updated_user)&#10;        &#10;        return DataResponse.success_response(&#10;            message=&quot;User information updated successfully&quot;,&#10;            data=user_schema,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update user information: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/time-offs&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_201_CREATED)&#10;async def create_time_off(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffCreate,&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for the current user.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=time_off_in.user_id,&#10;            start_date=time_off_in.start_date,&#10;            end_date=time_off_in.end_date&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Create the time off&#10;        time_off = crud_time_off.create(&#10;            db=db,&#10;            obj_in=time_off_in,&#10;            company_id=company_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off created successfully&quot;,&#10;            data=time_off,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/time-offs&quot;, response_model=DataResponse[List[TimeOff]], status_code=status.HTTP_200_OK)&#10;async def get_all_user_time_offs(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    start_date: datetime = Query(datetime.today(), description=&quot;Filter time offs that end after this date&quot;),&#10;    availability_type: AvailabilityType = Query(AvailabilityType.WEEKLY, description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all time offs for the current user with optional date filtering.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        end_date = start_date + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        time_offs = crud_time_off.get_user_time_offs(&#10;            db=db,&#10;            company_id=company_id,&#10;            start_date=start_date,&#10;            end_date=end_date&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=time_offs,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve time offs: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_200_OK)&#10;async def update_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffUpdate,&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the time off by ID&#10;        time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;        if not time_off:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Time off not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if the time off belongs to the current user&#10;        if str(time_off.user_id) != str(current_user.id):&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                message=&quot;You don't have permission to update this time off&quot;,&#10;                status_code=status.HTTP_403_FORBIDDEN&#10;            )&#10;&#10;        # Determine the new start and end dates for overlap check&#10;        start_date = time_off_in.start_date if time_off_in.start_date is not None else time_off.start_date&#10;        end_date = time_off_in.end_date if time_off_in.end_date is not None else time_off.end_date&#10;&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=current_user.id,&#10;            start_date=start_date,&#10;            end_date=end_date,&#10;            exclude_id=time_off_id&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The updated time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the time off&#10;        updated_time_off = crud_time_off.update(&#10;            db=db,&#10;            db_obj=time_off,&#10;            obj_in=time_off_in&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off updated successfully&quot;,&#10;            data=updated_time_off,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def delete_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period.&#10;    &quot;&quot;&quot;&#10;    # Get the time off by ID&#10;    time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;    if not time_off:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            message=&quot;Time off not found&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    # Check if the time off belongs to the current user&#10;    if str(time_off.user_id) != str(current_user.id):&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            message=&quot;You don't have permission to delete this time off&quot;,&#10;            status_code=status.HTTP_403_FORBIDDEN&#10;        )&#10;&#10;    # Delete the time off&#10;    deleted = crud_time_off.delete(db=db, time_off_id=time_off_id)&#10;    if not deleted:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Failed to delete time off&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Time off deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=DataResponse[TokenResponse])&#10;async def refresh_token(&#10;    request: Request,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Refresh access and refresh tokens using the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        # Get the refresh token from the request cookies&#10;        refresh_token = request.cookies.get(&quot;refresh_token&quot;)&#10;        if not refresh_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Refresh token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the refresh token&#10;        payload = verify_token(refresh_token, &quot;refresh&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid refresh token&quot;&#10;            )&#10;&#10;        # Extract user data from payload&#10;        user_id = payload.get(&quot;sub&quot;)&#10;        email = payload.get(&quot;email&quot;)&#10;        company_id = payload.get(&quot;company_id&quot;)&#10;&#10;        if not user_id or not email:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid token payload&quot;&#10;            )&#10;&#10;        # Create new tokens&#10;        new_tokens = create_token_pair(&#10;            id=user_id,&#10;            email=email,&#10;            actor=&quot;user&quot;,&#10;            ver=&quot;1&quot;,&#10;            company_id=company_id&#10;        )&#10;&#10;        # Determine cookie domain - use shared domain for production&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;&#10;        # Set new cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=new_tokens[&quot;refresh_token&quot;],&#10;            max_age=new_tokens['rt_expires_in'],&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,&#10;            domain=cookie_domain&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=new_tokens[&quot;access_token&quot;],&#10;            max_age=new_tokens['at_expires_in'],&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,&#10;            domain=cookie_domain&#10;        )&#10;&#10;        return DataResponse.success_response(data=TokenResponse(**new_tokens))&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to refresh token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/verify-token&quot;, response_model=DataResponse[dict])&#10;async def verify_access_token(&#10;    request: Request,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify the access token and return the token data.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the access token from the request cookies&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Access token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the access token&#10;        payload = verify_token(access_token, &quot;access&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid or expired access token&quot;&#10;            )&#10;&#10;        # Return token validity info&#10;        return DataResponse.success_response(data={&#10;            &quot;valid&quot;: True,&#10;            &quot;user_id&quot;: payload.get(&quot;sub&quot;),&#10;            &quot;email&quot;: payload.get(&quot;email&quot;),&#10;            &quot;company_id&quot;: payload.get(&quot;company_id&quot;),&#10;            &quot;expires_at&quot;: payload.get(&quot;exp&quot;)&#10;        })&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to verify token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/google/authorize&quot;, response_model=GoogleAuthorizationResponse)&#10;async def google_authorize(&#10;    response: Response&#10;) -&gt; GoogleAuthorizationResponse:&#10;    &quot;&quot;&quot;&#10;    Initiate Google OAuth flow - returns authorization URL and state token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        state = GoogleOAuthService.generate_state_token()&#10;&#10;        # Store state in response cookie for verification later&#10;        response.set_cookie(&#10;            key=&quot;google_oauth_state&quot;,&#10;            value=state,&#10;            httponly=True,&#10;            secure=True,&#10;            samesite=&quot;lax&quot;,&#10;            max_age=600  # 10 minutes&#10;        )&#10;&#10;        authorization_url = GoogleOAuthService.get_authorization_url(state)&#10;&#10;        return GoogleAuthorizationResponse(&#10;            authorization_url=authorization_url,&#10;            state=state&#10;        )&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to initiate Google OAuth: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.get(&quot;/auth/google/callback&quot;, response_model=DataResponse[TokenResponse])&#10;async def google_callback(&#10;    request: Request,&#10;    response: Response,&#10;    state: str = Query(..., description=&quot;State token for CSRF protection&quot;),&#10;    code: str = Query(..., description=&quot;Authorization code from Google&quot;),&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Handle Google OAuth callback for both signup and login.&#10;    - If user exists: authenticates and returns tokens&#10;    - If user doesn't exist: creates new user with random password and returns tokens&#10;&#10;    This unified endpoint eliminates the need for separate signup/login paths.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        error = None&#10;        google_email = &quot;&quot;&#10;        google_name = &quot;Google User&quot;  # Initialize with default value&#10;        # Verify state token for CSRF protection&#10;        stored_state = request.cookies.get(&quot;google_oauth_state&quot;)&#10;        if not stored_state or stored_state != state:&#10;            error = 'Invalid state parameter'&#10;        else:&#10;            # Get redirect_uri from environment or default&#10;            redirect_uri = getattr(settings, 'GOOGLE_REDIRECT_URI', 'http://localhost:8000/api/v1/users/auth/google/callback')&#10;&#10;            # Exchange authorization code for tokens&#10;            token_response = GoogleOAuthService.exchange_code_for_token(&#10;                code,&#10;                redirect_uri&#10;            )&#10;            print(f'Token response: {token_response}')&#10;            if not token_response:&#10;                error = 'Failed to exchange authorization code for tokens'&#10;            else:&#10;                access_token = token_response.get(&quot;access_token&quot;)&#10;                if not access_token:&#10;                    error = 'No access token in response'&#10;&#10;                else:&#10;                    # Get user info from Google&#10;                    user_info = GoogleOAuthService.get_user_info(access_token)&#10;&#10;                    if not user_info:&#10;                        error = 'Failed to retrieve user information from Google'&#10;&#10;                    else:&#10;                        google_email = user_info.get(&quot;email&quot;, &quot;&quot;).lower()&#10;                        google_name = user_info.get(&quot;name&quot;, &quot;Google User&quot;)&#10;&#10;                        if not google_email:&#10;                            error = 'Google account does not have an email'&#10;&#10;        if error:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=error&#10;            )&#10;        # Check if user already exists&#10;        user = crud_user.get_by_email(db=db, email=google_email)&#10;&#10;        if user:&#10;            # User exists - authenticate them&#10;            company = crud_user.get_company_by_user(db, user.id)&#10;            tokens = create_token_pair(&#10;                user.id,&#10;                user.email,&#10;                actor=&quot;user&quot;,&#10;                ver=&quot;1&quot;,&#10;                company_id=str(company.company_id) if company else ''&#10;            )&#10;            auth_message = &quot;Logged in successfully via Google&quot;&#10;        else:&#10;            # User doesn't exist - create new user with random password&#10;            random_password = GoogleOAuthService.generate_random_password()&#10;            hashed_password = hash_password(random_password)&#10;&#10;            # Parse name into first and last name&#10;            name_parts = google_name.split(&quot; &quot;, 1)&#10;            first_name = name_parts[0] if name_parts else &quot;User&quot;&#10;            last_name = name_parts[1] if len(name_parts) &gt; 1 else &quot;&quot;&#10;&#10;            # Create user object&#10;            user_create = UserCreate(&#10;                first_name=first_name,&#10;                last_name=last_name,&#10;                email=google_email,&#10;                password=hashed_password,&#10;                phone=&quot;&quot;  # Default empty phone for OAuth users&#10;            )&#10;&#10;            new_user, auth_message = await _create_new_user(&#10;                db=db,&#10;                user_in=user_create,&#10;                send_verification_email=False  # No email verification for OAuth users&#10;            )&#10;&#10;            # Create tokens for new user&#10;            tokens = create_token_pair(&#10;                new_user.id,&#10;                new_user.email,&#10;                actor=&quot;user&quot;,&#10;                ver=&quot;1&quot;,&#10;                company_id=&quot;&quot;&#10;            )&#10;            auth_message = &quot;Account created and logged in successfully via Google&quot;&#10;            user = new_user&#10;&#10;        # Set cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            max_age=tokens['rt_expires_in'],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;none&quot;&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=tokens[&quot;access_token&quot;],&#10;            max_age=tokens['at_expires_in'],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;none&quot;&#10;        )&#10;&#10;        # Clear the state cookie&#10;        response.delete_cookie(key=&quot;google_oauth_state&quot;)&#10;        return DataResponse.success_response(data = TokenResponse(**tokens))&#10;&#10;    except Exception as e:&#10;        return DataResponse.error_response(message=f&quot;Google OAuth process failed: {str(e)}&quot;, status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from datetime import datetime, timedelta&#10;import logging&#10;from fastapi.responses import RedirectResponse, JSONResponse&#10;&#10;from app.api.dependencies import get_current_active_user, get_current_company_id&#10;from app.db.session import get_db&#10;from app.models import AvailabilityType&#10;from app.models.models import Users&#10;from app.schemas import User&#10;from app.schemas.auth import (&#10;    LoginRequest, TokenResponse, VerificationRequest,&#10;    GoogleAuthorizationResponse, GoogleCallbackRequest, GoogleOAuthResponse&#10;)&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import ResponseMessage, TimeOffCreate, TimeOff, TimeOffUpdate, UserUpdate&#10;from app.schemas.schemas import UserCreate&#10;from app.services.auth import hash_password, verify_password, create_token_pair, verify_token&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_time_off&#10;from app.services.crud import company as crud_company&#10;from app.services.email_service import email_service, create_verification_token&#10;from app.services.google_oauth import GoogleOAuthService&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;&#10;logger = logging.getLogger()&#10;router = APIRouter()&#10;&#10;&#10;# Helper function to create a new user (reused by both signup and Google OAuth)&#10;async def _create_new_user(&#10;    db: Session,&#10;    user_in: UserCreate,&#10;    send_verification_email: bool = True&#10;) -&gt; tuple[Users, str]:&#10;    &quot;&quot;&quot;&#10;    Internal helper to create a new user.&#10;&#10;    Returns:&#10;        Tuple of (new_user, message)&#10;    &quot;&quot;&quot;&#10;    user_in.email = user_in.email.lower()&#10;&#10;    # Check if user already exists&#10;    existing_user = crud_user.get_by_email(db=db, email=user_in.email)&#10;    if existing_user:&#10;        raise ValueError(&quot;User with this email already exists&quot;)&#10;&#10;    # Hash password&#10;    user_in.password = hash_password(user_in.password)&#10;    new_user = crud_user.create(db=db, obj_in=user_in)&#10;&#10;    # Create verification token&#10;    verification_record = create_verification_token(&#10;        db=db,&#10;        entity_id=new_user.id,&#10;        verification_type=VerificationType.EMAIL,&#10;        entity_type=&quot;user&quot;,&#10;        expires_in_hours=24&#10;    )&#10;&#10;    if send_verification_email:&#10;        # Send verification email&#10;        user_name = f&quot;{new_user.first_name} {new_user.last_name}&quot;&#10;        email_sent = email_service.send_verification_email(&#10;            to_email=new_user.email,&#10;            verification_token=verification_record.token,&#10;            user_name=user_name&#10;        )&#10;&#10;        if not email_sent:&#10;            raise Exception(f&quot;Warning: Failed to send verification email to {new_user.email}&quot;)&#10;&#10;        message = &quot;User created successfully. Please check your email to verify your account.&quot;&#10;    else:&#10;        # Auto-verify email for OAuth users&#10;        crud_user.verify_token(db=db, db_obj=verification_record)&#10;        message = &quot;User created successfully via Google OAuth&quot;&#10;&#10;    return new_user, message&#10;&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=ResponseMessage, status_code=status.HTTP_201_CREATED)&#10;async def create_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    user_in: UserCreate&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Register a new user and send email verification.&#10;    &quot;&quot;&quot;&#10;&#10;    try:&#10;        new_user, message = await _create_new_user(db, user_in, send_verification_email=True)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return ResponseMessage(message=message, status=&quot;success&quot;)&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return ResponseMessage(message=str(e), status=&quot;error&quot;)&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=DataResponse)&#10;async def verify_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify user email with token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_user.get_verification_token(&#10;            db=db,&#10;            token=verification_in.token,&#10;            type=VerificationType.EMAIL&#10;        )&#10;&#10;        if not token:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Verification token not found&quot;&#10;            )&#10;&#10;        if token.status != VerificationStatus.PENDING or token.expires_at &lt; datetime.now():&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Token has expired or is invalid&quot;&#10;            )&#10;&#10;        result = crud_user.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return DataResponse.success_response(&#10;                message=&quot;Email verified successfully&quot;&#10;            )&#10;&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=&quot;Email verification failed&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Verification process failed: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=DataResponse[TokenResponse])&#10;async def user_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Login professional using mobile number or email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;&#10;    # Try to get professional by mobile number first&#10;    user = crud_user.get_by_email(db, email=login_data.email)&#10;&#10;    if not user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Verify password&#10;    if not verify_password(login_data.password, user.password):&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;    company = crud_user.get_company_by_user(db, user.id)&#10;&#10;    # Create token pair&#10;    tokens = create_token_pair(user.id, user.email, actor=&quot;user&quot;, ver=&quot;1&quot;, company_id=str(company.company_id) if company else '')&#10;&#10;    response.set_cookie(&#10;        key=&quot;refresh_token&quot;,&#10;        value=tokens[&quot;refresh_token&quot;],&#10;        max_age=tokens['rt_expires_in'],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;none&quot;&#10;    )&#10;    response.set_cookie(&#10;        key=&quot;access_token&quot;,&#10;        value=tokens[&quot;access_token&quot;],&#10;        max_age=tokens['at_expires_in'],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;none&quot;&#10;    )&#10;&#10;    return DataResponse.success_response(data = TokenResponse(**tokens))&#10;&#10;&#10;@router.put(&quot;/auth/logout&quot;)&#10;async def logout_user(response: Response):&#10;    &quot;&quot;&quot;&#10;    Logout professional by clearing the refresh token cookie&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        # Determine cookie domain - must match the domain used when setting cookies&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;&#10;        # Delete cookies with the same parameters used when setting them&#10;        response.delete_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            domain=cookie_domain,&#10;            secure=is_production,&#10;            httponly=True,&#10;            samesite=&quot;lax&quot;&#10;        )&#10;        response.delete_cookie(&#10;            key=&quot;access_token&quot;,&#10;            domain=cookie_domain,&#10;            secure=is_production,&#10;            httponly=True,&#10;            samesite=&quot;lax&quot;&#10;        )&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.get(&quot;/me&quot;, response_model=DataResponse)&#10;async def get_current_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get current logged-in user. Returns CompanyUser if user belongs to a company, otherwise returns User.&#10;    &quot;&quot;&quot;&#10;    # Check if user belongs to a company&#10;    if current_user.company_id:&#10;        try:&#10;            # Get company user details&#10;            company_user = crud_company.get_company_user(&#10;                db=db, &#10;                user_id=str(current_user.id), &#10;                company_id=str(current_user.company_id)&#10;            )&#10;            if company_user:&#10;                return DataResponse.success_response(data=company_user)&#10;        except Exception as e:&#10;            print(f&quot;Error fetching company user: {str(e)}&quot;)&#10;            # Fall through to return basic user if company user fetch fails&#10;    &#10;    # Return basic user if no company association - convert SQLAlchemy model to Pydantic schema&#10;    user_schema = User.model_validate(current_user)&#10;    return DataResponse.success_response(data=user_schema)&#10;&#10;&#10;@router.put(&quot;/me&quot;, response_model=DataResponse[User], status_code=status.HTTP_200_OK)&#10;async def update_current_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_in: UserUpdate,&#10;    response: Response,&#10;    current_user: Users = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update current user's information (first_name, last_name, email, phone).&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Update the user&#10;        updated_user = crud_user.update(&#10;            db=db,&#10;            db_obj=current_user,&#10;            obj_in=user_in&#10;        )&#10;        &#10;        # Convert to Pydantic schema for response&#10;        user_schema = User.model_validate(updated_user)&#10;        &#10;        return DataResponse.success_response(&#10;            message=&quot;User information updated successfully&quot;,&#10;            data=user_schema,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update user information: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/time-offs&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_201_CREATED)&#10;async def create_time_off(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffCreate,&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for the current user.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=time_off_in.user_id,&#10;            start_date=time_off_in.start_date,&#10;            end_date=time_off_in.end_date&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Create the time off&#10;        time_off = crud_time_off.create(&#10;            db=db,&#10;            obj_in=time_off_in,&#10;            company_id=company_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off created successfully&quot;,&#10;            data=time_off,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/time-offs&quot;, response_model=DataResponse[List[TimeOff]], status_code=status.HTTP_200_OK)&#10;async def get_all_user_time_offs(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    start_date: datetime = Query(datetime.today(), description=&quot;Filter time offs that end after this date&quot;),&#10;    availability_type: AvailabilityType = Query(AvailabilityType.WEEKLY, description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all time offs for the current user with optional date filtering.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        end_date = start_date + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        time_offs = crud_time_off.get_user_time_offs(&#10;            db=db,&#10;            company_id=company_id,&#10;            start_date=start_date,&#10;            end_date=end_date&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=time_offs,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve time offs: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_200_OK)&#10;async def update_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffUpdate,&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the time off by ID&#10;        time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;        if not time_off:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Time off not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if the time off belongs to the current user&#10;        if str(time_off.user_id) != str(current_user.id):&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                message=&quot;You don't have permission to update this time off&quot;,&#10;                status_code=status.HTTP_403_FORBIDDEN&#10;            )&#10;&#10;        # Determine the new start and end dates for overlap check&#10;        start_date = time_off_in.start_date if time_off_in.start_date is not None else time_off.start_date&#10;        end_date = time_off_in.end_date if time_off_in.end_date is not None else time_off.end_date&#10;&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=current_user.id,&#10;            start_date=start_date,&#10;            end_date=end_date,&#10;            exclude_id=time_off_id&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The updated time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the time off&#10;        updated_time_off = crud_time_off.update(&#10;            db=db,&#10;            db_obj=time_off,&#10;            obj_in=time_off_in&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off updated successfully&quot;,&#10;            data=updated_time_off,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def delete_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period.&#10;    &quot;&quot;&quot;&#10;    # Get the time off by ID&#10;    time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;    if not time_off:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            message=&quot;Time off not found&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    # Check if the time off belongs to the current user&#10;    if str(time_off.user_id) != str(current_user.id):&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            message=&quot;You don't have permission to delete this time off&quot;,&#10;            status_code=status.HTTP_403_FORBIDDEN&#10;        )&#10;&#10;    # Delete the time off&#10;    deleted = crud_time_off.delete(db=db, time_off_id=time_off_id)&#10;    if not deleted:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Failed to delete time off&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Time off deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=DataResponse[TokenResponse])&#10;async def refresh_token(&#10;    request: Request,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Refresh access and refresh tokens using the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        # Get the refresh token from the request cookies&#10;        refresh_token = request.cookies.get(&quot;refresh_token&quot;)&#10;        if not refresh_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Refresh token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the refresh token&#10;        payload = verify_token(refresh_token, &quot;refresh&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid refresh token&quot;&#10;            )&#10;&#10;        # Extract user data from payload&#10;        user_id = payload.get(&quot;sub&quot;)&#10;        email = payload.get(&quot;email&quot;)&#10;        company_id = payload.get(&quot;company_id&quot;)&#10;&#10;        if not user_id or not email:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid token payload&quot;&#10;            )&#10;&#10;        # Create new tokens&#10;        new_tokens = create_token_pair(&#10;            id=user_id,&#10;            email=email,&#10;            actor=&quot;user&quot;,&#10;            ver=&quot;1&quot;,&#10;            company_id=company_id&#10;        )&#10;&#10;        # Determine cookie domain - use shared domain for production&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;&#10;        # Set new cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=new_tokens[&quot;refresh_token&quot;],&#10;            max_age=new_tokens['rt_expires_in'],&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,&#10;            domain=cookie_domain&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=new_tokens[&quot;access_token&quot;],&#10;            max_age=new_tokens['at_expires_in'],&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,&#10;            domain=cookie_domain&#10;        )&#10;&#10;        return DataResponse.success_response(data=TokenResponse(**new_tokens))&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to refresh token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/verify-token&quot;, response_model=DataResponse[dict])&#10;async def verify_access_token(&#10;    request: Request,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify the access token and return the token data.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the access token from the request cookies&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Access token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the access token&#10;        payload = verify_token(access_token, &quot;access&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid or expired access token&quot;&#10;            )&#10;&#10;        # Return token validity info&#10;        return DataResponse.success_response(data={&#10;            &quot;valid&quot;: True,&#10;            &quot;user_id&quot;: payload.get(&quot;sub&quot;),&#10;            &quot;email&quot;: payload.get(&quot;email&quot;),&#10;            &quot;company_id&quot;: payload.get(&quot;company_id&quot;),&#10;            &quot;expires_at&quot;: payload.get(&quot;exp&quot;)&#10;        })&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to verify token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/google/authorize&quot;, response_model=GoogleAuthorizationResponse)&#10;async def google_authorize(&#10;    response: Response&#10;) -&gt; GoogleAuthorizationResponse:&#10;    &quot;&quot;&quot;&#10;    Initiate Google OAuth flow - returns authorization URL and state token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        state = GoogleOAuthService.generate_state_token()&#10;&#10;        # Store state in response cookie for verification later&#10;        response.set_cookie(&#10;            key=&quot;google_oauth_state&quot;,&#10;            value=state,&#10;            httponly=True,&#10;            secure=True,&#10;            samesite=&quot;lax&quot;,&#10;            max_age=600  # 10 minutes&#10;        )&#10;&#10;        authorization_url = GoogleOAuthService.get_authorization_url(state)&#10;&#10;        return GoogleAuthorizationResponse(&#10;            authorization_url=authorization_url,&#10;            state=state&#10;        )&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to initiate Google OAuth: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.get(&quot;/auth/google/callback&quot;, response_model=DataResponse[TokenResponse])&#10;async def google_callback(&#10;    request: Request,&#10;    response: Response,&#10;    state: str = Query(..., description=&quot;State token for CSRF protection&quot;),&#10;    code: str = Query(..., description=&quot;Authorization code from Google&quot;),&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Handle Google OAuth callback for both signup and login.&#10;    - If user exists: authenticates and returns tokens&#10;    - If user doesn't exist: creates new user with random password and returns tokens&#10;&#10;    This unified endpoint eliminates the need for separate signup/login paths.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        error = None&#10;        google_email = &quot;&quot;&#10;        google_name = &quot;Google User&quot;  # Initialize with default value&#10;        # Verify state token for CSRF protection&#10;        stored_state = request.cookies.get(&quot;google_oauth_state&quot;)&#10;        if not stored_state or stored_state != state:&#10;            error = 'Invalid state parameter'&#10;        else:&#10;            # Get redirect_uri from environment or default&#10;            redirect_uri = getattr(settings, 'GOOGLE_REDIRECT_URI', 'http://localhost:8000/api/v1/users/auth/google/callback')&#10;&#10;            # Exchange authorization code for tokens&#10;            token_response = GoogleOAuthService.exchange_code_for_token(&#10;                code,&#10;                redirect_uri&#10;            )&#10;            print(f'Token response: {token_response}')&#10;            if not token_response:&#10;                error = 'Failed to exchange authorization code for tokens'&#10;            else:&#10;                access_token = token_response.get(&quot;access_token&quot;)&#10;                if not access_token:&#10;                    error = 'No access token in response'&#10;&#10;                else:&#10;                    # Get user info from Google&#10;                    user_info = GoogleOAuthService.get_user_info(access_token)&#10;&#10;                    if not user_info:&#10;                        error = 'Failed to retrieve user information from Google'&#10;&#10;                    else:&#10;                        google_email = user_info.get(&quot;email&quot;, &quot;&quot;).lower()&#10;                        google_name = user_info.get(&quot;name&quot;, &quot;Google User&quot;)&#10;&#10;                        if not google_email:&#10;                            error = 'Google account does not have an email'&#10;&#10;        if error:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=error&#10;            )&#10;        # Check if user already exists&#10;        user = crud_user.get_by_email(db=db, email=google_email)&#10;&#10;        if user:&#10;            # User exists - authenticate them&#10;            company = crud_user.get_company_by_user(db, user.id)&#10;            tokens = create_token_pair(&#10;                user.id,&#10;                user.email,&#10;                actor=&quot;user&quot;,&#10;                ver=&quot;1&quot;,&#10;                company_id=str(company.company_id) if company else ''&#10;            )&#10;            auth_message = &quot;Logged in successfully via Google&quot;&#10;        else:&#10;            # User doesn't exist - create new user with random password&#10;            random_password = GoogleOAuthService.generate_random_password()&#10;            hashed_password = hash_password(random_password)&#10;&#10;            # Parse name into first and last name&#10;            name_parts = google_name.split(&quot; &quot;, 1)&#10;            first_name = name_parts[0] if name_parts else &quot;User&quot;&#10;            last_name = name_parts[1] if len(name_parts) &gt; 1 else &quot;&quot;&#10;&#10;            # Create user object&#10;            user_create = UserCreate(&#10;                first_name=first_name,&#10;                last_name=last_name,&#10;                email=google_email,&#10;                password=hashed_password,&#10;                phone=&quot;&quot;  # Default empty phone for OAuth users&#10;            )&#10;&#10;            new_user, auth_message = await _create_new_user(&#10;                db=db,&#10;                user_in=user_create,&#10;                send_verification_email=False  # No email verification for OAuth users&#10;            )&#10;&#10;            # Create tokens for new user&#10;            tokens = create_token_pair(&#10;                new_user.id,&#10;                new_user.email,&#10;                actor=&quot;user&quot;,&#10;                ver=&quot;1&quot;,&#10;                company_id=&quot;&quot;&#10;            )&#10;            auth_message = &quot;Account created and logged in successfully via Google&quot;&#10;            user = new_user&#10;&#10;        # Set cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            max_age=tokens['rt_expires_in'],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;none&quot;&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=tokens[&quot;access_token&quot;],&#10;            max_age=tokens['at_expires_in'],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;none&quot;&#10;        )&#10;&#10;        # Clear the state cookie&#10;        response.delete_cookie(key=&quot;google_oauth_state&quot;)&#10;        return DataResponse.success_response(data = TokenResponse(**tokens))&#10;&#10;    except Exception as e:&#10;        return DataResponse.error_response(message=f&quot;Google OAuth process failed: {str(e)}&quot;, status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/dependencies.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/dependencies.py" />
              <option name="originalContent" value="from fastapi import Depends, HTTPException, status, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from app.db.session import get_db&#10;from app.schemas import User&#10;from app.services.auth import get_current_id, verify_token&#10;from app.services.crud import user as crud_user, customer as crud_customer, company as crud_company&#10;from app.models.models import Users, Customers, CompanyUsers&#10;from app.models.enums import CompanyRoleType&#10;&#10;&#10;async def get_current_user(&#10;    request: Request,&#10;    db: Session = Depends(get_db)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current authenticated user from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;    &#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract user ID from token (this will raise HTTPException with specific message if token is expired)&#10;    user_id = get_current_id(access_token)&#10;    if user_id is None:&#10;        raise credentials_exception&#10;&#10;    # Get user from database&#10;    user, company_id = crud_user.get(db, id=user_id)&#10;    if user is None:&#10;        raise credentials_exception&#10;&#10;    user.company_id = company_id&#10;    return user&#10;&#10;&#10;def get_current_customer(&#10;        request: Request,&#10;        db: Session = Depends(get_db)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current authenticated customer from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    try:&#10;        # Extract access token from HTTP-only cookie&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise credentials_exception&#10;&#10;        # Extract customer ID from token&#10;        customer_id = get_current_id(access_token)&#10;        if customer_id is None:&#10;            raise credentials_exception&#10;&#10;    except Exception:&#10;        raise credentials_exception&#10;&#10;    # Get customer from database&#10;    customer = crud_customer.get(db, id=customer_id)&#10;&#10;    if customer is None:&#10;        raise credentials_exception&#10;&#10;    return customer&#10;&#10;&#10;def get_token_payload(&#10;        request: Request&#10;) -&gt; dict:&#10;    &quot;&quot;&quot;Extract and return the payload from the JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract payload from token (this will raise HTTPException with specific message if token is expired)&#10;    payload = verify_token(access_token)&#10;    if payload is None:&#10;        raise credentials_exception&#10;&#10;    return payload&#10;&#10;&#10;def get_current_company_id(token_payload: dict = Depends(get_token_payload)) -&gt; str:&#10;    company_id = token_payload.get(&quot;company_id&quot;)&#10;    if not company_id:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            detail=&quot;Company ID not found in token&quot;&#10;        )&#10;    return company_id&#10;&#10;&#10;async def get_current_active_user(&#10;    current_user: Users = Depends(get_current_user)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_user&#10;&#10;&#10;async def get_current_company_user(&#10;        current_user: Users = Depends(get_current_user),&#10;        company_id: str = Depends(get_current_company_id),&#10;        db: Session = Depends(get_db)&#10;) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    company_user = crud_company.get_company_user(db, user_id=current_user.id, company_id=company_id)&#10;&#10;    return company_user&#10;&#10;&#10;async def get_current_active_customer(&#10;    current_customer: Customers = Depends(get_current_customer)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current active customer (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_customer&#10;&#10;&#10;async def get_current_user_role(&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_user),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Get the current user's role in the company.&quot;&quot;&quot;&#10;    company_user = db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == current_user.id,&#10;        CompanyUsers.company_id == company_id&#10;    ).first()&#10;&#10;    if not company_user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;User is not a member of this company&quot;&#10;        )&#10;&#10;    return company_user.role&#10;&#10;&#10;def require_role(allowed_roles: List[CompanyRoleType]):&#10;    &quot;&quot;&quot;&#10;    Dependency factory to check if user has one of the allowed roles.&#10;&#10;    Usage:&#10;        @router.get(&quot;/staff&quot;)&#10;        async def list_staff(&#10;            role: CompanyRoleType = Depends(require_role([CompanyRoleType.owner, CompanyRoleType.admin]))&#10;        ):&#10;            ...&#10;    &quot;&quot;&quot;&#10;    async def role_checker(&#10;        user_role: CompanyRoleType = Depends(get_current_user_role)&#10;    ) -&gt; CompanyRoleType:&#10;        if user_role not in allowed_roles:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                detail=f&quot;Insufficient permissions, contact your administrator&quot;&#10;            )&#10;        return user_role&#10;&#10;    return role_checker&#10;&#10;&#10;async def require_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require owner role.&quot;&quot;&quot;&#10;    if user_role != CompanyRoleType.owner:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_admin_or_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require admin or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners or admins can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_staff_or_higher(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require staff, admin, or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin, CompanyRoleType.staff]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company staff, admins, or owners can access this resource&quot;&#10;        )&#10;    return user_role&#10;" />
              <option name="updatedContent" value="from fastapi import Depends, HTTPException, status, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from app.db.session import get_db&#10;from app.schemas import User&#10;from app.services.auth import get_current_id, verify_token&#10;from app.services.crud import user as crud_user, customer as crud_customer, company as crud_company&#10;from app.models.models import Users, Customers, CompanyUsers&#10;from app.models.enums import CompanyRoleType&#10;&#10;&#10;async def get_current_user(&#10;    request: Request,&#10;    db: Session = Depends(get_db)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current authenticated user from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;    &#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract user ID from token (this will raise HTTPException with specific message if token is expired)&#10;    user_id = get_current_id(access_token)&#10;    if user_id is None:&#10;        raise credentials_exception&#10;&#10;    # Get user from database&#10;    user, company_id = crud_user.get(db, id=user_id)&#10;    if user is None:&#10;        raise credentials_exception&#10;&#10;    user.company_id = company_id&#10;    return user&#10;&#10;&#10;def get_current_customer(&#10;        request: Request,&#10;        db: Session = Depends(get_db)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current authenticated customer from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    try:&#10;        # Extract access token from HTTP-only cookie&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise credentials_exception&#10;&#10;        # Extract customer ID from token&#10;        customer_id = get_current_id(access_token)&#10;        if customer_id is None:&#10;            raise credentials_exception&#10;&#10;    except Exception:&#10;        raise credentials_exception&#10;&#10;    # Get customer from database&#10;    customer = crud_customer.get(db, id=customer_id)&#10;&#10;    if customer is None:&#10;        raise credentials_exception&#10;&#10;    return customer&#10;&#10;&#10;def get_token_payload(&#10;        request: Request&#10;) -&gt; dict:&#10;    &quot;&quot;&quot;Extract and return the payload from the JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract payload from token (this will raise HTTPException with specific message if token is expired)&#10;    payload = verify_token(access_token)&#10;    if payload is None:&#10;        raise credentials_exception&#10;&#10;    return payload&#10;&#10;&#10;def get_current_company_id(token_payload: dict = Depends(get_token_payload)) -&gt; str:&#10;    company_id = token_payload.get(&quot;company_id&quot;)&#10;    if not company_id:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            detail=&quot;Company ID not found in token&quot;&#10;        )&#10;    return company_id&#10;&#10;&#10;async def get_current_active_user(&#10;    current_user: Users = Depends(get_current_user)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_user&#10;&#10;&#10;async def get_current_company_user(&#10;        current_user: Users = Depends(get_current_user),&#10;        company_id: str = Depends(get_current_company_id),&#10;        db: Session = Depends(get_db)&#10;) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    company_user = crud_company.get_company_user(db, user_id=current_user.id, company_id=company_id)&#10;&#10;    return company_user&#10;&#10;&#10;async def get_current_active_customer(&#10;    current_customer: Customers = Depends(get_current_customer)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current active customer (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_customer&#10;&#10;&#10;async def get_current_user_role(&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_user),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Get the current user's role in the company.&quot;&quot;&quot;&#10;    company_user = db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == current_user.id,&#10;        CompanyUsers.company_id == company_id&#10;    ).first()&#10;&#10;    if not company_user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;User is not a member of this company&quot;&#10;        )&#10;&#10;    return company_user.role&#10;&#10;&#10;def require_role(allowed_roles: List[CompanyRoleType]):&#10;    &quot;&quot;&quot;&#10;    Dependency factory to check if user has one of the allowed roles.&#10;&#10;    Usage:&#10;        @router.get(&quot;/staff&quot;)&#10;        async def list_staff(&#10;            role: CompanyRoleType = Depends(require_role([CompanyRoleType.owner, CompanyRoleType.admin]))&#10;        ):&#10;            ...&#10;    &quot;&quot;&quot;&#10;    async def role_checker(&#10;        user_role: CompanyRoleType = Depends(get_current_user_role)&#10;    ) -&gt; CompanyRoleType:&#10;        if user_role not in allowed_roles:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                detail=f&quot;Insufficient permissions, contact your administrator&quot;&#10;            )&#10;        return user_role&#10;&#10;    return role_checker&#10;&#10;&#10;async def require_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require owner role.&quot;&quot;&quot;&#10;    if user_role != CompanyRoleType.owner:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_admin_or_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require admin or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners or admins can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_staff_or_higher(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require staff, admin, or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin, CompanyRoleType.staff]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company staff, admins, or owners can access this resource&quot;&#10;        )&#10;    return user_role" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/schemas/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/schemas/schemas.py" />
              <option name="originalContent" value="from datetime import datetime, date, time, timezone&#10;from decimal import Decimal&#10;from typing import Optional, List, Annotated&#10;from pydantic import BaseModel, Field, field_validator, ConfigDict, UUID4, EmailStr&#10;&#10;from app.models import CustomerStatusType, CompanyCategories&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType, EmailStatusType, PhoneStatusType, NotificationType, NotificationStatus, CompanyRoleType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    company_id: Optional[UUID4] = None&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(TimestampedModel):&#10;    id: UUID4&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;&#10;    user: Optional[User] = None&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;&#10;class CompanyUserUpdate(BaseModel):&#10;    role: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.active&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class CompanyUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    type: Optional[str] = None&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    id: Optional[UUID4] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: Optional[UUID4] = None&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: Optional[UUID4] = None&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    start_time: Optional[datetime] = None&#10;    notes: Optional[str] = None&#10;    status: Optional[BookingStatus] = None&#10;    services: Optional[List[BookingServiceRequest]] = None&#10;&#10;&#10;class ServiceStaff(BaseModel):&#10;    &quot;&quot;&quot;Schema for the service_staff junction table linking services to staff members&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;    # Optional nested user information&#10;    user: Optional['User'] = None&#10;&#10;&#10;class ServiceStaffCreate(BaseModel):&#10;    &quot;&quot;&quot;Schema for creating service-staff assignments&quot;&quot;&quot;&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;class ServiceStaffResponse(BaseModel):&#10;    &quot;&quot;&quot;Simplified response schema for staff assigned to a service&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    name: str&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    service_staff: Optional[List['ServiceStaff']] = []  # List of staff assigned to this service&#10;&#10;&#10;class StaffMember(BaseModel):&#10;    &quot;&quot;&quot;Simple staff member schema for booking assignments&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class BookingService(TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    booking_id: UUID4&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;    start_date: Optional[datetime] = None&#10;    end_date: Optional[datetime] = None&#10;&#10;    category_service: Optional[CategoryServiceResponse] = None&#10;    assigned_staff: Optional[User] = None  # Changed from assigned_staff to match the model relationship&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;    customer: Optional[Customer] = None&#10;    booking_services: Optional[List[BookingService]] = []&#10;    user_ids: set[str] = set([])&#10;&#10;&#10;#&#10;class CompanyCustomers(Company):&#10;&#10;    model_config = ConfigDict(from_attributes=True)&#10;    customers: List[Customer] = []&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: Optional[str]&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceBase(BaseModel):&#10;    name: str&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;&#10;class CategoryServiceCreate(CategoryServiceBase):&#10;    category_id: str&#10;    staff_ids: List[UUID4] = []  # List of staff member IDs to assign to this service&#10;&#10;class CategoryServiceUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    duration: Optional[int] = None&#10;    price: Optional[float] = None&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    buffer_before: Optional[int] = None&#10;    buffer_after: Optional[int] = None&#10;    staff_ids: Optional[List[UUID4]] = None  # List of staff member IDs to assign to this service&#10;&#10;&#10;class CompanyCategoryBase(BaseModel):&#10;    name: str&#10;    description: Optional[str] = None&#10;&#10;class CompanyCategoryCreate(CompanyCategoryBase):&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyCategoryUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    description: Optional[str] = None&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyCategory(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;# CompanyCategoryWithServicesResponse already exists&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []&#10;&#10;# Time Off schemas&#10;class TimeOffBase(BaseModel):&#10;    start_date: datetime&#10;    end_date: datetime&#10;    user_id: UUID4&#10;    reason: Optional[str] = None&#10;&#10;class TimeOffCreate(TimeOffBase):&#10;    pass&#10;&#10;class TimeOffUpdate(BaseModel):&#10;    start_date: Optional[date] = None&#10;    end_date: Optional[date] = None&#10;    reason: Optional[str] = None&#10;&#10;class TimeOff(TimeOffBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user: User&#10;&#10;&#10;class CompanyEmailBase(BaseModel):&#10;    email: EmailStr&#10;    status: EmailStatusType = EmailStatusType.unverified&#10;&#10;class CompanyEmailCreate(BaseModel):&#10;    emails: List[CompanyEmailBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyEmail(CompanyEmailBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyPhoneBase(BaseModel):&#10;    phone: str&#10;    is_primary: bool = False&#10;    status: PhoneStatusType = PhoneStatusType.unverified&#10;&#10;class CompanyPhoneCreate(BaseModel):&#10;    company_phones: List[CompanyPhoneBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyPhone(CompanyPhoneBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;# Company Address schemas&#10;class CompanyAddressBase(BaseModel):&#10;    address: str&#10;    city: str&#10;    zip: Optional[str] = None&#10;    country: str&#10;    is_primary: bool = False&#10;&#10;&#10;class CompanyAddressResponse(CompanyAddressBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class NotificationBase(BaseModel):&#10;    type: NotificationType&#10;    message: str&#10;    data: Optional[str] = None&#10;    status: NotificationStatus = NotificationStatus.UNREAD&#10;    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))&#10;&#10;&#10;class NotificationCreate(NotificationBase):&#10;    pass&#10;&#10;&#10;class CompanyNotificationCreate(NotificationCreate):&#10;    company_id: Optional[UUID4] = None&#10;&#10;&#10;class NotificationUpdate(BaseModel):&#10;    status: Optional[NotificationStatus] = None&#10;&#10;class Notification(NotificationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyMemberCreate(BaseModel):&#10;    user: UserCreate&#10;    company_id: UUID4&#10;    role: CompanyRoleType&#10;&#10;&#10;# Telegram Integration schemas&#10;class TelegramIntegrationBase(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;&#10;&#10;class TelegramIntegrationCreate(TelegramIntegrationBase):&#10;    bot_token: str&#10;&#10;&#10;class TelegramIntegrationUpdate(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    bot_token: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class TelegramIntegration(TelegramIntegrationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    bot_token: Optional[str] = None  # Decrypted token returned in response&#10;&#10;&#10;# Invitation schemas&#10;class InvitationBase(BaseModel):&#10;    email: str&#10;    role: Optional[CompanyRoleType] = CompanyRoleType.staff&#10;&#10;&#10;class InvitationCreate(InvitationBase):&#10;    pass&#10;&#10;&#10;class InvitationAccept(BaseModel):&#10;    token: str&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    phone: Optional[str] = None&#10;    password: Optional[str] = None  # Only required if user doesn't exist&#10;&#10;&#10;class Invitation(InvitationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    token: Optional[str] = None  # Don't expose token in responses&#10;    status: str&#10;" />
              <option name="updatedContent" value="from datetime import datetime, date, time, timezone&#10;from decimal import Decimal&#10;from typing import Optional, List, Annotated&#10;from pydantic import BaseModel, Field, field_validator, ConfigDict, UUID4, EmailStr&#10;&#10;from app.models import CustomerStatusType, CompanyCategories&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType, EmailStatusType, PhoneStatusType, NotificationType, NotificationStatus, CompanyRoleType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    company_id: Optional[UUID4] = None&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(TimestampedModel):&#10;    id: UUID4&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;&#10;    user: Optional[User] = None&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;&#10;class CompanyUserUpdate(BaseModel):&#10;    role: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.active&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class CompanyUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    type: Optional[str] = None&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    id: Optional[UUID4] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: Optional[UUID4] = None&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: Optional[UUID4] = None&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    start_time: Optional[datetime] = None&#10;    notes: Optional[str] = None&#10;    status: Optional[BookingStatus] = None&#10;    services: Optional[List[BookingServiceRequest]] = None&#10;&#10;&#10;class ServiceStaff(BaseModel):&#10;    &quot;&quot;&quot;Schema for the service_staff junction table linking services to staff members&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;    # Optional nested user information&#10;    user: Optional['User'] = None&#10;&#10;&#10;class ServiceStaffCreate(BaseModel):&#10;    &quot;&quot;&quot;Schema for creating service-staff assignments&quot;&quot;&quot;&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;class ServiceStaffResponse(BaseModel):&#10;    &quot;&quot;&quot;Simplified response schema for staff assigned to a service&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    name: str&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    service_staff: Optional[List['ServiceStaff']] = []  # List of staff assigned to this service&#10;&#10;&#10;class StaffMember(BaseModel):&#10;    &quot;&quot;&quot;Simple staff member schema for booking assignments&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class BookingService(TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    booking_id: UUID4&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;    start_date: Optional[datetime] = None&#10;    end_date: Optional[datetime] = None&#10;&#10;    category_service: Optional[CategoryServiceResponse] = None&#10;    assigned_staff: Optional[User] = None  # Changed from assigned_staff to match the model relationship&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;    customer: Optional[Customer] = None&#10;    booking_services: Optional[List[BookingService]] = []&#10;    user_ids: set[str] = set([])&#10;&#10;&#10;#&#10;class CompanyCustomers(Company):&#10;&#10;    model_config = ConfigDict(from_attributes=True)&#10;    customers: List[Customer] = []&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: Optional[str]&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceBase(BaseModel):&#10;    name: str&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;&#10;class CategoryServiceCreate(CategoryServiceBase):&#10;    category_id: str&#10;    staff_ids: List[UUID4] = []  # List of staff member IDs to assign to this service&#10;&#10;class CategoryServiceUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    duration: Optional[int] = None&#10;    price: Optional[float] = None&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    buffer_before: Optional[int] = None&#10;    buffer_after: Optional[int] = None&#10;    staff_ids: Optional[List[UUID4]] = None  # List of staff member IDs to assign to this service&#10;&#10;&#10;class CompanyCategoryBase(BaseModel):&#10;    name: str&#10;    description: Optional[str] = None&#10;&#10;class CompanyCategoryCreate(CompanyCategoryBase):&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyCategoryUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    description: Optional[str] = None&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyCategory(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;# CompanyCategoryWithServicesResponse already exists&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []&#10;&#10;# Time Off schemas&#10;class TimeOffBase(BaseModel):&#10;    start_date: datetime&#10;    end_date: datetime&#10;    user_id: UUID4&#10;    reason: Optional[str] = None&#10;&#10;class TimeOffCreate(TimeOffBase):&#10;    pass&#10;&#10;class TimeOffUpdate(BaseModel):&#10;    start_date: Optional[date] = None&#10;    end_date: Optional[date] = None&#10;    reason: Optional[str] = None&#10;&#10;class TimeOff(TimeOffBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user: User&#10;&#10;&#10;class CompanyEmailBase(BaseModel):&#10;    email: EmailStr&#10;    status: EmailStatusType = EmailStatusType.unverified&#10;&#10;class CompanyEmailCreate(BaseModel):&#10;    emails: List[CompanyEmailBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyEmail(CompanyEmailBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyPhoneBase(BaseModel):&#10;    phone: str&#10;    is_primary: bool = False&#10;    status: PhoneStatusType = PhoneStatusType.unverified&#10;&#10;class CompanyPhoneCreate(BaseModel):&#10;    company_phones: List[CompanyPhoneBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyPhone(CompanyPhoneBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;# Company Address schemas&#10;class CompanyAddressBase(BaseModel):&#10;    address: str&#10;    city: str&#10;    zip: Optional[str] = None&#10;    country: str&#10;    is_primary: bool = False&#10;&#10;&#10;class CompanyAddressResponse(CompanyAddressBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class NotificationBase(BaseModel):&#10;    type: NotificationType&#10;    message: str&#10;    data: Optional[str] = None&#10;    status: NotificationStatus = NotificationStatus.UNREAD&#10;    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))&#10;&#10;&#10;class NotificationCreate(NotificationBase):&#10;    pass&#10;&#10;&#10;class CompanyNotificationCreate(NotificationCreate):&#10;    company_id: Optional[UUID4] = None&#10;&#10;&#10;class NotificationUpdate(BaseModel):&#10;    status: Optional[NotificationStatus] = None&#10;&#10;class Notification(NotificationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyMemberCreate(BaseModel):&#10;    user: UserCreate&#10;    company_id: UUID4&#10;    role: CompanyRoleType&#10;&#10;&#10;# Telegram Integration schemas&#10;class TelegramIntegrationBase(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;&#10;&#10;class TelegramIntegrationCreate(TelegramIntegrationBase):&#10;    bot_token: str&#10;&#10;&#10;class TelegramIntegrationUpdate(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    bot_token: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class TelegramIntegration(TelegramIntegrationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    bot_token: Optional[str] = None  # Decrypted token returned in response&#10;&#10;&#10;# Invitation schemas&#10;class InvitationBase(BaseModel):&#10;    email: str&#10;    role: Optional[CompanyRoleType] = CompanyRoleType.staff&#10;&#10;&#10;class InvitationCreate(InvitationBase):&#10;    pass&#10;&#10;&#10;class InvitationAccept(BaseModel):&#10;    token: str&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    phone: Optional[str] = None&#10;    password: Optional[str] = None  # Only required if user doesn't exist&#10;&#10;&#10;class Invitation(InvitationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    token: Optional[str] = None  # Don't expose token in responses&#10;    status: str&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/customer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/customer.py" />
              <option name="originalContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime, timezone&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import Companies, Bookings&#10;from app.models.models import (Customers, CustomerVerifications, CustomerEmails)&#10;from app.models.enums import VerificationStatus&#10;from app.schemas import CompanyCustomers&#10;from app.schemas.schemas import (&#10;    CustomerCreate, CustomerUpdate&#10;)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Customers]:&#10;    return db.query(Customers).filter(Customers.id == id).first()&#10;&#10;def get_by_email(db: Session, email: str) -&gt; Optional[Customers]:&#10;    return db.query(Customers).filter(Customers.email == email).first()&#10;&#10;def create(db: Session, *, obj_in: CustomerCreate) -&gt; Customers:&#10;    db_obj = Customers(**obj_in.model_dump())&#10;    db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def create_customer_email(db: Session, customer_id: int, email: str, status: str) -&gt; CustomerEmails:&#10;    db_obj = CustomerEmails(customer_id=customer_id, email=email, status=status)&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def update(db: Session, *, db_obj: Customers, obj_in: CustomerUpdate) -&gt; Customers:&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;    &#10;    # Ensure updated_at is set to current UTC time&#10;    db_obj.updated_at = utcnow()&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def get_verification_token(db: Session, token: str, type: str) -&gt; Optional[CustomerVerifications]:&#10;    return db.query(CustomerVerifications).filter(CustomerVerifications.token == token,&#10;                                                  CustomerVerifications.type == type).first()&#10;&#10;def verify_token(db: Session, db_obj: CustomerVerifications) -&gt; bool:&#10;    try:&#10;        db_obj.status = VerificationStatus.VERIFIED&#10;        db_obj.used_at = utcnow()&#10;        &#10;        # Update customer's email verification status&#10;        customer = db.query(Customers).filter(Customers.id == db_obj.customer_id).first()&#10;        if customer:&#10;            customer.email_verified = True&#10;            customer.updated_at = utcnow()&#10;            db.add(customer)&#10;        &#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return True&#10;    except Exception:&#10;        db.rollback()&#10;        return False&#10;&#10;def get_company_customers(db: Session, company_id: str) -&gt; List[CompanyCustomers]:&#10;    customers = (&#10;        db.query(Customers)&#10;        .join(Bookings, Customers.id == Bookings.customer_id)&#10;        .filter(Bookings.company_id == company_id)&#10;        .all()&#10;    )&#10;    &#10;    return [&#10;        CompanyCustomers(&#10;            id=customer.id,&#10;            first_name=customer.first_name,&#10;            last_name=customer.last_name,&#10;            email=customer.email,&#10;            phone=customer.phone,&#10;            status=customer.status,&#10;            email_verified=customer.email_verified,&#10;            created_at=customer.created_at,&#10;            updated_at=customer.updated_at&#10;        )&#10;        for customer in customers&#10;    ]" />
              <option name="updatedContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime, timezone&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import Companies, Bookings&#10;from app.models.models import (Customers, CustomerVerifications, CustomerEmails)&#10;from app.models.enums import VerificationStatus&#10;from app.schemas import CompanyCustomers&#10;from app.schemas.schemas import (&#10;    CustomerCreate, CustomerUpdate&#10;)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Customers]:&#10;    return db.query(Customers).filter(Customers.id == id).first()&#10;&#10;def get_by_email(db: Session, email: str) -&gt; Optional[Customers]:&#10;    return db.query(Customers).filter(Customers.email == email).first()&#10;&#10;def create(db: Session, *, obj_in: CustomerCreate) -&gt; Customers:&#10;    db_obj = Customers(**obj_in.model_dump())&#10;    db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def create_customer_email(db: Session, customer_id: int, email: str, status: str) -&gt; CustomerEmails:&#10;    db_obj = CustomerEmails(customer_id=customer_id, email=email, status=status)&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def update(db: Session, *, db_obj: Customers, obj_in: CustomerUpdate) -&gt; Customers:&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;    &#10;    # Ensure updated_at is set to current UTC time&#10;    db_obj.updated_at = utcnow()&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def get_verification_token(db: Session, token: str, type: str) -&gt; Optional[CustomerVerifications]:&#10;    return db.query(CustomerVerifications).filter(CustomerVerifications.token == token,&#10;                                                  CustomerVerifications.type == type).first()&#10;&#10;def verify_token(db: Session, db_obj: CustomerVerifications) -&gt; bool:&#10;    try:&#10;        db_obj.status = VerificationStatus.VERIFIED&#10;        db_obj.used_at = utcnow()&#10;        &#10;        # Update customer's email verification status&#10;        customer = db.query(Customers).filter(Customers.id == db_obj.customer_id).first()&#10;        if customer:&#10;            customer.email_verified = True&#10;            customer.updated_at = utcnow()&#10;            db.add(customer)&#10;        &#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return True&#10;    except Exception:&#10;        db.rollback()&#10;        return False&#10;&#10;def get_company_customers(db: Session, company_id: str) -&gt; List[CompanyCustomers]:&#10;    customers = (&#10;        db.query(Customers)&#10;        .join(Bookings, Customers.id == Bookings.customer_id)&#10;        .filter(Bookings.company_id == company_id)&#10;        .all()&#10;    )&#10;    &#10;    return [&#10;        CompanyCustomers(&#10;            id=customer.id,&#10;            first_name=customer.first_name,&#10;            last_name=customer.last_name,&#10;            email=customer.email,&#10;            phone=customer.phone,&#10;            status=customer.status,&#10;            email_verified=customer.email_verified,&#10;            created_at=customer.created_at,&#10;            updated_at=customer.updated_at&#10;        )&#10;        for customer in customers&#10;    ]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/invitation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/invitation.py" />
              <option name="originalContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime, timedelta, timezone&#10;from pydantic import UUID4&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy.exc import SQLAlchemyError&#10;&#10;from app.models.models import Invitations, CompanyUsers&#10;from app.schemas.schemas import Invitation&#10;from app.models.enums import InvitationStatus, StatusType, CompanyRoleType&#10;from app.core.datetime_utils import utcnow&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;def create_invitation(&#10;    db: Session,&#10;    company_id: str,&#10;    email: str,&#10;    role: CompanyRoleType = CompanyRoleType.staff,&#10;    token: str = None&#10;) -&gt; Invitation:&#10;    &quot;&quot;&quot;&#10;    Create a new invitation for a staff member.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        email: Email to invite&#10;        role: Role to assign (default: staff)&#10;        token: Invitation token (if not provided, one will be generated)&#10;&#10;    Returns:&#10;        Invitations: The created invitation record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        if not token:&#10;            token = str(uuid.uuid4())&#10;&#10;        # Check if an active invitation already exists for this email and company&#10;        existing = db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id,&#10;            Invitations.status == InvitationStatus.PENDING&#10;        ).first()&#10;&#10;        if existing:&#10;            # Update the existing invitation&#10;            existing.token = token&#10;            existing.role = role&#10;            existing.updated_at = utcnow()&#10;            db.add(existing)&#10;            db.commit()&#10;            db.refresh(existing)&#10;&#10;            return Invitation.model_validate(existing)&#10;&#10;        # Create new invitation&#10;        invitation = Invitations(&#10;            id=str(uuid.uuid4()),&#10;            email=email,&#10;            token=token,&#10;            role=role,&#10;            company_id=company_id,&#10;            status=InvitationStatus.PENDING&#10;        )&#10;        &#10;        db.add(invitation)&#10;        db.commit()&#10;        db.refresh(invitation)&#10;        return Invitation.model_validate(invitation)&#10;&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error creating invitation: {e}&quot;)&#10;        db.rollback()&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Unexpected error creating invitation: {e}&quot;)&#10;        db.rollback()&#10;        raise&#10;&#10;&#10;def get_invitation_by_token(db: Session, token: str) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get an invitation by token.&#10;&#10;    Args:&#10;        db: Database session&#10;        token: Invitation token&#10;&#10;    Returns:&#10;        Invitations: The invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.status == InvitationStatus.PENDING&#10;        ).first()&#10;&#10;        # Check if invitation has expired (older than 3 days)&#10;        if invitation:&#10;            expires_at = invitation.created_at + timedelta(days=3)&#10;            if datetime.now(timezone.utc) &gt; expires_at:&#10;                invitation.status = InvitationStatus.EXPIRED&#10;                db.add(invitation)&#10;                db.commit()&#10;                db.refresh(invitation)&#10;                return None&#10;&#10;        return invitation&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Unexpected error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def get_invitation_by_email_and_company(&#10;    db: Session,&#10;    email: str,&#10;    company_id: UUID4&#10;) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get an invitation by email and company.&#10;&#10;    Args:&#10;        db: Database session&#10;        email: Email address&#10;        company_id: Company ID&#10;&#10;    Returns:&#10;        Invitations: The invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id&#10;        ).first()&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def get_company_invitations(&#10;    db: Session,&#10;    company_id: str,&#10;    status: Optional[InvitationStatus] = None&#10;) -&gt; List[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company, optionally filtered by status.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        status: Optional status filter&#10;&#10;    Returns:&#10;        List[Invitations]: List of invitation records&#10;    &quot;&quot;&quot;&#10;    try:&#10;        query = db.query(Invitations).filter(&#10;            Invitations.company_id == company_id, Invitations.status != 'used'&#10;        )&#10;&#10;        if status:&#10;            query = query.filter(Invitations.status == status)&#10;&#10;        return query.all()&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitations: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def accept_invitation(&#10;    db: Session,&#10;    invitation: Invitations,&#10;    user_id: UUID4&#10;) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Accept an invitation and add user to company.&#10;&#10;    Args:&#10;        db: Database session&#10;        invitation: Invitation record&#10;        user_id: User ID&#10;&#10;    Returns:&#10;        bool: True if successful&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Update invitation status&#10;        invitation.status = InvitationStatus.USED&#10;        invitation.updated_at = utcnow()&#10;        db.add(invitation)&#10;&#10;        # Check if user is already a company member&#10;        existing_member = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == user_id,&#10;            CompanyUsers.company_id == invitation.company_id&#10;        ).first()&#10;&#10;        if not existing_member:&#10;            # Add user to company&#10;            company_user = CompanyUsers(&#10;                id=uuid.uuid4(),&#10;                user_id=user_id,&#10;                company_id=invitation.company_id,&#10;                role=invitation.role,&#10;                status=StatusType.active&#10;            )&#10;            db.add(company_user)&#10;        else:&#10;            # If already a member, update their role and status&#10;            existing_member.role = invitation.role&#10;            existing_member.status = StatusType.active&#10;            db.add(existing_member)&#10;&#10;        db.commit()&#10;        return True&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while accepting invitation: {str(e)}&quot;)&#10;        raise&#10;    except Exception as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Unexpected error while accepting invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def decline_invitation(db: Session, token: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Decline an invitation.&#10;&#10;    Args:&#10;        db: Database session&#10;        token: Invitation token&#10;&#10;    Returns:&#10;        bool: True if successful&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return False&#10;&#10;        invitation.status = InvitationStatus.DECLINED&#10;        invitation.updated_at = utcnow()&#10;        db.add(invitation)&#10;        db.commit()&#10;        return True&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while declining invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def resend_invitation(&#10;    db: Session,&#10;    company_id: UUID4,&#10;    email: str&#10;) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation by generating a new token.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        email: Email address&#10;&#10;    Returns:&#10;        Invitations: The updated invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id,&#10;            Invitations.status.in_([InvitationStatus.PENDING, InvitationStatus.EXPIRED])&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return None&#10;&#10;        # Generate new token and reset to pending&#10;        invitation.token = str(uuid.uuid4())&#10;        invitation.status = InvitationStatus.PENDING&#10;        invitation.created_at = utcnow()&#10;        invitation.updated_at = utcnow()&#10;&#10;        db.add(invitation)&#10;        db.commit()&#10;        db.refresh(invitation)&#10;        return invitation&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while resending invitation: {str(e)}&quot;)&#10;        raise&#10;" />
              <option name="updatedContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime, timedelta, timezone&#10;from pydantic import UUID4&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy.exc import SQLAlchemyError&#10;&#10;from app.models.models import Invitations, CompanyUsers&#10;from app.schemas.schemas import Invitation&#10;from app.models.enums import InvitationStatus, StatusType, CompanyRoleType&#10;from app.core.datetime_utils import utcnow&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;def create_invitation(&#10;    db: Session,&#10;    company_id: str,&#10;    email: str,&#10;    role: CompanyRoleType = CompanyRoleType.staff,&#10;    token: str = None&#10;) -&gt; Invitation:&#10;    &quot;&quot;&quot;&#10;    Create a new invitation for a staff member.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        email: Email to invite&#10;        role: Role to assign (default: staff)&#10;        token: Invitation token (if not provided, one will be generated)&#10;&#10;    Returns:&#10;        Invitations: The created invitation record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        if not token:&#10;            token = str(uuid.uuid4())&#10;&#10;        # Check if an active invitation already exists for this email and company&#10;        existing = db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id,&#10;            Invitations.status == InvitationStatus.PENDING&#10;        ).first()&#10;&#10;        if existing:&#10;            # Update the existing invitation&#10;            existing.token = token&#10;            existing.role = role&#10;            existing.updated_at = utcnow()&#10;            db.add(existing)&#10;            db.commit()&#10;            db.refresh(existing)&#10;&#10;            return Invitation.model_validate(existing)&#10;&#10;        # Create new invitation&#10;        invitation = Invitations(&#10;            id=str(uuid.uuid4()),&#10;            email=email,&#10;            token=token,&#10;            role=role,&#10;            company_id=company_id,&#10;            status=InvitationStatus.PENDING&#10;        )&#10;        &#10;        db.add(invitation)&#10;        db.commit()&#10;        db.refresh(invitation)&#10;        return Invitation.model_validate(invitation)&#10;&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error creating invitation: {e}&quot;)&#10;        db.rollback()&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Unexpected error creating invitation: {e}&quot;)&#10;        db.rollback()&#10;        raise&#10;&#10;&#10;def get_invitation_by_token(db: Session, token: str) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get an invitation by token.&#10;&#10;    Args:&#10;        db: Database session&#10;        token: Invitation token&#10;&#10;    Returns:&#10;        Invitations: The invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.status == InvitationStatus.PENDING&#10;        ).first()&#10;&#10;        # Check if invitation has expired (older than 3 days)&#10;        if invitation:&#10;            expires_at = invitation.created_at + timedelta(days=3)&#10;            if datetime.now(timezone.utc) &gt; expires_at:&#10;                invitation.status = InvitationStatus.EXPIRED&#10;                db.add(invitation)&#10;                db.commit()&#10;                db.refresh(invitation)&#10;                return None&#10;&#10;        return invitation&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Unexpected error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def get_invitation_by_email_and_company(&#10;    db: Session,&#10;    email: str,&#10;    company_id: UUID4&#10;) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get an invitation by email and company.&#10;&#10;    Args:&#10;        db: Database session&#10;        email: Email address&#10;        company_id: Company ID&#10;&#10;    Returns:&#10;        Invitations: The invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id&#10;        ).first()&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def get_company_invitations(&#10;    db: Session,&#10;    company_id: str,&#10;    status: Optional[InvitationStatus] = None&#10;) -&gt; List[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company, optionally filtered by status.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        status: Optional status filter&#10;&#10;    Returns:&#10;        List[Invitations]: List of invitation records&#10;    &quot;&quot;&quot;&#10;    try:&#10;        query = db.query(Invitations).filter(&#10;            Invitations.company_id == company_id, Invitations.status != 'used'&#10;        )&#10;&#10;        if status:&#10;            query = query.filter(Invitations.status == status)&#10;&#10;        return query.all()&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitations: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def accept_invitation(&#10;    db: Session,&#10;    invitation: Invitations,&#10;    user_id: UUID4&#10;) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Accept an invitation and add user to company.&#10;&#10;    Args:&#10;        db: Database session&#10;        invitation: Invitation record&#10;        user_id: User ID&#10;&#10;    Returns:&#10;        bool: True if successful&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Update invitation status&#10;        invitation.status = InvitationStatus.USED&#10;        invitation.updated_at = utcnow()&#10;        db.add(invitation)&#10;&#10;        # Check if user is already a company member&#10;        existing_member = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == user_id,&#10;            CompanyUsers.company_id == invitation.company_id&#10;        ).first()&#10;&#10;        if not existing_member:&#10;            # Add user to company&#10;            company_user = CompanyUsers(&#10;                id=uuid.uuid4(),&#10;                user_id=user_id,&#10;                company_id=invitation.company_id,&#10;                role=invitation.role,&#10;                status=StatusType.active&#10;            )&#10;            db.add(company_user)&#10;        else:&#10;            # If already a member, update their role and status&#10;            existing_member.role = invitation.role&#10;            existing_member.status = StatusType.active&#10;            db.add(existing_member)&#10;&#10;        db.commit()&#10;        return True&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while accepting invitation: {str(e)}&quot;)&#10;        raise&#10;    except Exception as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Unexpected error while accepting invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def decline_invitation(db: Session, token: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Decline an invitation.&#10;&#10;    Args:&#10;        db: Database session&#10;        token: Invitation token&#10;&#10;    Returns:&#10;        bool: True if successful&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return False&#10;&#10;        invitation.status = InvitationStatus.DECLINED&#10;        invitation.updated_at = utcnow()&#10;        db.add(invitation)&#10;        db.commit()&#10;        return True&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while declining invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def resend_invitation(&#10;    db: Session,&#10;    company_id: UUID4,&#10;    email: str&#10;) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation by generating a new token.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        email: Email address&#10;&#10;    Returns:&#10;        Invitations: The updated invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id,&#10;            Invitations.status.in_([InvitationStatus.PENDING, InvitationStatus.EXPIRED])&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return None&#10;&#10;        # Generate new token and reset to pending&#10;        invitation.token = str(uuid.uuid4())&#10;        invitation.status = InvitationStatus.PENDING&#10;        invitation.created_at = utcnow()&#10;        invitation.updated_at = utcnow()&#10;&#10;        db.add(invitation)&#10;        db.commit()&#10;        db.refresh(invitation)&#10;        return invitation&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while resending invitation: {str(e)}&quot;)&#10;        raise" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/user.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/user.py" />
              <option name="originalContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime, timezone&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyUsers, CustomerStatusType&#10;from app.models.models import Users, UserVerifications&#10;from app.models.enums import VerificationStatus&#10;from app.schemas import CompanyUser, User&#10;from app.schemas.schemas import (&#10;    UserCreate, UserUpdate&#10;)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Users]:&#10;    return db.query(Users, CompanyUsers.company_id).outerjoin(CompanyUsers, CompanyUsers.user_id == Users.id).filter(Users.id == id).first()&#10;&#10;&#10;def get_all(db: Session) -&gt; List[Users]:&#10;    return db.query(Users).all()&#10;&#10;&#10;def get_by_email(db: Session, email: str) -&gt; Optional[Users]:&#10;    return db.query(Users).filter(Users.email == email).first()&#10;&#10;&#10;def create(db: Session, *, obj_in: UserCreate) -&gt; Users:&#10;    db_obj = Users(**obj_in.model_dump())&#10;    db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Users, obj_in: UserUpdate) -&gt; Users:&#10;    &quot;&quot;&quot;Update user information&quot;&quot;&quot;&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    &#10;    # If email is being updated, check if it's already in use by another user&#10;    if 'email' in update_data and update_data['email']:&#10;        existing_user = get_by_email(db, email=update_data['email'])&#10;        if existing_user and existing_user.id != db_obj.id:&#10;            raise ValueError(&quot;Email is already in use by another user&quot;)&#10;    &#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;    &#10;    # Ensure updated_at is set to current UTC time&#10;    db_obj.updated_at = utcnow()&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def get_verification_token(db: Session, token: str, type: str) -&gt; Optional[UserVerifications]:&#10;    &quot;&quot;&quot;Get verification token by token string and type&quot;&quot;&quot;&#10;    return db.query(UserVerifications).filter(&#10;        UserVerifications.token == token,&#10;        UserVerifications.type == type&#10;    ).first()&#10;&#10;&#10;def verify_token(db: Session, db_obj: UserVerifications) -&gt; bool:&#10;    &quot;&quot;&quot;Mark verification token as verified and update user email_verified status&quot;&quot;&quot;&#10;    try:&#10;        db_obj.status = VerificationStatus.VERIFIED&#10;        db_obj.used_at = utcnow()&#10;&#10;        # Update user's email_verified status&#10;        user = db.query(Users).filter(Users.id == db_obj.user_id).first()&#10;        if user:&#10;            user.email_verified = True&#10;            user.status = CustomerStatusType.active&#10;            user.updated_at = utcnow()&#10;            db.add(user)&#10;&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return True&#10;    except Exception:&#10;        db.rollback()&#10;        return False&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUser]:&#10;    &quot;&quot;&quot;&#10;    Get all users for a company&#10;    &quot;&quot;&quot;&#10;    users = db.query(CompanyUsers).join(Users, Users.id == CompanyUsers.user_id).filter(&#10;        Users.status == 'active', CompanyUsers.company_id == company_id, CompanyUsers.status == 'active'&#10;    ).all()&#10;    # result = []&#10;    # for company_user, user in users:&#10;    #     result.append(CompanyUser(&#10;    #         user_id=company_user.user_id,&#10;    #         company_id=company_user.company_id,&#10;    #         role=company_user.role,&#10;    #         status=company_user.status,&#10;    #         user=User(&#10;    #             id=user.id,&#10;    #             first_name=user.first_name,&#10;    #             last_name=user.last_name,&#10;    #             email=user.email,&#10;    #             phone=user.phone,&#10;    #             status=user.status,&#10;    #             created_at=user.created_at,&#10;    #             updated_at=user.updated_at&#10;    #         )&#10;    #     ))&#10;    return users&#10;&#10;&#10;def get_company_by_user(db: Session, user_id: str) -&gt; Optional[CompanyUsers]:&#10;    return db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == user_id).first()" />
              <option name="updatedContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime, timezone&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyUsers, CustomerStatusType&#10;from app.models.models import Users, UserVerifications&#10;from app.models.enums import VerificationStatus&#10;from app.schemas import CompanyUser, User&#10;from app.schemas.schemas import (&#10;    UserCreate, UserUpdate&#10;)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Users]:&#10;    return db.query(Users, CompanyUsers.company_id).outerjoin(CompanyUsers, CompanyUsers.user_id == Users.id).filter(Users.id == id).first()&#10;&#10;&#10;def get_all(db: Session) -&gt; List[Users]:&#10;    return db.query(Users).all()&#10;&#10;&#10;def get_by_email(db: Session, email: str) -&gt; Optional[Users]:&#10;    return db.query(Users).filter(Users.email == email).first()&#10;&#10;&#10;def create(db: Session, *, obj_in: UserCreate) -&gt; Users:&#10;    db_obj = Users(**obj_in.model_dump())&#10;    db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Users, obj_in: UserUpdate) -&gt; Users:&#10;    &quot;&quot;&quot;Update user information&quot;&quot;&quot;&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    &#10;    # If email is being updated, check if it's already in use by another user&#10;    if 'email' in update_data and update_data['email']:&#10;        existing_user = get_by_email(db, email=update_data['email'])&#10;        if existing_user and existing_user.id != db_obj.id:&#10;            raise ValueError(&quot;Email is already in use by another user&quot;)&#10;    &#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;    &#10;    # Ensure updated_at is set to current UTC time&#10;    db_obj.updated_at = utcnow()&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def get_verification_token(db: Session, token: str, type: str) -&gt; Optional[UserVerifications]:&#10;    &quot;&quot;&quot;Get verification token by token string and type&quot;&quot;&quot;&#10;    return db.query(UserVerifications).filter(&#10;        UserVerifications.token == token,&#10;        UserVerifications.type == type&#10;    ).first()&#10;&#10;&#10;def verify_token(db: Session, db_obj: UserVerifications) -&gt; bool:&#10;    &quot;&quot;&quot;Mark verification token as verified and update user email_verified status&quot;&quot;&quot;&#10;    try:&#10;        db_obj.status = VerificationStatus.VERIFIED&#10;        db_obj.used_at = utcnow()&#10;&#10;        # Update user's email_verified status&#10;        user = db.query(Users).filter(Users.id == db_obj.user_id).first()&#10;        if user:&#10;            user.email_verified = True&#10;            user.status = CustomerStatusType.active&#10;            user.updated_at = utcnow()&#10;            db.add(user)&#10;&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return True&#10;    except Exception:&#10;        db.rollback()&#10;        return False&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUser]:&#10;    &quot;&quot;&quot;&#10;    Get all users for a company&#10;    &quot;&quot;&quot;&#10;    users = db.query(CompanyUsers).join(Users, Users.id == CompanyUsers.user_id).filter(&#10;        Users.status == 'active', CompanyUsers.company_id == company_id, CompanyUsers.status == 'active'&#10;    ).all()&#10;    # result = []&#10;    # for company_user, user in users:&#10;    #     result.append(CompanyUser(&#10;    #         user_id=company_user.user_id,&#10;    #         company_id=company_user.company_id,&#10;    #         role=company_user.role,&#10;    #         status=company_user.status,&#10;    #         user=User(&#10;    #             id=user.id,&#10;    #             first_name=user.first_name,&#10;    #             last_name=user.last_name,&#10;    #             email=user.email,&#10;    #             phone=user.phone,&#10;    #             status=user.status,&#10;    #             created_at=user.created_at,&#10;    #             updated_at=user.updated_at&#10;    #         )&#10;    #     ))&#10;    return users&#10;&#10;&#10;def get_company_by_user(db: Session, user_id: str) -&gt; Optional[CompanyUsers]:&#10;    return db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == user_id).first()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/email_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/email_service.py" />
              <option name="originalContent" value="import uuid&#10;from datetime import datetime, timedelta, timezone&#10;from typing import Optional, Union&#10;from sqlalchemy.orm import Session&#10;from sendgrid import SendGridAPIClient&#10;from sendgrid.helpers.mail import Mail, Email, To, Content&#10;&#10;from app.core.config import settings&#10;from app.models.models import CustomerVerifications, UserVerifications&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;&#10;class EmailService:&#10;    &quot;&quot;&quot;Service for sending emails via SendGrid - works for both users and customers&quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        api_key: Optional[str] = None,&#10;        from_email: Optional[str] = None,&#10;        from_name: Optional[str] = None&#10;    ):&#10;        self.api_key = api_key or getattr(settings, 'SENDGRID_API_KEY', '')&#10;        self.from_email = from_email or getattr(settings, 'SENDGRID_FROM_EMAIL', '')&#10;        self.from_name = from_name or getattr(settings, 'SENDGRID_FROM_NAME', 'Salona')&#10;&#10;    def _send_email(&#10;        self,&#10;        to_email: str,&#10;        subject: str,&#10;        html_content: str,&#10;        text_content: Optional[str] = None&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send an email via SendGrid&#10;&#10;        Args:&#10;            to_email: Recipient email address&#10;            subject: Email subject&#10;            html_content: HTML content of the email&#10;            text_content: Plain text fallback content&#10;            &#10;        Returns:&#10;            bool: True if email sent successfully, False otherwise&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Validate API key&#10;            if not self.api_key:&#10;                print(&quot;Error: SendGrid API key is not configured&quot;)&#10;                return False&#10;&#10;            # Create SendGrid message&#10;            message = Mail(&#10;                from_email=Email(self.from_email, self.from_name),&#10;                to_emails=To(to_email),&#10;                subject=subject,&#10;                plain_text_content=Content(&quot;text/plain&quot;, text_content or &quot;&quot;),&#10;                html_content=Content(&quot;text/html&quot;, html_content)&#10;            )&#10;&#10;            # Send email using SendGrid API&#10;            sg = SendGridAPIClient(self.api_key)&#10;            response = sg.send(message)&#10;&#10;            # Check if email was sent successfully (2xx status codes)&#10;            if 200 &lt;= response.status_code &lt; 300:&#10;                return True&#10;            else:&#10;                print(f&quot;SendGrid API returned status code: {response.status_code}&quot;)&#10;                return False&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error sending email via SendGrid: {str(e)}&quot;)&#10;            return False&#10;    &#10;    def send_verification_email(&#10;        self,&#10;        to_email: str,&#10;        verification_token: str,&#10;        user_name: str&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send email verification email (works for both users and customers)&#10;&#10;        Args:&#10;            to_email: Email address&#10;            verification_token: Verification token&#10;            user_name: User's name&#10;&#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        verification_url = f&quot;{settings.FRONTEND_URL}/verify-email?token={verification_token}&quot;&#10;        &#10;        subject = &quot;Verify Your Email Address - Salona&quot;&#10;        &#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Welcome to Salona!&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {user_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;Thank you for signing up! To complete your registration, please verify your email address by clicking the button below:&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{verification_url}&quot; &#10;                       style=&quot;background-color: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        Verify Email Address&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                    {verification_url}&#10;                &lt;/p&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                    This verification link will expire in 24 hours. If you didn't create an account with Salona, please ignore this email.&#10;                &lt;/p&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;        &#10;        text_content = f&quot;&quot;&quot;&#10;        Welcome to Salona!&#10;        &#10;        Hi {user_name},&#10;        &#10;        Thank you for signing up! To complete your registration, please verify your email address by clicking the link below:&#10;        &#10;        {verification_url}&#10;        &#10;        This verification link will expire in 24 hours. If you didn't create an account with Salona, please ignore this email.&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;        &#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;    &#10;    def send_password_reset_email(&#10;        self,&#10;        to_email: str,&#10;        reset_token: str,&#10;        user_name: str&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send password reset email (works for both users and customers)&#10;&#10;        Args:&#10;            to_email: Email address&#10;            reset_token: Password reset token&#10;            user_name: User's name&#10;&#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        reset_url = f&quot;{settings.FRONTEND_URL}/reset-password?token={reset_token}&quot;&#10;        &#10;        subject = &quot;Reset Your Password - Salona&quot;&#10;        &#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Password Reset Request&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {user_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;We received a request to reset your password. Click the button below to create a new password:&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{reset_url}&quot; &#10;                       style=&quot;background-color: #dc3545; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        Reset Password&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                    {reset_url}&#10;                &lt;/p&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                    This password reset link will expire in 1 hour. If you didn't request a password reset, please ignore this email or contact support if you have concerns.&#10;                &lt;/p&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;        &#10;        text_content = f&quot;&quot;&quot;&#10;        Password Reset Request&#10;        &#10;        Hi {user_name},&#10;        &#10;        We received a request to reset your password. Click the link below to create a new password:&#10;        &#10;        {reset_url}&#10;        &#10;        This password reset link will expire in 1 hour. If you didn't request a password reset, please ignore this email.&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;        &#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;&#10;    def send_staff_invitation_email(&#10;        self,&#10;        to_email: str,&#10;        invitation_token: str,&#10;        invited_by: str,&#10;        company_name: str,&#10;        is_existing_user: bool = False&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send staff member invitation email&#10;&#10;        Args:&#10;            to_email: Email address to invite&#10;            invitation_token: Invitation token&#10;            invited_by: Name of person sending invitation&#10;            company_name: Company name&#10;            is_existing_user: Whether the user already exists in the system&#10;&#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        invitation_url = f&quot;{settings.FRONTEND_URL}/users/accept-invitation?token={invitation_token}&quot;&#10;&#10;        subject = f&quot;You're Invited to Join {company_name} on Salona&quot;&#10;&#10;        if is_existing_user:&#10;            # Email for existing users&#10;            html_content = f&quot;&quot;&quot;&#10;            &lt;!DOCTYPE html&gt;&#10;            &lt;html&gt;&#10;            &lt;head&gt;&#10;                &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;            &lt;/head&gt;&#10;            &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;                &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                    &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;You've Been Invited to Join a Team!&lt;/h1&gt;&#10;                    &#10;                    &lt;p&gt;Hi there,&lt;/p&gt;&#10;                    &#10;                    &lt;p&gt;&lt;strong&gt;{invited_by}&lt;/strong&gt; has invited you to join &lt;strong&gt;{company_name}&lt;/strong&gt; on Salona as a staff member.&lt;/p&gt;&#10;                    &#10;                    &lt;p&gt;To accept this invitation and start collaborating, click the button below:&lt;/p&gt;&#10;                    &#10;                    &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                        &lt;a href=&quot;{invitation_url}&quot; &#10;                           style=&quot;background-color: #28a745; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                            Accept Invitation&#10;                        &lt;/a&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                    &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                        {invitation_url}&#10;                    &lt;/p&gt;&#10;                    &#10;                    &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                        This invitation will expire in 3 days. If you didn't expect this invitation, you can safely ignore this email.&#10;                    &lt;/p&gt;&#10;                    &#10;                    &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                    &#10;                    &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                         {datetime.now().year} Salona. All rights reserved.&#10;                    &lt;/p&gt;&#10;                &lt;/div&gt;&#10;            &lt;/body&gt;&#10;            &lt;/html&gt;&#10;            &quot;&quot;&quot;&#10;&#10;            text_content = f&quot;&quot;&quot;&#10;            You've Been Invited to Join a Team!&#10;            &#10;            Hi there,&#10;            &#10;            {invited_by} has invited you to join {company_name} on Salona as a staff member.&#10;            &#10;            To accept this invitation and start collaborating, click the link below:&#10;            &#10;            {invitation_url}&#10;            &#10;            This invitation will expire in 3 days. If you didn't expect this invitation, you can safely ignore this email.&#10;            &#10;             {datetime.now().year} Salona. All rights reserved.&#10;            &quot;&quot;&quot;&#10;        else:&#10;            # Email for new users&#10;            html_content = f&quot;&quot;&quot;&#10;            &lt;!DOCTYPE html&gt;&#10;            &lt;html&gt;&#10;            &lt;head&gt;&#10;                &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;            &lt;/head&gt;&#10;            &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;                &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                    &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Welcome to Salona!&lt;/h1&gt;&#10;                    &#10;                    &lt;p&gt;Hi there,&lt;/p&gt;&#10;                    &#10;                    &lt;p&gt;&lt;strong&gt;{invited_by}&lt;/strong&gt; has invited you to join &lt;strong&gt;{company_name}&lt;/strong&gt; on Salona as a staff member.&lt;/p&gt;&#10;                    &#10;                    &lt;p&gt;To accept this invitation and create your account, click the button below:&lt;/p&gt;&#10;                    &#10;                    &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                        &lt;a href=&quot;{invitation_url}&quot; &#10;                           style=&quot;background-color: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                            Accept Invitation &amp; Sign Up&#10;                        &lt;/a&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                    &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                        {invitation_url}&#10;                    &lt;/p&gt;&#10;                    &#10;                    &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                        This invitation will expire in 3 days. Once you accept, you'll be able to create your account and get started with {company_name}.&#10;                    &lt;/p&gt;&#10;                    &#10;                    &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                    &#10;                    &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                         {datetime.now().year} Salona. All rights reserved.&#10;                    &lt;/p&gt;&#10;                &lt;/div&gt;&#10;            &lt;/body&gt;&#10;            &lt;/html&gt;&#10;            &quot;&quot;&quot;&#10;&#10;            text_content = f&quot;&quot;&quot;&#10;            Welcome to Salona!&#10;            &#10;            Hi there,&#10;            &#10;            {invited_by} has invited you to join {company_name} on Salona as a staff member.&#10;            &#10;            To accept this invitation and create your account, click the link below:&#10;            &#10;            {invitation_url}&#10;            &#10;            This invitation will expire in 3 days. Once you accept, you'll be able to create your account and get started with {company_name}.&#10;            &#10;             {datetime.now().year} Salona. All rights reserved.&#10;            &quot;&quot;&quot;&#10;&#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;&#10;    def send_booking_notification_email(&#10;        self,&#10;        to_email: str,&#10;        staff_name: str,&#10;        customer_name: str,&#10;        company_name: str,&#10;        booking_date: str,&#10;        services: list,&#10;        booking_notes: Optional[str] = None&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send booking notification email to staff members&#10;&#10;        Args:&#10;            to_email: Staff member's email address&#10;            staff_name: Staff member's name&#10;            customer_name: Customer's name who made the booking&#10;            company_name: Company name&#10;            booking_date: Date of the booking (formatted string)&#10;            services: List of service names for the booking&#10;            booking_notes: Optional notes from the customer&#10;&#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        subject = f&quot;New Booking Notification - {company_name}&quot;&#10;&#10;        # Format services list for display&#10;        services_html = &quot;&quot;&#10;        if services:&#10;            services_html = &quot;&lt;ul style='margin: 10px 0; padding-left: 20px;'&gt;&quot;&#10;            for service in services:&#10;                services_html += f&quot;&lt;li style='margin: 5px 0;'&gt;{service}&lt;/li&gt;&quot;&#10;            services_html += &quot;&lt;/ul&gt;&quot;&#10;&#10;        # Add notes section if provided&#10;        notes_html = &quot;&quot;&#10;        if booking_notes:&#10;            notes_html = f&quot;&quot;&quot;&#10;            &lt;div style=&quot;background-color: #fff3cd; padding: 15px; border-radius: 5px; margin: 20px 0; border-left: 4px solid #ffc107;&quot;&gt;&#10;                &lt;strong style=&quot;color: #856404;&quot;&gt;Customer Notes:&lt;/strong&gt;&#10;                &lt;p style=&quot;margin: 10px 0 0 0; color: #856404;&quot;&gt;{booking_notes}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &quot;&quot;&quot;&#10;&#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;New Booking Notification&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {staff_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;You have a new booking appointment scheduled at &lt;strong&gt;{company_name}&lt;/strong&gt;.&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;background-color: white; padding: 20px; border-radius: 8px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);&quot;&gt;&#10;                    &lt;h2 style=&quot;color: #007bff; margin-top: 0; font-size: 18px;&quot;&gt;Booking Details&lt;/h2&gt;&#10;                    &#10;                    &lt;table style=&quot;width: 100%; border-collapse: collapse;&quot;&gt;&#10;                        &lt;tr&gt;&#10;                            &lt;td style=&quot;padding: 10px 0; border-bottom: 1px solid #e9ecef;&quot;&gt;&#10;                                &lt;strong&gt;Customer:&lt;/strong&gt;&#10;                            &lt;/td&gt;&#10;                            &lt;td style=&quot;padding: 10px 0; border-bottom: 1px solid #e9ecef; text-align: right;&quot;&gt;&#10;                                {customer_name}&#10;                            &lt;/td&gt;&#10;                        &lt;/tr&gt;&#10;                        &lt;tr&gt;&#10;                            &lt;td style=&quot;padding: 10px 0; border-bottom: 1px solid #e9ecef;&quot;&gt;&#10;                                &lt;strong&gt;Date:&lt;/strong&gt;&#10;                            &lt;/td&gt;&#10;                            &lt;td style=&quot;padding: 10px 0; border-bottom: 1px solid #e9ecef; text-align: right;&quot;&gt;&#10;                                {booking_date}&#10;                            &lt;/td&gt;&#10;                        &lt;/tr&gt;&#10;                        &lt;tr&gt;&#10;                            &lt;td style=&quot;padding: 10px 0;&quot; colspan=&quot;2&quot;&gt;&#10;                                &lt;strong&gt;Services:&lt;/strong&gt;&#10;                                {services_html}&#10;                            &lt;/td&gt;&#10;                        &lt;/tr&gt;&#10;                    &lt;/table&gt;&#10;                &lt;/div&gt;&#10;                &#10;                {notes_html}&#10;                &#10;                &lt;p style=&quot;color: #28a745; font-weight: bold;&quot;&gt;Please make sure you're available at the scheduled time.&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{settings.FRONTEND_URL}/bookings&quot; &#10;                       style=&quot;background-color: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        View Booking&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;&#10;        # Plain text version&#10;        services_text = &quot;\n&quot;.join([f&quot;  - {service}&quot; for service in services]) if services else &quot;  No services specified&quot;&#10;        notes_text = f&quot;\n\nCustomer Notes:\n{booking_notes}\n&quot; if booking_notes else &quot;&quot;&#10;&#10;        text_content = f&quot;&quot;&quot;&#10;        New Booking Notification&#10;        &#10;        Hi {staff_name},&#10;        &#10;        You have a new booking appointment scheduled at {company_name}.&#10;        &#10;        Booking Details:&#10;        ----------------&#10;        Customer: {customer_name}&#10;        Date: {booking_date}&#10;        &#10;        Services:&#10;        {services_text}&#10;        {notes_text}&#10;        &#10;        Please make sure you're available at the scheduled time.&#10;        &#10;        View your bookings at: {settings.FRONTEND_URL}/bookings&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;&#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;&#10;&#10;def create_verification_token(&#10;    db: Session,&#10;    entity_id: str,&#10;    verification_type: VerificationType,&#10;    entity_type: str = &quot;user&quot;,&#10;    expires_in_hours: int = 24&#10;) -&gt; Union[UserVerifications, CustomerVerifications]:&#10;    &quot;&quot;&quot;&#10;    Create a verification token for a user or customer&#10;&#10;    Args:&#10;        db: Database session&#10;        entity_id: User or Customer ID&#10;        verification_type: Type of verification (email, phone, etc.)&#10;        entity_type: Either &quot;user&quot; or &quot;customer&quot;&#10;        expires_in_hours: Hours until token expires&#10;        &#10;    Returns:&#10;        UserVerifications or CustomerVerifications: The created verification record&#10;    &quot;&quot;&quot;&#10;    token = str(uuid.uuid4())&#10;    expires_at = datetime.now(timezone.utc) + timedelta(hours=expires_in_hours)&#10;    &#10;    if entity_type == &quot;user&quot;:&#10;        db_obj = UserVerifications(&#10;            id=uuid.uuid4(),&#10;            user_id=entity_id,&#10;            token=token,&#10;            type=verification_type,&#10;            status=VerificationStatus.PENDING,&#10;            expires_at=expires_at&#10;        )&#10;    else:  # customer&#10;        db_obj = CustomerVerifications(&#10;            id=uuid.uuid4(),&#10;            customer_id=entity_id,&#10;            token=token,&#10;            type=verification_type,&#10;            status=VerificationStatus.PENDING,&#10;            expires_at=expires_at&#10;        )&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    &#10;    return db_obj&#10;&#10;&#10;# Singleton instance&#10;email_service = EmailService()&#10;" />
              <option name="updatedContent" value="import uuid&#10;from datetime import datetime, timedelta, timezone&#10;from typing import Optional, Union&#10;from sqlalchemy.orm import Session&#10;from sendgrid import SendGridAPIClient&#10;from sendgrid.helpers.mail import Mail, Email, To, Content&#10;&#10;from app.core.config import settings&#10;from app.models.models import CustomerVerifications, UserVerifications&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;&#10;class EmailService:&#10;    &quot;&quot;&quot;Service for sending emails via SendGrid - works for both users and customers&quot;&quot;&quot;&#10;&#10;    def __init__(&#10;        self,&#10;        api_key: Optional[str] = None,&#10;        from_email: Optional[str] = None,&#10;        from_name: Optional[str] = None&#10;    ):&#10;        self.api_key = api_key or getattr(settings, 'SENDGRID_API_KEY', '')&#10;        self.from_email = from_email or getattr(settings, 'SENDGRID_FROM_EMAIL', '')&#10;        self.from_name = from_name or getattr(settings, 'SENDGRID_FROM_NAME', 'Salona')&#10;&#10;    def _send_email(&#10;        self,&#10;        to_email: str,&#10;        subject: str,&#10;        html_content: str,&#10;        text_content: Optional[str] = None&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send an email via SendGrid&#10;&#10;        Args:&#10;            to_email: Recipient email address&#10;            subject: Email subject&#10;            html_content: HTML content of the email&#10;            text_content: Plain text fallback content&#10;            &#10;        Returns:&#10;            bool: True if email sent successfully, False otherwise&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Validate API key&#10;            if not self.api_key:&#10;                print(&quot;Error: SendGrid API key is not configured&quot;)&#10;                return False&#10;&#10;            # Create SendGrid message&#10;            message = Mail(&#10;                from_email=Email(self.from_email, self.from_name),&#10;                to_emails=To(to_email),&#10;                subject=subject,&#10;                plain_text_content=Content(&quot;text/plain&quot;, text_content or &quot;&quot;),&#10;                html_content=Content(&quot;text/html&quot;, html_content)&#10;            )&#10;&#10;            # Send email using SendGrid API&#10;            sg = SendGridAPIClient(self.api_key)&#10;            response = sg.send(message)&#10;&#10;            # Check if email was sent successfully (2xx status codes)&#10;            if 200 &lt;= response.status_code &lt; 300:&#10;                return True&#10;            else:&#10;                print(f&quot;SendGrid API returned status code: {response.status_code}&quot;)&#10;                return False&#10;&#10;        except Exception as e:&#10;            print(f&quot;Error sending email via SendGrid: {str(e)}&quot;)&#10;            return False&#10;    &#10;    def send_verification_email(&#10;        self,&#10;        to_email: str,&#10;        verification_token: str,&#10;        user_name: str&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send email verification email (works for both users and customers)&#10;&#10;        Args:&#10;            to_email: Email address&#10;            verification_token: Verification token&#10;            user_name: User's name&#10;&#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        verification_url = f&quot;{settings.FRONTEND_URL}/verify-email?token={verification_token}&quot;&#10;        &#10;        subject = &quot;Verify Your Email Address - Salona&quot;&#10;        &#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Welcome to Salona!&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {user_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;Thank you for signing up! To complete your registration, please verify your email address by clicking the button below:&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{verification_url}&quot; &#10;                       style=&quot;background-color: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        Verify Email Address&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                    {verification_url}&#10;                &lt;/p&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                    This verification link will expire in 24 hours. If you didn't create an account with Salona, please ignore this email.&#10;                &lt;/p&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;        &#10;        text_content = f&quot;&quot;&quot;&#10;        Welcome to Salona!&#10;        &#10;        Hi {user_name},&#10;        &#10;        Thank you for signing up! To complete your registration, please verify your email address by clicking the link below:&#10;        &#10;        {verification_url}&#10;        &#10;        This verification link will expire in 24 hours. If you didn't create an account with Salona, please ignore this email.&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;        &#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;    &#10;    def send_password_reset_email(&#10;        self,&#10;        to_email: str,&#10;        reset_token: str,&#10;        user_name: str&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send password reset email (works for both users and customers)&#10;&#10;        Args:&#10;            to_email: Email address&#10;            reset_token: Password reset token&#10;            user_name: User's name&#10;&#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        reset_url = f&quot;{settings.FRONTEND_URL}/reset-password?token={reset_token}&quot;&#10;        &#10;        subject = &quot;Reset Your Password - Salona&quot;&#10;        &#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Password Reset Request&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {user_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;We received a request to reset your password. Click the button below to create a new password:&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{reset_url}&quot; &#10;                       style=&quot;background-color: #dc3545; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        Reset Password&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                    {reset_url}&#10;                &lt;/p&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                    This password reset link will expire in 1 hour. If you didn't request a password reset, please ignore this email or contact support if you have concerns.&#10;                &lt;/p&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;        &#10;        text_content = f&quot;&quot;&quot;&#10;        Password Reset Request&#10;        &#10;        Hi {user_name},&#10;        &#10;        We received a request to reset your password. Click the link below to create a new password:&#10;        &#10;        {reset_url}&#10;        &#10;        This password reset link will expire in 1 hour. If you didn't request a password reset, please ignore this email.&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;        &#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;&#10;    def send_staff_invitation_email(&#10;        self,&#10;        to_email: str,&#10;        invitation_token: str,&#10;        invited_by: str,&#10;        company_name: str,&#10;        is_existing_user: bool = False&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send staff member invitation email&#10;&#10;        Args:&#10;            to_email: Email address to invite&#10;            invitation_token: Invitation token&#10;            invited_by: Name of person sending invitation&#10;            company_name: Company name&#10;            is_existing_user: Whether the user already exists in the system&#10;&#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        invitation_url = f&quot;{settings.FRONTEND_URL}/users/accept-invitation?token={invitation_token}&quot;&#10;&#10;        subject = f&quot;You're Invited to Join {company_name} on Salona&quot;&#10;&#10;        if is_existing_user:&#10;            # Email for existing users&#10;            html_content = f&quot;&quot;&quot;&#10;            &lt;!DOCTYPE html&gt;&#10;            &lt;html&gt;&#10;            &lt;head&gt;&#10;                &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;            &lt;/head&gt;&#10;            &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;                &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                    &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;You've Been Invited to Join a Team!&lt;/h1&gt;&#10;                    &#10;                    &lt;p&gt;Hi there,&lt;/p&gt;&#10;                    &#10;                    &lt;p&gt;&lt;strong&gt;{invited_by}&lt;/strong&gt; has invited you to join &lt;strong&gt;{company_name}&lt;/strong&gt; on Salona as a staff member.&lt;/p&gt;&#10;                    &#10;                    &lt;p&gt;To accept this invitation and start collaborating, click the button below:&lt;/p&gt;&#10;                    &#10;                    &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                        &lt;a href=&quot;{invitation_url}&quot; &#10;                           style=&quot;background-color: #28a745; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                            Accept Invitation&#10;                        &lt;/a&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                    &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                        {invitation_url}&#10;                    &lt;/p&gt;&#10;                    &#10;                    &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                        This invitation will expire in 3 days. If you didn't expect this invitation, you can safely ignore this email.&#10;                    &lt;/p&gt;&#10;                    &#10;                    &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                    &#10;                    &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                         {datetime.now().year} Salona. All rights reserved.&#10;                    &lt;/p&gt;&#10;                &lt;/div&gt;&#10;            &lt;/body&gt;&#10;            &lt;/html&gt;&#10;            &quot;&quot;&quot;&#10;&#10;            text_content = f&quot;&quot;&quot;&#10;            You've Been Invited to Join a Team!&#10;            &#10;            Hi there,&#10;            &#10;            {invited_by} has invited you to join {company_name} on Salona as a staff member.&#10;            &#10;            To accept this invitation and start collaborating, click the link below:&#10;            &#10;            {invitation_url}&#10;            &#10;            This invitation will expire in 3 days. If you didn't expect this invitation, you can safely ignore this email.&#10;            &#10;             {datetime.now().year} Salona. All rights reserved.&#10;            &quot;&quot;&quot;&#10;        else:&#10;            # Email for new users&#10;            html_content = f&quot;&quot;&quot;&#10;            &lt;!DOCTYPE html&gt;&#10;            &lt;html&gt;&#10;            &lt;head&gt;&#10;                &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;                &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;            &lt;/head&gt;&#10;            &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;                &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                    &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Welcome to Salona!&lt;/h1&gt;&#10;                    &#10;                    &lt;p&gt;Hi there,&lt;/p&gt;&#10;                    &#10;                    &lt;p&gt;&lt;strong&gt;{invited_by}&lt;/strong&gt; has invited you to join &lt;strong&gt;{company_name}&lt;/strong&gt; on Salona as a staff member.&lt;/p&gt;&#10;                    &#10;                    &lt;p&gt;To accept this invitation and create your account, click the button below:&lt;/p&gt;&#10;                    &#10;                    &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                        &lt;a href=&quot;{invitation_url}&quot; &#10;                           style=&quot;background-color: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                            Accept Invitation &amp; Sign Up&#10;                        &lt;/a&gt;&#10;                    &lt;/div&gt;&#10;                    &#10;                    &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                    &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                        {invitation_url}&#10;                    &lt;/p&gt;&#10;                    &#10;                    &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                        This invitation will expire in 3 days. Once you accept, you'll be able to create your account and get started with {company_name}.&#10;                    &lt;/p&gt;&#10;                    &#10;                    &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                    &#10;                    &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                         {datetime.now().year} Salona. All rights reserved.&#10;                    &lt;/p&gt;&#10;                &lt;/div&gt;&#10;            &lt;/body&gt;&#10;            &lt;/html&gt;&#10;            &quot;&quot;&quot;&#10;&#10;            text_content = f&quot;&quot;&quot;&#10;            Welcome to Salona!&#10;            &#10;            Hi there,&#10;            &#10;            {invited_by} has invited you to join {company_name} on Salona as a staff member.&#10;            &#10;            To accept this invitation and create your account, click the link below:&#10;            &#10;            {invitation_url}&#10;            &#10;            This invitation will expire in 3 days. Once you accept, you'll be able to create your account and get started with {company_name}.&#10;            &#10;             {datetime.now().year} Salona. All rights reserved.&#10;            &quot;&quot;&quot;&#10;&#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;&#10;    def send_booking_notification_email(&#10;        self,&#10;        to_email: str,&#10;        staff_name: str,&#10;        customer_name: str,&#10;        company_name: str,&#10;        booking_date: str,&#10;        services: list,&#10;        booking_notes: Optional[str] = None&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send booking notification email to staff members&#10;&#10;        Args:&#10;            to_email: Staff member's email address&#10;            staff_name: Staff member's name&#10;            customer_name: Customer's name who made the booking&#10;            company_name: Company name&#10;            booking_date: Date of the booking (formatted string)&#10;            services: List of service names for the booking&#10;            booking_notes: Optional notes from the customer&#10;&#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        subject = f&quot;New Booking Notification - {company_name}&quot;&#10;&#10;        # Format services list for display&#10;        services_html = &quot;&quot;&#10;        if services:&#10;            services_html = &quot;&lt;ul style='margin: 10px 0; padding-left: 20px;'&gt;&quot;&#10;            for service in services:&#10;                services_html += f&quot;&lt;li style='margin: 5px 0;'&gt;{service}&lt;/li&gt;&quot;&#10;            services_html += &quot;&lt;/ul&gt;&quot;&#10;&#10;        # Add notes section if provided&#10;        notes_html = &quot;&quot;&#10;        if booking_notes:&#10;            notes_html = f&quot;&quot;&quot;&#10;            &lt;div style=&quot;background-color: #fff3cd; padding: 15px; border-radius: 5px; margin: 20px 0; border-left: 4px solid #ffc107;&quot;&gt;&#10;                &lt;strong style=&quot;color: #856404;&quot;&gt;Customer Notes:&lt;/strong&gt;&#10;                &lt;p style=&quot;margin: 10px 0 0 0; color: #856404;&quot;&gt;{booking_notes}&lt;/p&gt;&#10;            &lt;/div&gt;&#10;            &quot;&quot;&quot;&#10;&#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;New Booking Notification&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {staff_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;You have a new booking appointment scheduled at &lt;strong&gt;{company_name}&lt;/strong&gt;.&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;background-color: white; padding: 20px; border-radius: 8px; margin: 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1);&quot;&gt;&#10;                    &lt;h2 style=&quot;color: #007bff; margin-top: 0; font-size: 18px;&quot;&gt;Booking Details&lt;/h2&gt;&#10;                    &#10;                    &lt;table style=&quot;width: 100%; border-collapse: collapse;&quot;&gt;&#10;                        &lt;tr&gt;&#10;                            &lt;td style=&quot;padding: 10px 0; border-bottom: 1px solid #e9ecef;&quot;&gt;&#10;                                &lt;strong&gt;Customer:&lt;/strong&gt;&#10;                            &lt;/td&gt;&#10;                            &lt;td style=&quot;padding: 10px 0; border-bottom: 1px solid #e9ecef; text-align: right;&quot;&gt;&#10;                                {customer_name}&#10;                            &lt;/td&gt;&#10;                        &lt;/tr&gt;&#10;                        &lt;tr&gt;&#10;                            &lt;td style=&quot;padding: 10px 0; border-bottom: 1px solid #e9ecef;&quot;&gt;&#10;                                &lt;strong&gt;Date:&lt;/strong&gt;&#10;                            &lt;/td&gt;&#10;                            &lt;td style=&quot;padding: 10px 0; border-bottom: 1px solid #e9ecef; text-align: right;&quot;&gt;&#10;                                {booking_date}&#10;                            &lt;/td&gt;&#10;                        &lt;/tr&gt;&#10;                        &lt;tr&gt;&#10;                            &lt;td style=&quot;padding: 10px 0;&quot; colspan=&quot;2&quot;&gt;&#10;                                &lt;strong&gt;Services:&lt;/strong&gt;&#10;                                {services_html}&#10;                            &lt;/td&gt;&#10;                        &lt;/tr&gt;&#10;                    &lt;/table&gt;&#10;                &lt;/div&gt;&#10;                &#10;                {notes_html}&#10;                &#10;                &lt;p style=&quot;color: #28a745; font-weight: bold;&quot;&gt;Please make sure you're available at the scheduled time.&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{settings.FRONTEND_URL}/bookings&quot; &#10;                       style=&quot;background-color: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        View Booking&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;&#10;        # Plain text version&#10;        services_text = &quot;\n&quot;.join([f&quot;  - {service}&quot; for service in services]) if services else &quot;  No services specified&quot;&#10;        notes_text = f&quot;\n\nCustomer Notes:\n{booking_notes}\n&quot; if booking_notes else &quot;&quot;&#10;&#10;        text_content = f&quot;&quot;&quot;&#10;        New Booking Notification&#10;        &#10;        Hi {staff_name},&#10;        &#10;        You have a new booking appointment scheduled at {company_name}.&#10;        &#10;        Booking Details:&#10;        ----------------&#10;        Customer: {customer_name}&#10;        Date: {booking_date}&#10;        &#10;        Services:&#10;        {services_text}&#10;        {notes_text}&#10;        &#10;        Please make sure you're available at the scheduled time.&#10;        &#10;        View your bookings at: {settings.FRONTEND_URL}/bookings&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;&#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;&#10;&#10;def create_verification_token(&#10;    db: Session,&#10;    entity_id: str,&#10;    verification_type: VerificationType,&#10;    entity_type: str = &quot;user&quot;,&#10;    expires_in_hours: int = 24&#10;) -&gt; Union[UserVerifications, CustomerVerifications]:&#10;    &quot;&quot;&quot;&#10;    Create a verification token for a user or customer&#10;&#10;    Args:&#10;        db: Database session&#10;        entity_id: User or Customer ID&#10;        verification_type: Type of verification (email, phone, etc.)&#10;        entity_type: Either &quot;user&quot; or &quot;customer&quot;&#10;        expires_in_hours: Hours until token expires&#10;        &#10;    Returns:&#10;        UserVerifications or CustomerVerifications: The created verification record&#10;    &quot;&quot;&quot;&#10;    token = str(uuid.uuid4())&#10;    expires_at = datetime.now(timezone.utc) + timedelta(hours=expires_in_hours)&#10;    &#10;    if entity_type == &quot;user&quot;:&#10;        db_obj = UserVerifications(&#10;            id=uuid.uuid4(),&#10;            user_id=entity_id,&#10;            token=token,&#10;            type=verification_type,&#10;            status=VerificationStatus.PENDING,&#10;            expires_at=expires_at&#10;        )&#10;    else:  # customer&#10;        db_obj = CustomerVerifications(&#10;            id=uuid.uuid4(),&#10;            customer_id=entity_id,&#10;            token=token,&#10;            type=verification_type,&#10;            status=VerificationStatus.PENDING,&#10;            expires_at=expires_at&#10;        )&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    &#10;    return db_obj&#10;&#10;&#10;# Singleton instance&#10;email_service = EmailService()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>