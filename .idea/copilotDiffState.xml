<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/bookings.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/bookings.py" />
              <option name="originalContent" value="from datetime import datetime, timezone, date, timedelta&#10;from typing import List, Optional&#10;&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Header&#10;from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;from app.db.session import get_db&#10;from app.schemas import User&#10;from app.schemas.schemas import Booking, BookingCreate, BookingUpdate, AvailabilityResponse, CustomerCreate, BookingWithDetails&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import customer as crud_customer&#10;from app.api.dependencies import get_current_company_id&#10;from app.schemas.responses import DataResponse&#10;from app.api.dependencies import get_current_customer&#10;&#10;from app.services.auth import verify_token&#10;import uuid&#10;&#10;&#10;router = APIRouter()&#10;security = HTTPBearer(auto_error=False)&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;def create_booking(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        response: Response,&#10;        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;    if credentials:&#10;        customer = get_current_customer(credentials=credentials)&#10;&#10;    # If no valid customer found, create a new inactive one&#10;    if not customer:&#10;        # For unregistered customers, we need customer_info in the booking_in&#10;        if not booking_in.customer_info:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Customer information required for unregistered booking&quot;&#10;            )&#10;&#10;        # Create a new customer from the provided information&#10;        customer_data = CustomerCreate(&#10;            first_name=booking_in.customer_info.first_name,&#10;            last_name=booking_in.customer_info.last_name,&#10;            email=booking_in.customer_info.email,&#10;            phone=booking_in.customer_info.phone,&#10;            password=str(uuid.uuid4())  # Random password for inactive account&#10;        )&#10;&#10;        # Check if customer with this email already exists&#10;        existing_customer = crud_customer.get_by_email(db, email=str(customer_data.email))&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            customer = crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Verify that the company exists&#10;    selected_company = crud_company.get(db=db, id=booking_in.company_id)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Selected company not found&quot;&#10;        )&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;&#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        selected_user = crud_user.get(db=db, id=selected_company_service.user_id)&#10;        if not selected_user:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;User not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;    try:&#10;        booking = crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        db.commit()&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;@router.get(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking])&#10;def get_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        # current_customer: Customer = Depends(get_current_active_customer),&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get booking by ID with details.&#10;    &quot;&quot;&quot;&#10;    booking_id = UUID4(booking_id)&#10;    booking = crud_booking.get(db=db, id=booking_id)&#10;    if not booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;    response.status_code = status.HTTP_200_OK&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=booking,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[List[BookingWithDetails]], status_code=status.HTTP_200_OK)&#10;def get_all_bookings(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        start_date: Optional[date] = Query(None, description=&quot;Start date in YYYY-MM-DD format&quot;),&#10;        end_date: Optional[date] = Query(None, description=&quot;End date in YYYY-MM-DD format&quot;),&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get bookings with details for a company within a date range.&#10;    &quot;&quot;&quot;&#10;&#10;    if not start_date:&#10;        start_date = (datetime.now() - timedelta(days=datetime.now().weekday())).replace(hour=0, minute=0, second=0, microsecond=0)&#10;    if not end_date:&#10;        end_date = (datetime.now() - timedelta(days=datetime.now().weekday()) + timedelta(days=7)).replace(hour=23, minute=59, second=59, microsecond=999999)&#10;&#10;    booking_tuples = crud_booking.get_all_bookings_in_range_by_company(db=db,&#10;                                                                 company_id=company_id,&#10;                                                                 start_date=start_date,&#10;                                                                 end_date=end_date)&#10;    &#10;    if not booking_tuples:&#10;        return DataResponse.success_response(&#10;            message=&quot;No bookings found&quot;,&#10;            data=[],&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=bookings,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;" />
              <option name="updatedContent" value="from datetime import datetime, timezone, date, timedelta&#10;from typing import List, Optional&#10;&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Header&#10;from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;from app.db.session import get_db&#10;from app.schemas import User&#10;from app.schemas.schemas import Booking, BookingCreate, BookingUpdate, AvailabilityResponse, CustomerCreate, BookingWithDetails&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import customer as crud_customer&#10;from app.api.dependencies import get_current_company_id&#10;from app.schemas.responses import DataResponse&#10;from app.api.dependencies import get_current_customer&#10;&#10;from app.services.auth import verify_token&#10;import uuid&#10;&#10;&#10;router = APIRouter()&#10;security = HTTPBearer(auto_error=False)&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;def create_booking(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        response: Response,&#10;        credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;    if credentials:&#10;        customer = get_current_customer(credentials=credentials)&#10;&#10;    # If no valid customer found, create a new inactive one&#10;    if not customer:&#10;        # For unregistered customers, we need customer_info in the booking_in&#10;        if not booking_in.customer_info:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Customer information required for unregistered booking&quot;&#10;            )&#10;&#10;        # Create a new customer from the provided information&#10;        customer_data = CustomerCreate(&#10;            first_name=booking_in.customer_info.first_name,&#10;            last_name=booking_in.customer_info.last_name,&#10;            email=booking_in.customer_info.email,&#10;            phone=booking_in.customer_info.phone,&#10;            password=str(uuid.uuid4())  # Random password for inactive account&#10;        )&#10;&#10;        # Check if customer with this email already exists&#10;        existing_customer = crud_customer.get_by_email(db, email=str(customer_data.email))&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            customer = crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Verify that the company exists&#10;    selected_company = crud_company.get(db=db, id=booking_in.company_id)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Selected company not found&quot;&#10;        )&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;&#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        selected_user = crud_user.get(db=db, id=selected_company_service.user_id)&#10;        if not selected_user:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;User not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;    try:&#10;        booking = crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        db.commit()&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;@router.get(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking])&#10;def get_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        # current_customer: Customer = Depends(get_current_active_customer),&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get booking by ID with details.&#10;    &quot;&quot;&quot;&#10;    booking_id = UUID4(booking_id)&#10;    booking = crud_booking.get(db=db, id=booking_id)&#10;    if not booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;    response.status_code = status.HTTP_200_OK&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=booking,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[List[BookingWithDetails]], status_code=status.HTTP_200_OK)&#10;def get_all_bookings(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        start_date: Optional[date] = Query(None, description=&quot;Start date in YYYY-MM-DD format&quot;),&#10;        end_date: Optional[date] = Query(None, description=&quot;End date in YYYY-MM-DD format&quot;),&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get bookings with details for a company within a date range.&#10;    &quot;&quot;&quot;&#10;&#10;    if not start_date:&#10;        start_date = (datetime.now() - timedelta(days=datetime.now().weekday())).replace(hour=0, minute=0, second=0, microsecond=0)&#10;    if not end_date:&#10;        end_date = (datetime.now() - timedelta(days=datetime.now().weekday()) + timedelta(days=7)).replace(hour=23, minute=59, second=59, microsecond=999999)&#10;&#10;    booking_tuples = crud_booking.get_all_bookings_in_range_by_company(db=db,&#10;                                                                 company_id=company_id,&#10;                                                                 start_date=start_date,&#10;                                                                 end_date=end_date)&#10;    &#10;    if not booking_tuples:&#10;        return DataResponse.success_response(&#10;            message=&quot;No bookings found&quot;,&#10;            data=[],&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=bookings,&#10;        status_code=status.HTTP_200_OK&#10;    )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/schemas/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/schemas/schemas.py" />
              <option name="originalContent" value="from datetime import datetime, date, time&#10;from typing import Optional, List&#10;from pydantic import BaseModel, EmailStr, ConfigDict, UUID4&#10;&#10;from app.models import CustomerStatusType&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    mobile_number: Optional[str] = None&#10;    country: Optional[str] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(BaseModel):&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;    user: User&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.inactive&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: str&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: UUID4&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    service_id: Optional[int] = None&#10;    client_id: Optional[int] = None&#10;    start_time: Optional[datetime] = None&#10;    end_time: Optional[datetime] = None&#10;    status: Optional[str] = None&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;&#10;&#10;class BookingWithDetails(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    # Booking fields&#10;    id: UUID4&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus&#10;    notes: Optional[str] = None&#10;    total_price: int&#10;    created_at: datetime&#10;    updated_at: datetime&#10;    &#10;    # Customer fields&#10;    customer: Optional[Customer] = None&#10;&#10;#&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: str&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []&#10;" />
              <option name="updatedContent" value="from datetime import datetime, date, time&#10;from typing import Optional, List&#10;from pydantic import BaseModel, EmailStr, ConfigDict, UUID4&#10;&#10;from app.models import CustomerStatusType&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    mobile_number: Optional[str] = None&#10;    country: Optional[str] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(BaseModel):&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;    user: User&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.inactive&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: str&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: UUID4&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    service_id: Optional[int] = None&#10;    client_id: Optional[int] = None&#10;    start_time: Optional[datetime] = None&#10;    end_time: Optional[datetime] = None&#10;    status: Optional[str] = None&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;&#10;&#10;class BookingWithDetails(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    # Booking fields&#10;    id: UUID4&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus&#10;    notes: Optional[str] = None&#10;    total_price: int&#10;    created_at: datetime&#10;    updated_at: datetime&#10;    &#10;    # Customer fields&#10;    customer: Optional[Customer] = None&#10;&#10;#&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: str&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>