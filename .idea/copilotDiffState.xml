<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/alembic/versions/add_membership_tables.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic/versions/add_membership_tables.py" />
              <option name="originalContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/api.py" />
              <option name="originalContent" value="from fastapi import APIRouter&#10;from app.api.api_v1.endpoints import customers, users, companies, services, bookings, notifications, memberships, integrations&#10;&#10;api_router = APIRouter()&#10;api_router.include_router(users.router, prefix=&quot;/users&quot;, tags=[&quot;users&quot;])&#10;api_router.include_router(companies.router, prefix=&quot;/companies&quot;, tags=[&quot;companies&quot;])&#10;api_router.include_router(services.router, prefix=&quot;/services&quot;, tags=[&quot;services&quot;])&#10;api_router.include_router(customers.router, prefix=&quot;/customers&quot;, tags=[&quot;customers&quot;])&#10;api_router.include_router(bookings.router, prefix=&quot;/bookings&quot;, tags=[&quot;bookings&quot;])&#10;api_router.include_router(notifications.router, prefix=&quot;/notifications&quot;, tags=[&quot;notifications&quot;])&#10;api_router.include_router(memberships.router, prefix=&quot;/memberships&quot;, tags=[&quot;memberships&quot;])&#10;api_router.include_router(integrations.router, prefix=&quot;/integrations&quot;, tags=[&quot;integrations&quot;])" />
              <option name="updatedContent" value="from fastapi import APIRouter&#10;from app.api.api_v1.endpoints import customers, users, companies, services, bookings, notifications, memberships, integrations&#10;&#10;api_router = APIRouter()&#10;api_router.include_router(users.router, prefix=&quot;/users&quot;, tags=[&quot;users&quot;])&#10;api_router.include_router(companies.router, prefix=&quot;/companies&quot;, tags=[&quot;companies&quot;])&#10;api_router.include_router(services.router, prefix=&quot;/services&quot;, tags=[&quot;services&quot;])&#10;api_router.include_router(customers.router, prefix=&quot;/customers&quot;, tags=[&quot;customers&quot;])&#10;api_router.include_router(bookings.router, prefix=&quot;/bookings&quot;, tags=[&quot;bookings&quot;])&#10;api_router.include_router(notifications.router, prefix=&quot;/notifications&quot;, tags=[&quot;notifications&quot;])&#10;api_router.include_router(memberships.router, prefix=&quot;/memberships&quot;, tags=[&quot;memberships&quot;])&#10;api_router.include_router(integrations.router, prefix=&quot;/integrations&quot;, tags=[&quot;integrations&quot;])" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/bookings.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/bookings.py" />
              <option name="originalContent" value="from datetime import datetime, timezone, date, timedelta&#10;from typing import List, Optional&#10;&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Header&#10;from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;from app.db.session import get_db&#10;from app.core.redis_client import publish_event&#10;from app.schemas import CompanyNotificationCreate&#10;from app.services.notification_service import notification_service&#10;from app.schemas.schemas import Booking, BookingCreate, BookingUpdate, AvailabilityResponse, CustomerCreate&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import customer as crud_customer&#10;from app.api.dependencies import get_current_company_id, get_token_payload&#10;from app.schemas.responses import DataResponse&#10;from app.api.dependencies import get_current_customer&#10;from app.models import BookingServices, BookingStatus, NotificationType&#10;&#10;from app.services.auth import verify_token&#10;import uuid&#10;&#10;&#10;router = APIRouter()&#10;security = HTTPBearer(auto_error=False)&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;async def create_booking(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;    # print(credentials)&#10;    # if credentials:&#10;    #     customer = get_current_customer(credentials=credentials, db=db)&#10;&#10;    publish_event('booking_created',&#10;                  str({'info': f&quot;TEST&quot;}))&#10;&#10;    # If no valid customer found, create a new inactive one&#10;    if not customer:&#10;        # For unregistered customers, we need customer_info in the booking_in&#10;        if not booking_in.customer_info:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Customer information required for unregistered booking&quot;&#10;            )&#10;        if booking_in.customer_info.id:&#10;            # If customer_info contains an ID, try to fetch that customer&#10;            existing_customer = crud_customer.get(db, id=booking_in.customer_info.id)&#10;            if existing_customer:&#10;                customer = existing_customer&#10;            else:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                raise DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;Customer with provided ID not found&quot;&#10;                )&#10;            # If we found the customer by ID, we can skip creating a new one&#10;            booking_in.customer_info = None  # Clear to avoid confusion later&#10;&#10;        # Create a new customer from the provided information&#10;        if booking_in.customer_info:&#10;            customer_data = CustomerCreate(&#10;                first_name=booking_in.customer_info.first_name,&#10;                last_name=booking_in.customer_info.last_name,&#10;                email=booking_in.customer_info.email,&#10;                phone=booking_in.customer_info.phone,&#10;                password=str(uuid.uuid4())  # Random password for inactive account&#10;            )&#10;&#10;            # Check if customer with this email already exists&#10;            existing_customer = crud_customer.get_by_email(db, email=str(customer_data.email))&#10;            if existing_customer:&#10;                customer = existing_customer&#10;            else:&#10;                customer = crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Verify that the company exists&#10;    selected_company = crud_company.get(db=db, id=booking_in.company_id)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Selected company not found&quot;&#10;        )&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;&#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        selected_user = crud_user.get(db=db, id=selected_company_service.user_id)&#10;        if not selected_user:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;User not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;    try:&#10;        booking = crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        publish_event('booking_created', str({'info': f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;}))&#10;&#10;        # Create confirmation notification for the assigned staff member&#10;        res = notification_service.create_notification(&#10;            db=db,&#10;            notification_request=CompanyNotificationCreate(&#10;                company_id=booking_in.company_id,&#10;                type=NotificationType.BOOKING_CREATED,&#10;                message=f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;&#10;            )&#10;        )&#10;        db.commit()&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;@router.get(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking])&#10;def get_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        # current_customer: Customer = Depends(get_current_active_customer),&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get booking by ID with details.&#10;    &quot;&quot;&quot;&#10;    booking_id = UUID4(booking_id)&#10;    booking = crud_booking.get(db=db, id=booking_id)&#10;    if not booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;    response.status_code = status.HTTP_200_OK&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=booking,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[List[Booking]], status_code=status.HTTP_200_OK)&#10;async def get_all_bookings(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        start_date: Optional[date] = Query(None, description=&quot;Start date in YYYY-MM-DD format&quot;),&#10;        end_date: Optional[date] = Query(None, description=&quot;End date in YYYY-MM-DD format&quot;)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get bookings with details for a company within a date range.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Company ID is required&quot;&#10;        )&#10;    if not start_date:&#10;        start_date = (datetime.now() - timedelta(days=datetime.now().weekday())).replace(hour=0, minute=0, second=0, microsecond=0)&#10;    if not end_date:&#10;        end_date = (datetime.now() - timedelta(days=datetime.now().weekday()) + timedelta(days=7)).replace(hour=23, minute=59, second=59, microsecond=999999)&#10;&#10;    bookings: List[Booking] = crud_booking.get_all_bookings_in_range_by_company(db=db,&#10;                                                                 company_id=company_id,&#10;                                                                 start_date=start_date,&#10;                                                                 end_date=end_date)&#10;&#10;    if not bookings:&#10;        return DataResponse.success_response(&#10;            message=&quot;No bookings found&quot;,&#10;            data=[],&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=bookings,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/users/create_booking&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;async def create_booking_by_user(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id),&#10;&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;    if not booking_in.company_id:&#10;        booking_in.company_id = company_id&#10;&#10;&#10;    # For unregistered customers, we need customer_info in the booking_in&#10;    if not booking_in.customer_info:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Customer information required for unregistered booking&quot;&#10;        )&#10;    if booking_in.customer_info.id:&#10;        # If customer_info contains an ID, try to fetch that customer&#10;        existing_customer = crud_customer.get(db, id=booking_in.customer_info.id)&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Customer with provided ID not found&quot;&#10;            )&#10;        # If we found the customer by ID, we can skip creating a new one&#10;        booking_in.customer_info = None  # Clear to avoid confusion later&#10;&#10;    # Create a new customer from the provided information&#10;    if booking_in.customer_info:&#10;        customer_data = CustomerCreate(&#10;            first_name=booking_in.customer_info.first_name,&#10;            last_name=booking_in.customer_info.last_name,&#10;            email=booking_in.customer_info.email,&#10;            phone=booking_in.customer_info.phone,&#10;            password=str(uuid.uuid4())  # Random password for inactive account&#10;        )&#10;&#10;        # Check if customer with this email already exists&#10;        existing_customer = crud_customer.get_by_email(db, email=str(customer_data.email))&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            customer = crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Verify that the company exists&#10;    selected_company = crud_company.get(db=db, id=booking_in.company_id)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Selected company not found&quot;&#10;        )&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;&#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        selected_user = crud_user.get(db=db, id=selected_company_service.user_id)&#10;        if not selected_user:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                data = None,&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;User not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;    try:&#10;        booking = crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        await publish_event('booking_created', str({'info': f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;}))&#10;&#10;        # Create confirmation notification for the assigned staff member&#10;        res = notification_service.create_notification(&#10;            db=db,&#10;            notification_request=CompanyNotificationCreate(&#10;                company_id=booking_in.company_id,&#10;                type=NotificationType.BOOKING_CREATED,&#10;                message=f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;&#10;            )&#10;        )&#10;        db.commit()&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;@router.put(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def update_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        booking_update: BookingUpdate,&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update a booking by ID.&#10;    Can update start time, notes, status, and services.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to update this booking&quot;&#10;        )&#10;&#10;    # Validate new start time if provided&#10;    if booking_update.start_time and booking_update.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot schedule booking in the past&quot;&#10;        )&#10;&#10;    # Validate services if provided&#10;    if booking_update.services:&#10;        for service_request in booking_update.services:&#10;            # Verify that the service exists and belongs to the company&#10;            company_service = crud_service.get_service(&#10;                db=db,&#10;                service_id=service_request.category_service_id,&#10;                company_id=company_id&#10;            )&#10;            if not company_service:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                return DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;Service not found or doesn't belong to this company&quot;&#10;                )&#10;&#10;            # Verify that the user(worker) exists and belongs to the company&#10;            selected_user = crud_user.get(db=db, id=service_request.user_id)&#10;            if not selected_user:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                return DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;User not found&quot;&#10;                )&#10;&#10;    try:&#10;        updated_booking = crud_booking.update(&#10;            db=db,&#10;            db_obj=existing_booking,&#10;            obj_in=booking_update&#10;        )&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking updated successfully&quot;,&#10;            data=updated_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def delete_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by ID (marks as cancelled instead of deleting).&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to cancel this booking&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD cancel function to mark the booking as cancelled&#10;        cancelled_booking = crud_booking.cancel(db=db, booking_id=booking_uuid)&#10;        if not cancelled_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        db.commit()&#10;&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking cancelled successfully&quot;,&#10;            data=cancelled_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to cancel booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/{booking_id}/confirm&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def confirm_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to confirm this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot confirm a cancelled booking&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot confirm a completed booking&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD confirm function to mark the booking as confirmed&#10;        confirmed_booking = crud_booking.confirm(db=db, booking_id=booking_uuid)&#10;        if not confirmed_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        db.commit()&#10;&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking confirmed successfully&quot;,&#10;            data=confirmed_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to confirm booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/{booking_id}/complete&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def complete_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Complete a booking by setting its status to COMPLETED.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to complete this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot complete a cancelled booking&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Booking is already completed&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD complete function to mark the booking as completed&#10;        completed_booking = crud_booking.complete(db=db, booking_id=booking_uuid)&#10;        if not completed_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        db.commit()&#10;&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking completed successfully&quot;,&#10;            data=completed_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to complete booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;" />
              <option name="updatedContent" value="from datetime import datetime, timezone, date, timedelta&#10;from typing import List, Optional&#10;&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Header&#10;from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;from app.db.session import get_db&#10;from app.core.redis_client import publish_event&#10;from app.schemas import CompanyNotificationCreate&#10;from app.services.notification_service import notification_service&#10;from app.schemas.schemas import Booking, BookingCreate, BookingUpdate, AvailabilityResponse, CustomerCreate&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import customer as crud_customer&#10;from app.api.dependencies import get_current_company_id, get_token_payload&#10;from app.schemas.responses import DataResponse&#10;from app.api.dependencies import get_current_customer&#10;from app.models import BookingServices, BookingStatus, NotificationType&#10;&#10;from app.services.auth import verify_token&#10;import uuid&#10;&#10;&#10;router = APIRouter()&#10;security = HTTPBearer(auto_error=False)&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;async def create_booking(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;    # print(credentials)&#10;    # if credentials:&#10;    #     customer = get_current_customer(credentials=credentials, db=db)&#10;&#10;    publish_event('booking_created',&#10;                  str({'info': f&quot;TEST&quot;}))&#10;&#10;    # If no valid customer found, create a new inactive one&#10;    if not customer:&#10;        # For unregistered customers, we need customer_info in the booking_in&#10;        if not booking_in.customer_info:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Customer information required for unregistered booking&quot;&#10;            )&#10;        if booking_in.customer_info.id:&#10;            # If customer_info contains an ID, try to fetch that customer&#10;            existing_customer = crud_customer.get(db, id=booking_in.customer_info.id)&#10;            if existing_customer:&#10;                customer = existing_customer&#10;            else:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                raise DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;Customer with provided ID not found&quot;&#10;                )&#10;            # If we found the customer by ID, we can skip creating a new one&#10;            booking_in.customer_info = None  # Clear to avoid confusion later&#10;&#10;        # Create a new customer from the provided information&#10;        if booking_in.customer_info:&#10;            customer_data = CustomerCreate(&#10;                first_name=booking_in.customer_info.first_name,&#10;                last_name=booking_in.customer_info.last_name,&#10;                email=booking_in.customer_info.email,&#10;                phone=booking_in.customer_info.phone,&#10;                password=str(uuid.uuid4())  # Random password for inactive account&#10;            )&#10;&#10;            # Check if customer with this email already exists&#10;            existing_customer = crud_customer.get_by_email(db, email=str(customer_data.email))&#10;            if existing_customer:&#10;                customer = existing_customer&#10;            else:&#10;                customer = crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Verify that the company exists&#10;    selected_company = crud_company.get(db=db, id=booking_in.company_id)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Selected company not found&quot;&#10;        )&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;&#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        selected_user = crud_user.get(db=db, id=selected_company_service.user_id)&#10;        if not selected_user:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;User not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;    try:&#10;        booking = crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        publish_event('booking_created', str({'info': f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;}))&#10;&#10;        # Create confirmation notification for the assigned staff member&#10;        res = notification_service.create_notification(&#10;            db=db,&#10;            notification_request=CompanyNotificationCreate(&#10;                company_id=booking_in.company_id,&#10;                type=NotificationType.BOOKING_CREATED,&#10;                message=f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;&#10;            )&#10;        )&#10;        db.commit()&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;@router.get(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking])&#10;def get_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        # current_customer: Customer = Depends(get_current_active_customer),&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get booking by ID with details.&#10;    &quot;&quot;&quot;&#10;    booking_id = UUID4(booking_id)&#10;    booking = crud_booking.get(db=db, id=booking_id)&#10;    if not booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;    response.status_code = status.HTTP_200_OK&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=booking,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[List[Booking]], status_code=status.HTTP_200_OK)&#10;async def get_all_bookings(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        start_date: Optional[date] = Query(None, description=&quot;Start date in YYYY-MM-DD format&quot;),&#10;        end_date: Optional[date] = Query(None, description=&quot;End date in YYYY-MM-DD format&quot;)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get bookings with details for a company within a date range.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Company ID is required&quot;&#10;        )&#10;    if not start_date:&#10;        start_date = (datetime.now() - timedelta(days=datetime.now().weekday())).replace(hour=0, minute=0, second=0, microsecond=0)&#10;    if not end_date:&#10;        end_date = (datetime.now() - timedelta(days=datetime.now().weekday()) + timedelta(days=7)).replace(hour=23, minute=59, second=59, microsecond=999999)&#10;&#10;    bookings: List[Booking] = crud_booking.get_all_bookings_in_range_by_company(db=db,&#10;                                                                 company_id=company_id,&#10;                                                                 start_date=start_date,&#10;                                                                 end_date=end_date)&#10;&#10;    if not bookings:&#10;        return DataResponse.success_response(&#10;            message=&quot;No bookings found&quot;,&#10;            data=[],&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=bookings,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/users/create_booking&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;async def create_booking_by_user(&#10;        *,&#10;        db: Session = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id),&#10;&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;    if not booking_in.company_id:&#10;        booking_in.company_id = company_id&#10;&#10;&#10;    # For unregistered customers, we need customer_info in the booking_in&#10;    if not booking_in.customer_info:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Customer information required for unregistered booking&quot;&#10;        )&#10;    if booking_in.customer_info.id:&#10;        # If customer_info contains an ID, try to fetch that customer&#10;        existing_customer = crud_customer.get(db, id=booking_in.customer_info.id)&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Customer with provided ID not found&quot;&#10;            )&#10;        # If we found the customer by ID, we can skip creating a new one&#10;        booking_in.customer_info = None  # Clear to avoid confusion later&#10;&#10;    # Create a new customer from the provided information&#10;    if booking_in.customer_info:&#10;        customer_data = CustomerCreate(&#10;            first_name=booking_in.customer_info.first_name,&#10;            last_name=booking_in.customer_info.last_name,&#10;            email=booking_in.customer_info.email,&#10;            phone=booking_in.customer_info.phone,&#10;            password=str(uuid.uuid4())  # Random password for inactive account&#10;        )&#10;&#10;        # Check if customer with this email already exists&#10;        existing_customer = crud_customer.get_by_email(db, email=str(customer_data.email))&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            customer = crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Verify that the company exists&#10;    selected_company = crud_company.get(db=db, id=booking_in.company_id)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Selected company not found&quot;&#10;        )&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;&#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        selected_user = crud_user.get(db=db, id=selected_company_service.user_id)&#10;        if not selected_user:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                data = None,&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;User not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;    try:&#10;        booking = crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        await publish_event('booking_created', str({'info': f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;}))&#10;&#10;        # Create confirmation notification for the assigned staff member&#10;        res = notification_service.create_notification(&#10;            db=db,&#10;            notification_request=CompanyNotificationCreate(&#10;                company_id=booking_in.company_id,&#10;                type=NotificationType.BOOKING_CREATED,&#10;                message=f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;&#10;            )&#10;        )&#10;        db.commit()&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;@router.put(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def update_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        booking_update: BookingUpdate,&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update a booking by ID.&#10;    Can update start time, notes, status, and services.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to update this booking&quot;&#10;        )&#10;&#10;    # Validate new start time if provided&#10;    if booking_update.start_time and booking_update.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot schedule booking in the past&quot;&#10;        )&#10;&#10;    # Validate services if provided&#10;    if booking_update.services:&#10;        for service_request in booking_update.services:&#10;            # Verify that the service exists and belongs to the company&#10;            company_service = crud_service.get_service(&#10;                db=db,&#10;                service_id=service_request.category_service_id,&#10;                company_id=company_id&#10;            )&#10;            if not company_service:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                return DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;Service not found or doesn't belong to this company&quot;&#10;                )&#10;&#10;            # Verify that the user(worker) exists and belongs to the company&#10;            selected_user = crud_user.get(db=db, id=service_request.user_id)&#10;            if not selected_user:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                return DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;User not found&quot;&#10;                )&#10;&#10;    try:&#10;        updated_booking = crud_booking.update(&#10;            db=db,&#10;            db_obj=existing_booking,&#10;            obj_in=booking_update&#10;        )&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking updated successfully&quot;,&#10;            data=updated_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def delete_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by ID (marks as cancelled instead of deleting).&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to cancel this booking&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD cancel function to mark the booking as cancelled&#10;        cancelled_booking = crud_booking.cancel(db=db, booking_id=booking_uuid)&#10;        if not cancelled_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        db.commit()&#10;&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking cancelled successfully&quot;,&#10;            data=cancelled_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to cancel booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/{booking_id}/confirm&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def confirm_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to confirm this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot confirm a cancelled booking&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot confirm a completed booking&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD confirm function to mark the booking as confirmed&#10;        confirmed_booking = crud_booking.confirm(db=db, booking_id=booking_uuid)&#10;        if not confirmed_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        db.commit()&#10;&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking confirmed successfully&quot;,&#10;            data=confirmed_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to confirm booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/{booking_id}/complete&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def complete_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: Session = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Complete a booking by setting its status to COMPLETED.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to complete this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot complete a cancelled booking&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Booking is already completed&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD complete function to mark the booking as completed&#10;        completed_booking = crud_booking.complete(db=db, booking_id=booking_uuid)&#10;        if not completed_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        db.commit()&#10;&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking completed successfully&quot;,&#10;            data=completed_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to complete booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/users.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/users.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from datetime import datetime, timedelta&#10;&#10;from fastapi.responses import RedirectResponse, JSONResponse&#10;&#10;from app.api.dependencies import get_current_active_user, get_current_company_id&#10;from app.db.session import get_db&#10;from app.models import AvailabilityType&#10;from app.models.models import Users&#10;from app.schemas import User&#10;from app.schemas.auth import (&#10;    LoginRequest, TokenResponse, VerificationRequest,&#10;    GoogleAuthorizationResponse, GoogleCallbackRequest, GoogleOAuthResponse&#10;)&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import ResponseMessage, TimeOffCreate, TimeOff, TimeOffUpdate&#10;from app.schemas.schemas import UserCreate&#10;from app.services.auth import hash_password, verify_password, create_token_pair, verify_token&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_time_off&#10;from app.services.crud import company as crud_company&#10;from app.services.email_service import email_service, create_verification_token&#10;from app.services.google_oauth import GoogleOAuthService&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;router = APIRouter()&#10;&#10;&#10;# Helper function to create a new user (reused by both signup and Google OAuth)&#10;async def _create_new_user(&#10;    db: Session,&#10;    user_in: UserCreate,&#10;    send_verification_email: bool = True&#10;) -&gt; tuple[Users, str]:&#10;    &quot;&quot;&quot;&#10;    Internal helper to create a new user.&#10;&#10;    Returns:&#10;        Tuple of (new_user, message)&#10;    &quot;&quot;&quot;&#10;    user_in.email = user_in.email.lower()&#10;&#10;    # Check if user already exists&#10;    existing_user = crud_user.get_by_email(db=db, email=user_in.email)&#10;    if existing_user:&#10;        raise ValueError(&quot;User with this email already exists&quot;)&#10;&#10;    # Hash password&#10;    user_in.password = hash_password(user_in.password)&#10;    new_user = crud_user.create(db=db, obj_in=user_in)&#10;&#10;    # Create verification token&#10;    verification_record = create_verification_token(&#10;        db=db,&#10;        entity_id=new_user.id,&#10;        verification_type=VerificationType.EMAIL,&#10;        entity_type=&quot;user&quot;,&#10;        expires_in_hours=24&#10;    )&#10;&#10;    if send_verification_email:&#10;        # Send verification email&#10;        user_name = f&quot;{new_user.first_name} {new_user.last_name}&quot;&#10;        email_sent = email_service.send_verification_email(&#10;            to_email=new_user.email,&#10;            verification_token=verification_record.token,&#10;            user_name=user_name&#10;        )&#10;&#10;        if not email_sent:&#10;            raise Exception(f&quot;Warning: Failed to send verification email to {new_user.email}&quot;)&#10;&#10;        message = &quot;User created successfully. Please check your email to verify your account.&quot;&#10;    else:&#10;        # Auto-verify email for OAuth users&#10;        crud_user.verify_token(db=db, db_obj=verification_record)&#10;        message = &quot;User created successfully via Google OAuth&quot;&#10;&#10;    return new_user, message&#10;&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=ResponseMessage, status_code=status.HTTP_201_CREATED)&#10;async def create_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    user_in: UserCreate&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Register a new user and send email verification.&#10;    &quot;&quot;&quot;&#10;&#10;    try:&#10;        new_user, message = await _create_new_user(db, user_in, send_verification_email=True)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return ResponseMessage(message=message, status=&quot;success&quot;)&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return ResponseMessage(message=str(e), status=&quot;error&quot;)&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=DataResponse)&#10;async def verify_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify user email with token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_user.get_verification_token(&#10;            db=db,&#10;            token=verification_in.token,&#10;            type=VerificationType.EMAIL&#10;        )&#10;&#10;        if not token:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Verification token not found&quot;&#10;            )&#10;&#10;        if token.status != VerificationStatus.PENDING or token.expires_at &lt; datetime.now():&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Token has expired or is invalid&quot;&#10;            )&#10;&#10;        result = crud_user.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return DataResponse.success_response(&#10;                message=&quot;Email verified successfully&quot;&#10;            )&#10;&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=&quot;Email verification failed&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Verification process failed: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=DataResponse[TokenResponse])&#10;async def user_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Login professional using mobile number or email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    &#10;    # Try to get professional by mobile number first&#10;    user = crud_user.get_by_email(db, email=login_data.email)&#10;&#10;    if not user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Verify password&#10;    if not verify_password(login_data.password, user.password):&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;    company = crud_user.get_company_by_user(db, user.id)&#10;    &#10;    # Create token pair&#10;    tokens = create_token_pair(user.id, user.email, actor=&quot;user&quot;, ver=&quot;1&quot;, company_id=str(company.company_id) if company else '')&#10;    &#10;    # Determine cookie domain - use shared domain for production&#10;    cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;    is_production = &quot;https://&quot; in settings.API_URL&#10;    &#10;    response.set_cookie(&#10;        key=&quot;refresh_token&quot;,&#10;        value=tokens[&quot;refresh_token&quot;],&#10;        max_age=3600,&#10;        httponly=True,&#10;        secure=is_production,&#10;        samesite=&quot;lax&quot;,&#10;        domain=cookie_domain&#10;    )&#10;    response.set_cookie(&#10;        key=&quot;access_token&quot;,&#10;        value=tokens[&quot;access_token&quot;],&#10;        max_age=tokens['expires_in'],&#10;        httponly=True,&#10;        secure=is_production,&#10;        samesite=&quot;lax&quot;,&#10;        domain=cookie_domain&#10;    )&#10;&#10;    return DataResponse.success_response(data = TokenResponse(**tokens))&#10;&#10;&#10;@router.put(&quot;/auth/logout&quot;)&#10;async def logout_user(response: Response):&#10;    &quot;&quot;&quot;&#10;    Logout professional by clearing the refresh token cookie&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        # Determine cookie domain - must match the domain used when setting cookies&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;        &#10;        # Delete cookies with the same parameters used when setting them&#10;        response.delete_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            domain=cookie_domain,&#10;            secure=is_production,&#10;            httponly=True,&#10;            samesite=&quot;lax&quot;&#10;        )&#10;        response.delete_cookie(&#10;            key=&quot;access_token&quot;,&#10;            domain=cookie_domain,&#10;            secure=is_production,&#10;            httponly=True,&#10;            samesite=&quot;lax&quot;&#10;        )&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.get(&quot;/me&quot;, response_model=DataResponse)&#10;async def get_current_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get current logged-in user. Returns CompanyUser if user belongs to a company, otherwise returns User.&#10;    &quot;&quot;&quot;&#10;    # Check if user belongs to a company&#10;    if current_user.company_id:&#10;        try:&#10;            # Get company user details&#10;            company_user = crud_company.get_company_user(&#10;                db=db, &#10;                user_id=str(current_user.id), &#10;                company_id=str(current_user.company_id)&#10;            )&#10;            if company_user:&#10;                return DataResponse.success_response(data=company_user)&#10;        except Exception as e:&#10;            print(f&quot;Error fetching company user: {str(e)}&quot;)&#10;            # Fall through to return basic user if company user fetch fails&#10;    &#10;    # Return basic user if no company association - convert SQLAlchemy model to Pydantic schema&#10;    user_schema = User.model_validate(current_user)&#10;    return DataResponse.success_response(data=user_schema)&#10;&#10;&#10;@router.post(&quot;/time-offs&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_201_CREATED)&#10;async def create_time_off(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffCreate,&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for the current user.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=time_off_in.user_id,&#10;            start_date=time_off_in.start_date,&#10;            end_date=time_off_in.end_date&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Create the time off&#10;        time_off = crud_time_off.create(&#10;            db=db,&#10;            obj_in=time_off_in,&#10;            company_id=company_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off created successfully&quot;,&#10;            data=time_off,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/time-offs&quot;, response_model=DataResponse[List[TimeOff]], status_code=status.HTTP_200_OK)&#10;async def get_all_user_time_offs(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    start_date: datetime = Query(datetime.today(), description=&quot;Filter time offs that end after this date&quot;),&#10;    availability_type: AvailabilityType = Query(AvailabilityType.WEEKLY, description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all time offs for the current user with optional date filtering.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        end_date = start_date + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        time_offs = crud_time_off.get_user_time_offs(&#10;            db=db,&#10;            company_id=company_id,&#10;            start_date=start_date,&#10;            end_date=end_date&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=time_offs,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve time offs: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_200_OK)&#10;async def update_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffUpdate,&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the time off by ID&#10;        time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;        if not time_off:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Time off not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if the time off belongs to the current user&#10;        if str(time_off.user_id) != str(current_user.id):&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                message=&quot;You don't have permission to update this time off&quot;,&#10;                status_code=status.HTTP_403_FORBIDDEN&#10;            )&#10;&#10;        # Determine the new start and end dates for overlap check&#10;        start_date = time_off_in.start_date if time_off_in.start_date is not None else time_off.start_date&#10;        end_date = time_off_in.end_date if time_off_in.end_date is not None else time_off.end_date&#10;&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=current_user.id,&#10;            start_date=start_date,&#10;            end_date=end_date,&#10;            exclude_id=time_off_id&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The updated time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the time off&#10;        updated_time_off = crud_time_off.update(&#10;            db=db,&#10;            db_obj=time_off,&#10;            obj_in=time_off_in&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off updated successfully&quot;,&#10;            data=updated_time_off,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def delete_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period.&#10;    &quot;&quot;&quot;&#10;    # Get the time off by ID&#10;    time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;    if not time_off:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            message=&quot;Time off not found&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    # Check if the time off belongs to the current user&#10;    if str(time_off.user_id) != str(current_user.id):&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            message=&quot;You don't have permission to delete this time off&quot;,&#10;            status_code=status.HTTP_403_FORBIDDEN&#10;        )&#10;&#10;    # Delete the time off&#10;    deleted = crud_time_off.delete(db=db, time_off_id=time_off_id)&#10;    if not deleted:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Failed to delete time off&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Time off deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=DataResponse[TokenResponse])&#10;async def refresh_token(&#10;    request: Request,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Refresh access and refresh tokens using the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        # Get the refresh token from the request cookies&#10;        refresh_token = request.cookies.get(&quot;refresh_token&quot;)&#10;        if not refresh_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Refresh token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the refresh token&#10;        payload = verify_token(refresh_token, &quot;refresh&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid refresh token&quot;&#10;            )&#10;&#10;        # Extract user data from payload&#10;        user_id = payload.get(&quot;sub&quot;)&#10;        email = payload.get(&quot;email&quot;)&#10;        company_id = payload.get(&quot;company_id&quot;)&#10;&#10;        if not user_id or not email:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid token payload&quot;&#10;            )&#10;&#10;        # Create new tokens&#10;        new_tokens = create_token_pair(&#10;            id=int(user_id),&#10;            email=email,&#10;            actor=&quot;user&quot;,&#10;            ver=&quot;1&quot;,&#10;            company_id=company_id&#10;        )&#10;&#10;        # Determine cookie domain - use shared domain for production&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;&#10;        # Set new cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=new_tokens[&quot;refresh_token&quot;],&#10;            max_age=3600,&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,&#10;            domain=cookie_domain&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=new_tokens[&quot;access_token&quot;],&#10;            max_age=new_tokens['expires_in'],&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,&#10;            domain=cookie_domain&#10;        )&#10;&#10;        return DataResponse.success_response(data=TokenResponse(**new_tokens))&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to refresh token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/verify-token&quot;, response_model=DataResponse[dict])&#10;async def verify_access_token(&#10;    request: Request,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify the access token and return the token data.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the access token from the request cookies&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Access token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the access token&#10;        payload = verify_token(access_token, &quot;access&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid or expired access token&quot;&#10;            )&#10;&#10;        # Return token validity info&#10;        return DataResponse.success_response(data={&#10;            &quot;valid&quot;: True,&#10;            &quot;user_id&quot;: payload.get(&quot;sub&quot;),&#10;            &quot;email&quot;: payload.get(&quot;email&quot;),&#10;            &quot;company_id&quot;: payload.get(&quot;company_id&quot;),&#10;            &quot;expires_at&quot;: payload.get(&quot;exp&quot;)&#10;        })&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to verify token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/google/authorize&quot;, response_model=GoogleAuthorizationResponse)&#10;async def google_authorize(&#10;    response: Response&#10;) -&gt; GoogleAuthorizationResponse:&#10;    &quot;&quot;&quot;&#10;    Initiate Google OAuth flow - returns authorization URL and state token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        state = GoogleOAuthService.generate_state_token()&#10;&#10;        # Store state in response cookie for verification later&#10;        response.set_cookie(&#10;            key=&quot;google_oauth_state&quot;,&#10;            value=state,&#10;            httponly=True,&#10;            secure=True,&#10;            samesite=&quot;lax&quot;,&#10;            max_age=600  # 10 minutes&#10;        )&#10;&#10;        authorization_url = GoogleOAuthService.get_authorization_url(state)&#10;&#10;        return GoogleAuthorizationResponse(&#10;            authorization_url=authorization_url,&#10;            state=state&#10;        )&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to initiate Google OAuth: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.get(&quot;/auth/google/callback&quot;)&#10;async def google_callback(&#10;    request: Request,&#10;    state: str = Query(..., description=&quot;State token for CSRF protection&quot;),&#10;    code: str = Query(..., description=&quot;Authorization code from Google&quot;),&#10;    db: Session = Depends(get_db)&#10;):&#10;    &quot;&quot;&quot;&#10;    Handle Google OAuth callback for both signup and login.&#10;    - If user exists: authenticates and returns tokens&#10;    - If user doesn't exist: creates new user with random password and returns tokens&#10;&#10;    This unified endpoint eliminates the need for separate signup/login paths.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        error = None&#10;        google_email = &quot;&quot;&#10;        google_name = &quot;Google User&quot;  # Initialize with default value&#10;        # Verify state token for CSRF protection&#10;        stored_state = request.cookies.get(&quot;google_oauth_state&quot;)&#10;        if not stored_state or stored_state != state:&#10;            error = 'Invalid state parameter'&#10;        else:&#10;            # Get redirect_uri from environment or default&#10;            redirect_uri = getattr(settings, 'GOOGLE_REDIRECT_URI', 'http://localhost:8000/api/v1/users/auth/google/callback')&#10;&#10;            # Exchange authorization code for tokens&#10;            token_response = GoogleOAuthService.exchange_code_for_token(&#10;                code,&#10;                redirect_uri&#10;            )&#10;&#10;            if not token_response:&#10;                error = 'Failed to exchange authorization code for tokens'&#10;            else:&#10;                access_token = token_response.get(&quot;access_token&quot;)&#10;                if not access_token:&#10;                    error = 'No access token in response'&#10;&#10;                else:&#10;                    # Get user info from Google&#10;                    user_info = GoogleOAuthService.get_user_info(access_token)&#10;&#10;                    if not user_info:&#10;                        error = 'Failed to retrieve user information from Google'&#10;&#10;                    else:&#10;                        google_email = user_info.get(&quot;email&quot;, &quot;&quot;).lower()&#10;                        google_name = user_info.get(&quot;name&quot;, &quot;Google User&quot;)&#10;&#10;                        if not google_email:&#10;                            error = 'Google account does not have an email'&#10;&#10;        if error:&#10;            return JSONResponse(content={&quot;error&quot;: error}, status_code=status.HTTP_400_BAD_REQUEST)&#10;&#10;        # Check if user already exists&#10;        user = crud_user.get_by_email(db=db, email=google_email)&#10;&#10;        if user:&#10;            # User exists - authenticate them&#10;            company = crud_user.get_company_by_user(db, user.id)&#10;            tokens = create_token_pair(&#10;                user.id,&#10;                user.email,&#10;                actor=&quot;user&quot;,&#10;                ver=&quot;1&quot;,&#10;                company_id=str(company.company_id) if company else ''&#10;            )&#10;            auth_message = &quot;Logged in successfully via Google&quot;&#10;        else:&#10;            # User doesn't exist - create new user with random password&#10;            random_password = GoogleOAuthService.generate_random_password()&#10;            hashed_password = hash_password(random_password)&#10;&#10;            # Parse name into first and last name&#10;            name_parts = google_name.split(&quot; &quot;, 1)&#10;            first_name = name_parts[0] if name_parts else &quot;User&quot;&#10;            last_name = name_parts[1] if len(name_parts) &gt; 1 else &quot;&quot;&#10;&#10;            # Create user object&#10;            user_create = UserCreate(&#10;                first_name=first_name,&#10;                last_name=last_name,&#10;                email=google_email,&#10;                password=hashed_password,&#10;                phone=&quot;&quot;  # Default empty phone for OAuth users&#10;            )&#10;&#10;            new_user, auth_message = await _create_new_user(&#10;                db=db,&#10;                user_in=user_create,&#10;                send_verification_email=False  # No email verification for OAuth users&#10;            )&#10;&#10;            # Create tokens for new user&#10;            tokens = create_token_pair(&#10;                new_user.id,&#10;                new_user.email,&#10;                actor=&quot;user&quot;,&#10;                ver=&quot;1&quot;,&#10;                company_id=&quot;&quot;&#10;            )&#10;            auth_message = &quot;Account created and logged in successfully via Google&quot;&#10;            user = new_user&#10;&#10;        # Create redirect response AFTER tokens are generated&#10;        response = RedirectResponse(&#10;            url=f&quot;{settings.FRONTEND_URL}/users/dashboard&quot;,&#10;            status_code=status.HTTP_303_SEE_OTHER  # Use 303 for proper POST-&gt;GET redirect&#10;        )&#10;&#10;        # Determine cookie domain - use shared domain for production&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;&#10;        # Set cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            max_age=3600,&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,  # Changed from &quot;none&quot; to &quot;lax&quot; for same-site redirects&#10;            domain=cookie_domain&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=tokens[&quot;access_token&quot;],&#10;            max_age=tokens['expires_in'],&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,  # Changed from &quot;none&quot; to &quot;lax&quot; for same-site redirects&#10;            domain=cookie_domain&#10;        )&#10;&#10;        # Clear the state cookie&#10;        response.delete_cookie(key=&quot;google_oauth_state&quot;)&#10;        return response&#10;&#10;    except Exception as e:&#10;        return JSONResponse(content={&quot;error&quot;: &quot;Google OAuth process failed&quot;}, status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from datetime import datetime, timedelta&#10;&#10;from fastapi.responses import RedirectResponse, JSONResponse&#10;&#10;from app.api.dependencies import get_current_active_user, get_current_company_id&#10;from app.db.session import get_db&#10;from app.models import AvailabilityType&#10;from app.models.models import Users&#10;from app.schemas import User&#10;from app.schemas.auth import (&#10;    LoginRequest, TokenResponse, VerificationRequest,&#10;    GoogleAuthorizationResponse, GoogleCallbackRequest, GoogleOAuthResponse&#10;)&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import ResponseMessage, TimeOffCreate, TimeOff, TimeOffUpdate&#10;from app.schemas.schemas import UserCreate&#10;from app.services.auth import hash_password, verify_password, create_token_pair, verify_token&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_time_off&#10;from app.services.crud import company as crud_company&#10;from app.services.email_service import email_service, create_verification_token&#10;from app.services.google_oauth import GoogleOAuthService&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;router = APIRouter()&#10;&#10;&#10;# Helper function to create a new user (reused by both signup and Google OAuth)&#10;async def _create_new_user(&#10;    db: Session,&#10;    user_in: UserCreate,&#10;    send_verification_email: bool = True&#10;) -&gt; tuple[Users, str]:&#10;    &quot;&quot;&quot;&#10;    Internal helper to create a new user.&#10;&#10;    Returns:&#10;        Tuple of (new_user, message)&#10;    &quot;&quot;&quot;&#10;    user_in.email = user_in.email.lower()&#10;&#10;    # Check if user already exists&#10;    existing_user = crud_user.get_by_email(db=db, email=user_in.email)&#10;    if existing_user:&#10;        raise ValueError(&quot;User with this email already exists&quot;)&#10;&#10;    # Hash password&#10;    user_in.password = hash_password(user_in.password)&#10;    new_user = crud_user.create(db=db, obj_in=user_in)&#10;&#10;    # Create verification token&#10;    verification_record = create_verification_token(&#10;        db=db,&#10;        entity_id=new_user.id,&#10;        verification_type=VerificationType.EMAIL,&#10;        entity_type=&quot;user&quot;,&#10;        expires_in_hours=24&#10;    )&#10;&#10;    if send_verification_email:&#10;        # Send verification email&#10;        user_name = f&quot;{new_user.first_name} {new_user.last_name}&quot;&#10;        email_sent = email_service.send_verification_email(&#10;            to_email=new_user.email,&#10;            verification_token=verification_record.token,&#10;            user_name=user_name&#10;        )&#10;&#10;        if not email_sent:&#10;            raise Exception(f&quot;Warning: Failed to send verification email to {new_user.email}&quot;)&#10;&#10;        message = &quot;User created successfully. Please check your email to verify your account.&quot;&#10;    else:&#10;        # Auto-verify email for OAuth users&#10;        crud_user.verify_token(db=db, db_obj=verification_record)&#10;        message = &quot;User created successfully via Google OAuth&quot;&#10;&#10;    return new_user, message&#10;&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=ResponseMessage, status_code=status.HTTP_201_CREATED)&#10;async def create_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    user_in: UserCreate&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Register a new user and send email verification.&#10;    &quot;&quot;&quot;&#10;&#10;    try:&#10;        new_user, message = await _create_new_user(db, user_in, send_verification_email=True)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return ResponseMessage(message=message, status=&quot;success&quot;)&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return ResponseMessage(message=str(e), status=&quot;error&quot;)&#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=DataResponse)&#10;async def verify_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify user email with token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_user.get_verification_token(&#10;            db=db,&#10;            token=verification_in.token,&#10;            type=VerificationType.EMAIL&#10;        )&#10;&#10;        if not token:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Verification token not found&quot;&#10;            )&#10;&#10;        if token.status != VerificationStatus.PENDING or token.expires_at &lt; datetime.now():&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Token has expired or is invalid&quot;&#10;            )&#10;&#10;        result = crud_user.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return DataResponse.success_response(&#10;                message=&quot;Email verified successfully&quot;&#10;            )&#10;&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=&quot;Email verification failed&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Verification process failed: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=DataResponse[TokenResponse])&#10;async def user_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Login professional using mobile number or email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    &#10;    # Try to get professional by mobile number first&#10;    user = crud_user.get_by_email(db, email=login_data.email)&#10;&#10;    if not user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Verify password&#10;    if not verify_password(login_data.password, user.password):&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;    company = crud_user.get_company_by_user(db, user.id)&#10;    &#10;    # Create token pair&#10;    tokens = create_token_pair(user.id, user.email, actor=&quot;user&quot;, ver=&quot;1&quot;, company_id=str(company.company_id) if company else '')&#10;    &#10;    # Determine cookie domain - use shared domain for production&#10;    cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;    is_production = &quot;https://&quot; in settings.API_URL&#10;    &#10;    response.set_cookie(&#10;        key=&quot;refresh_token&quot;,&#10;        value=tokens[&quot;refresh_token&quot;],&#10;        max_age=3600,&#10;        httponly=True,&#10;        secure=is_production,&#10;        samesite=&quot;lax&quot;,&#10;        domain=cookie_domain&#10;    )&#10;    response.set_cookie(&#10;        key=&quot;access_token&quot;,&#10;        value=tokens[&quot;access_token&quot;],&#10;        max_age=tokens['expires_in'],&#10;        httponly=True,&#10;        secure=is_production,&#10;        samesite=&quot;lax&quot;,&#10;        domain=cookie_domain&#10;    )&#10;&#10;    return DataResponse.success_response(data = TokenResponse(**tokens))&#10;&#10;&#10;@router.put(&quot;/auth/logout&quot;)&#10;async def logout_user(response: Response):&#10;    &quot;&quot;&quot;&#10;    Logout professional by clearing the refresh token cookie&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        # Determine cookie domain - must match the domain used when setting cookies&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;        &#10;        # Delete cookies with the same parameters used when setting them&#10;        response.delete_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            domain=cookie_domain,&#10;            secure=is_production,&#10;            httponly=True,&#10;            samesite=&quot;lax&quot;&#10;        )&#10;        response.delete_cookie(&#10;            key=&quot;access_token&quot;,&#10;            domain=cookie_domain,&#10;            secure=is_production,&#10;            httponly=True,&#10;            samesite=&quot;lax&quot;&#10;        )&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.get(&quot;/me&quot;, response_model=DataResponse)&#10;async def get_current_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get current logged-in user. Returns CompanyUser if user belongs to a company, otherwise returns User.&#10;    &quot;&quot;&quot;&#10;    # Check if user belongs to a company&#10;    if current_user.company_id:&#10;        try:&#10;            # Get company user details&#10;            company_user = crud_company.get_company_user(&#10;                db=db, &#10;                user_id=str(current_user.id), &#10;                company_id=str(current_user.company_id)&#10;            )&#10;            if company_user:&#10;                return DataResponse.success_response(data=company_user)&#10;        except Exception as e:&#10;            print(f&quot;Error fetching company user: {str(e)}&quot;)&#10;            # Fall through to return basic user if company user fetch fails&#10;    &#10;    # Return basic user if no company association - convert SQLAlchemy model to Pydantic schema&#10;    user_schema = User.model_validate(current_user)&#10;    return DataResponse.success_response(data=user_schema)&#10;&#10;&#10;@router.post(&quot;/time-offs&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_201_CREATED)&#10;async def create_time_off(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffCreate,&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for the current user.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=time_off_in.user_id,&#10;            start_date=time_off_in.start_date,&#10;            end_date=time_off_in.end_date&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Create the time off&#10;        time_off = crud_time_off.create(&#10;            db=db,&#10;            obj_in=time_off_in,&#10;            company_id=company_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off created successfully&quot;,&#10;            data=time_off,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/time-offs&quot;, response_model=DataResponse[List[TimeOff]], status_code=status.HTTP_200_OK)&#10;async def get_all_user_time_offs(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    start_date: datetime = Query(datetime.today(), description=&quot;Filter time offs that end after this date&quot;),&#10;    availability_type: AvailabilityType = Query(AvailabilityType.WEEKLY, description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all time offs for the current user with optional date filtering.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        end_date = start_date + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        time_offs = crud_time_off.get_user_time_offs(&#10;            db=db,&#10;            company_id=company_id,&#10;            start_date=start_date,&#10;            end_date=end_date&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=time_offs,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve time offs: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_200_OK)&#10;async def update_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffUpdate,&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the time off by ID&#10;        time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;        if not time_off:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Time off not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if the time off belongs to the current user&#10;        if str(time_off.user_id) != str(current_user.id):&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                message=&quot;You don't have permission to update this time off&quot;,&#10;                status_code=status.HTTP_403_FORBIDDEN&#10;            )&#10;&#10;        # Determine the new start and end dates for overlap check&#10;        start_date = time_off_in.start_date if time_off_in.start_date is not None else time_off.start_date&#10;        end_date = time_off_in.end_date if time_off_in.end_date is not None else time_off.end_date&#10;&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=current_user.id,&#10;            start_date=start_date,&#10;            end_date=end_date,&#10;            exclude_id=time_off_id&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The updated time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the time off&#10;        updated_time_off = crud_time_off.update(&#10;            db=db,&#10;            db_obj=time_off,&#10;            obj_in=time_off_in&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off updated successfully&quot;,&#10;            data=updated_time_off,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def delete_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period.&#10;    &quot;&quot;&quot;&#10;    # Get the time off by ID&#10;    time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;    if not time_off:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            message=&quot;Time off not found&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    # Check if the time off belongs to the current user&#10;    if str(time_off.user_id) != str(current_user.id):&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            message=&quot;You don't have permission to delete this time off&quot;,&#10;            status_code=status.HTTP_403_FORBIDDEN&#10;        )&#10;&#10;    # Delete the time off&#10;    deleted = crud_time_off.delete(db=db, time_off_id=time_off_id)&#10;    if not deleted:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Failed to delete time off&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Time off deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=DataResponse[TokenResponse])&#10;async def refresh_token(&#10;    request: Request,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Refresh access and refresh tokens using the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        # Get the refresh token from the request cookies&#10;        refresh_token = request.cookies.get(&quot;refresh_token&quot;)&#10;        if not refresh_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Refresh token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the refresh token&#10;        payload = verify_token(refresh_token, &quot;refresh&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid refresh token&quot;&#10;            )&#10;&#10;        # Extract user data from payload&#10;        user_id = payload.get(&quot;sub&quot;)&#10;        email = payload.get(&quot;email&quot;)&#10;        company_id = payload.get(&quot;company_id&quot;)&#10;&#10;        if not user_id or not email:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid token payload&quot;&#10;            )&#10;&#10;        # Create new tokens&#10;        new_tokens = create_token_pair(&#10;            id=int(user_id),&#10;            email=email,&#10;            actor=&quot;user&quot;,&#10;            ver=&quot;1&quot;,&#10;            company_id=company_id&#10;        )&#10;&#10;        # Determine cookie domain - use shared domain for production&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;&#10;        # Set new cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=new_tokens[&quot;refresh_token&quot;],&#10;            max_age=3600,&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,&#10;            domain=cookie_domain&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=new_tokens[&quot;access_token&quot;],&#10;            max_age=new_tokens['expires_in'],&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,&#10;            domain=cookie_domain&#10;        )&#10;&#10;        return DataResponse.success_response(data=TokenResponse(**new_tokens))&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to refresh token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/verify-token&quot;, response_model=DataResponse[dict])&#10;async def verify_access_token(&#10;    request: Request,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify the access token and return the token data.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the access token from the request cookies&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Access token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the access token&#10;        payload = verify_token(access_token, &quot;access&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid or expired access token&quot;&#10;            )&#10;&#10;        # Return token validity info&#10;        return DataResponse.success_response(data={&#10;            &quot;valid&quot;: True,&#10;            &quot;user_id&quot;: payload.get(&quot;sub&quot;),&#10;            &quot;email&quot;: payload.get(&quot;email&quot;),&#10;            &quot;company_id&quot;: payload.get(&quot;company_id&quot;),&#10;            &quot;expires_at&quot;: payload.get(&quot;exp&quot;)&#10;        })&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to verify token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/google/authorize&quot;, response_model=GoogleAuthorizationResponse)&#10;async def google_authorize(&#10;    response: Response&#10;) -&gt; GoogleAuthorizationResponse:&#10;    &quot;&quot;&quot;&#10;    Initiate Google OAuth flow - returns authorization URL and state token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        state = GoogleOAuthService.generate_state_token()&#10;&#10;        # Store state in response cookie for verification later&#10;        response.set_cookie(&#10;            key=&quot;google_oauth_state&quot;,&#10;            value=state,&#10;            httponly=True,&#10;            secure=True,&#10;            samesite=&quot;lax&quot;,&#10;            max_age=600  # 10 minutes&#10;        )&#10;&#10;        authorization_url = GoogleOAuthService.get_authorization_url(state)&#10;&#10;        return GoogleAuthorizationResponse(&#10;            authorization_url=authorization_url,&#10;            state=state&#10;        )&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to initiate Google OAuth: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.get(&quot;/auth/google/callback&quot;)&#10;async def google_callback(&#10;    request: Request,&#10;    state: str = Query(..., description=&quot;State token for CSRF protection&quot;),&#10;    code: str = Query(..., description=&quot;Authorization code from Google&quot;),&#10;    db: Session = Depends(get_db)&#10;):&#10;    &quot;&quot;&quot;&#10;    Handle Google OAuth callback for both signup and login.&#10;    - If user exists: authenticates and returns tokens&#10;    - If user doesn't exist: creates new user with random password and returns tokens&#10;&#10;    This unified endpoint eliminates the need for separate signup/login paths.&#10;    &quot;&quot;&quot;&#10;    from app.core.config import settings&#10;    try:&#10;        error = None&#10;        google_email = &quot;&quot;&#10;        google_name = &quot;Google User&quot;  # Initialize with default value&#10;        # Verify state token for CSRF protection&#10;        stored_state = request.cookies.get(&quot;google_oauth_state&quot;)&#10;        if not stored_state or stored_state != state:&#10;            error = 'Invalid state parameter'&#10;        else:&#10;            # Get redirect_uri from environment or default&#10;            redirect_uri = getattr(settings, 'GOOGLE_REDIRECT_URI', 'http://localhost:8000/api/v1/users/auth/google/callback')&#10;&#10;            # Exchange authorization code for tokens&#10;            token_response = GoogleOAuthService.exchange_code_for_token(&#10;                code,&#10;                redirect_uri&#10;            )&#10;&#10;            if not token_response:&#10;                error = 'Failed to exchange authorization code for tokens'&#10;            else:&#10;                access_token = token_response.get(&quot;access_token&quot;)&#10;                if not access_token:&#10;                    error = 'No access token in response'&#10;&#10;                else:&#10;                    # Get user info from Google&#10;                    user_info = GoogleOAuthService.get_user_info(access_token)&#10;&#10;                    if not user_info:&#10;                        error = 'Failed to retrieve user information from Google'&#10;&#10;                    else:&#10;                        google_email = user_info.get(&quot;email&quot;, &quot;&quot;).lower()&#10;                        google_name = user_info.get(&quot;name&quot;, &quot;Google User&quot;)&#10;&#10;                        if not google_email:&#10;                            error = 'Google account does not have an email'&#10;&#10;        if error:&#10;            return JSONResponse(content={&quot;error&quot;: error}, status_code=status.HTTP_400_BAD_REQUEST)&#10;&#10;        # Check if user already exists&#10;        user = crud_user.get_by_email(db=db, email=google_email)&#10;&#10;        if user:&#10;            # User exists - authenticate them&#10;            company = crud_user.get_company_by_user(db, user.id)&#10;            tokens = create_token_pair(&#10;                user.id,&#10;                user.email,&#10;                actor=&quot;user&quot;,&#10;                ver=&quot;1&quot;,&#10;                company_id=str(company.company_id) if company else ''&#10;            )&#10;            auth_message = &quot;Logged in successfully via Google&quot;&#10;        else:&#10;            # User doesn't exist - create new user with random password&#10;            random_password = GoogleOAuthService.generate_random_password()&#10;            hashed_password = hash_password(random_password)&#10;&#10;            # Parse name into first and last name&#10;            name_parts = google_name.split(&quot; &quot;, 1)&#10;            first_name = name_parts[0] if name_parts else &quot;User&quot;&#10;            last_name = name_parts[1] if len(name_parts) &gt; 1 else &quot;&quot;&#10;&#10;            # Create user object&#10;            user_create = UserCreate(&#10;                first_name=first_name,&#10;                last_name=last_name,&#10;                email=google_email,&#10;                password=hashed_password,&#10;                phone=&quot;&quot;  # Default empty phone for OAuth users&#10;            )&#10;&#10;            new_user, auth_message = await _create_new_user(&#10;                db=db,&#10;                user_in=user_create,&#10;                send_verification_email=False  # No email verification for OAuth users&#10;            )&#10;&#10;            # Create tokens for new user&#10;            tokens = create_token_pair(&#10;                new_user.id,&#10;                new_user.email,&#10;                actor=&quot;user&quot;,&#10;                ver=&quot;1&quot;,&#10;                company_id=&quot;&quot;&#10;            )&#10;            auth_message = &quot;Account created and logged in successfully via Google&quot;&#10;            user = new_user&#10;&#10;        # Create redirect response AFTER tokens are generated&#10;        response = RedirectResponse(&#10;            url=f&quot;{settings.FRONTEND_URL}/users/dashboard&quot;,&#10;            status_code=status.HTTP_303_SEE_OTHER  # Use 303 for proper POST-&gt;GET redirect&#10;        )&#10;&#10;        # Determine cookie domain - use shared domain for production&#10;        cookie_domain = &quot;.salona.me&quot; if &quot;salona.me&quot; in settings.API_URL else None&#10;        is_production = &quot;https://&quot; in settings.API_URL&#10;&#10;        # Set cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            max_age=3600,&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,  # Changed from &quot;none&quot; to &quot;lax&quot; for same-site redirects&#10;            domain=cookie_domain&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=tokens[&quot;access_token&quot;],&#10;            max_age=tokens['expires_in'],&#10;            httponly=True,&#10;            secure=is_production,&#10;            samesite=&quot;lax&quot;,  # Changed from &quot;none&quot; to &quot;lax&quot; for same-site redirects&#10;            domain=cookie_domain&#10;        )&#10;&#10;        # Clear the state cookie&#10;        response.delete_cookie(key=&quot;google_oauth_state&quot;)&#10;        return response&#10;&#10;    except Exception as e:&#10;        return JSONResponse(content={&quot;error&quot;: &quot;Google OAuth process failed&quot;}, status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/dependencies.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/dependencies.py" />
              <option name="originalContent" value="from fastapi import Depends, HTTPException, status, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from app.db.session import get_db&#10;from app.schemas import User&#10;from app.services.auth import get_current_id, verify_token&#10;from app.services.crud import user as crud_user, customer as crud_customer, company as crud_company&#10;from app.models.models import Users, Customers, CompanyUsers&#10;from app.models.enums import CompanyRoleType&#10;&#10;&#10;async def get_current_user(&#10;    request: Request,&#10;    db: Session = Depends(get_db)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current authenticated user from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;    &#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract user ID from token (this will raise HTTPException with specific message if token is expired)&#10;    user_id = get_current_id(access_token)&#10;    if user_id is None:&#10;        raise credentials_exception&#10;&#10;    # Get user from database&#10;    user, company_id = crud_user.get(db, id=user_id)&#10;    if user is None:&#10;        raise credentials_exception&#10;&#10;    user.company_id = company_id&#10;    return user&#10;&#10;&#10;def get_current_customer(&#10;        request: Request,&#10;        db: Session = Depends(get_db)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current authenticated customer from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    try:&#10;        # Extract access token from HTTP-only cookie&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise credentials_exception&#10;&#10;        # Extract customer ID from token&#10;        customer_id = get_current_id(access_token)&#10;        if customer_id is None:&#10;            raise credentials_exception&#10;&#10;    except Exception:&#10;        raise credentials_exception&#10;&#10;    # Get customer from database&#10;    customer = crud_customer.get(db, id=customer_id)&#10;&#10;    if customer is None:&#10;        raise credentials_exception&#10;&#10;    return customer&#10;&#10;&#10;def get_token_payload(&#10;        request: Request&#10;) -&gt; dict:&#10;    &quot;&quot;&quot;Extract and return the payload from the JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract payload from token (this will raise HTTPException with specific message if token is expired)&#10;    payload = verify_token(access_token)&#10;    if payload is None:&#10;        raise credentials_exception&#10;&#10;    return payload&#10;&#10;&#10;def get_current_company_id(token_payload: dict = Depends(get_token_payload)) -&gt; str:&#10;    company_id = token_payload.get(&quot;company_id&quot;)&#10;    if not company_id:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            detail=&quot;Company ID not found in token&quot;&#10;        )&#10;    return company_id&#10;&#10;&#10;async def get_current_active_user(&#10;    current_user: Users = Depends(get_current_user)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_user&#10;&#10;&#10;async def get_current_company_user(&#10;        current_user: Users = Depends(get_current_user),&#10;        company_id: str = Depends(get_current_company_id),&#10;        db: Session = Depends(get_db)&#10;) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    company_user = crud_company.get_company_user(db, user_id=current_user.id, company_id=company_id)&#10;&#10;    return company_user&#10;&#10;&#10;async def get_current_active_customer(&#10;    current_customer: Customers = Depends(get_current_customer)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current active customer (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_customer&#10;&#10;&#10;async def get_current_user_role(&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_user),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Get the current user's role in the company.&quot;&quot;&quot;&#10;    company_user = db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == current_user.id,&#10;        CompanyUsers.company_id == company_id&#10;    ).first()&#10;&#10;    if not company_user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;User is not a member of this company&quot;&#10;        )&#10;&#10;    return company_user.role&#10;&#10;&#10;def require_role(allowed_roles: List[CompanyRoleType]):&#10;    &quot;&quot;&quot;&#10;    Dependency factory to check if user has one of the allowed roles.&#10;&#10;    Usage:&#10;        @router.get(&quot;/staff&quot;)&#10;        async def list_staff(&#10;            role: CompanyRoleType = Depends(require_role([CompanyRoleType.owner, CompanyRoleType.admin]))&#10;        ):&#10;            ...&#10;    &quot;&quot;&quot;&#10;    async def role_checker(&#10;        user_role: CompanyRoleType = Depends(get_current_user_role)&#10;    ) -&gt; CompanyRoleType:&#10;        if user_role not in allowed_roles:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                detail=f&quot;Insufficient permissions, contact your administrator&quot;&#10;            )&#10;        return user_role&#10;&#10;    return role_checker&#10;&#10;&#10;async def require_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require owner role.&quot;&quot;&quot;&#10;    if user_role != CompanyRoleType.owner:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_admin_or_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require admin or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners or admins can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_staff_or_higher(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require staff, admin, or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin, CompanyRoleType.staff]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company staff, admins, or owners can access this resource&quot;&#10;        )&#10;    return user_role&#10;" />
              <option name="updatedContent" value="from fastapi import Depends, HTTPException, status, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from app.db.session import get_db&#10;from app.schemas import User&#10;from app.services.auth import get_current_id, verify_token&#10;from app.services.crud import user as crud_user, customer as crud_customer, company as crud_company&#10;from app.models.models import Users, Customers, CompanyUsers&#10;from app.models.enums import CompanyRoleType&#10;&#10;&#10;async def get_current_user(&#10;    request: Request,&#10;    db: Session = Depends(get_db)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current authenticated user from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;    &#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract user ID from token (this will raise HTTPException with specific message if token is expired)&#10;    user_id = get_current_id(access_token)&#10;    if user_id is None:&#10;        raise credentials_exception&#10;&#10;    # Get user from database&#10;    user, company_id = crud_user.get(db, id=user_id)&#10;    if user is None:&#10;        raise credentials_exception&#10;&#10;    user.company_id = company_id&#10;    return user&#10;&#10;&#10;def get_current_customer(&#10;        request: Request,&#10;        db: Session = Depends(get_db)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current authenticated customer from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    try:&#10;        # Extract access token from HTTP-only cookie&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise credentials_exception&#10;&#10;        # Extract customer ID from token&#10;        customer_id = get_current_id(access_token)&#10;        if customer_id is None:&#10;            raise credentials_exception&#10;&#10;    except Exception:&#10;        raise credentials_exception&#10;&#10;    # Get customer from database&#10;    customer = crud_customer.get(db, id=customer_id)&#10;&#10;    if customer is None:&#10;        raise credentials_exception&#10;&#10;    return customer&#10;&#10;&#10;def get_token_payload(&#10;        request: Request&#10;) -&gt; dict:&#10;    &quot;&quot;&quot;Extract and return the payload from the JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract payload from token (this will raise HTTPException with specific message if token is expired)&#10;    payload = verify_token(access_token)&#10;    if payload is None:&#10;        raise credentials_exception&#10;&#10;    return payload&#10;&#10;&#10;def get_current_company_id(token_payload: dict = Depends(get_token_payload)) -&gt; str:&#10;    company_id = token_payload.get(&quot;company_id&quot;)&#10;    if not company_id:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            detail=&quot;Company ID not found in token&quot;&#10;        )&#10;    return company_id&#10;&#10;&#10;async def get_current_active_user(&#10;    current_user: Users = Depends(get_current_user)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_user&#10;&#10;&#10;async def get_current_company_user(&#10;        current_user: Users = Depends(get_current_user),&#10;        company_id: str = Depends(get_current_company_id),&#10;        db: Session = Depends(get_db)&#10;) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    company_user = crud_company.get_company_user(db, user_id=current_user.id, company_id=company_id)&#10;&#10;    return company_user&#10;&#10;&#10;async def get_current_active_customer(&#10;    current_customer: Customers = Depends(get_current_customer)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current active customer (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_customer&#10;&#10;&#10;async def get_current_user_role(&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_user),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Get the current user's role in the company.&quot;&quot;&quot;&#10;    company_user = db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == current_user.id,&#10;        CompanyUsers.company_id == company_id&#10;    ).first()&#10;&#10;    if not company_user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;User is not a member of this company&quot;&#10;        )&#10;&#10;    return company_user.role&#10;&#10;&#10;def require_role(allowed_roles: List[CompanyRoleType]):&#10;    &quot;&quot;&quot;&#10;    Dependency factory to check if user has one of the allowed roles.&#10;&#10;    Usage:&#10;        @router.get(&quot;/staff&quot;)&#10;        async def list_staff(&#10;            role: CompanyRoleType = Depends(require_role([CompanyRoleType.owner, CompanyRoleType.admin]))&#10;        ):&#10;            ...&#10;    &quot;&quot;&quot;&#10;    async def role_checker(&#10;        user_role: CompanyRoleType = Depends(get_current_user_role)&#10;    ) -&gt; CompanyRoleType:&#10;        if user_role not in allowed_roles:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                detail=f&quot;Insufficient permissions, contact your administrator&quot;&#10;            )&#10;        return user_role&#10;&#10;    return role_checker&#10;&#10;&#10;async def require_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require owner role.&quot;&quot;&quot;&#10;    if user_role != CompanyRoleType.owner:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_admin_or_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require admin or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners or admins can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_staff_or_higher(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require staff, admin, or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin, CompanyRoleType.staff]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company staff, admins, or owners can access this resource&quot;&#10;        )&#10;    return user_role" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/models/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/models/models.py" />
              <option name="originalContent" value="import uuid&#10;&#10;from pydantic.v1 import create_model_from_typeddict&#10;from sqlalchemy import (Column, Integer, String, Boolean, DateTime, Text, Date, ForeignKey, UniqueConstraint, UUID,&#10;                        Time,&#10;                        CheckConstraint, false, BLOB, LargeBinary, Index)&#10;from sqlalchemy.dialects.postgresql import ENUM as SQLAlchemyEnum&#10;from sqlalchemy.orm import relationship&#10;from sqlalchemy.sql import func&#10;from sqlalchemy.sql import expression&#10;&#10;from app.db.base_class import BaseModel&#10;from app.models.enums import (StatusType, BookingStatus, CustomerStatusType, EmailStatusType,&#10;                              PhoneStatusType, VerificationType, VerificationStatus,&#10;                              CompanyRoleType, NotificationType, NotificationStatus, MembershipPlanType, InvitationStatus)&#10;&#10;&#10;#&#10;class Users(BaseModel):&#10;    __tablename__ = &quot;users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company_user = relationship(&quot;CompanyUsers&quot;, back_populates=&quot;user&quot;)&#10;    user_time_offs = relationship(&quot;UserTimeOffs&quot;, back_populates=&quot;user&quot;)&#10;&#10;&#10;class UserVerifications(BaseModel):&#10;    __tablename__ = &quot;user_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;&#10;class UserAvailabilities(BaseModel):&#10;    __tablename__ = &quot;user_availabilities&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    day_of_week = Column(Integer, nullable=False)  # 0=Monday, 6=Sunday&#10;    start_time = Column(Time, nullable=False)  # Store only time (HH:MM)&#10;    end_time = Column(Time, nullable=False)    # Store only time (HH:MM)&#10;    is_available = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    __table_args__ = (&#10;        # Add constraint to ensure start_time is before end_time&#10;        CheckConstraint('start_time &lt; end_time', name='check_time_order'),&#10;        # Add unique constraint to prevent overlapping time slots for the same user and day&#10;        UniqueConstraint('user_id', 'day_of_week', 'start_time', 'end_time', name='unique_user_availability')&#10;    )&#10;&#10;&#10;class UserTimeOffs(BaseModel):&#10;    __tablename__ = &quot;user_time_offs&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    start_date = Column(DateTime, nullable=False)&#10;    end_date = Column(DateTime, nullable=False)&#10;    reason = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;user_time_offs&quot;)&#10;&#10;&#10;class Companies(BaseModel):&#10;    __tablename__ = &quot;companies&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(255), nullable=False)&#10;    type = Column(String(255), nullable=False)&#10;    logo_url = Column(String(255))&#10;    website = Column(String(255))&#10;    description = Column(Text)&#10;    team_size = Column(Integer, default=1)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    invitations = relationship(&quot;Invitations&quot;, back_populates=&quot;company&quot;)&#10;&#10;&#10;class CompanyEmails(BaseModel):&#10;    __tablename__ = &quot;company_emails&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CompanyPhones(BaseModel):&#10;    __tablename__ = &quot;company_phones&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CompanyAddresses(BaseModel):&#10;    __tablename__ = &quot;company_addresses&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address = Column(String(255), nullable=False)&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;&#10;class CompanyUsers(BaseModel):&#10;    __tablename__ = &quot;company_users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)  # e.g., admin, member&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.inactive)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;company_user&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('user_id', 'company_id', name='_user_company_uc'),)&#10;&#10;&#10;class Customers(BaseModel):&#10;    __tablename__ = &quot;customers&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;customer&quot;)&#10;&#10;class CustomerEmails(BaseModel):&#10;    __tablename__ = &quot;customer_emails&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerPhones(BaseModel):&#10;    __tablename__ = &quot;customer_phones&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerAddresses(BaseModel):&#10;    __tablename__ = &quot;customer_addresses&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address_line1 = Column(String(255), nullable=False)&#10;    address_line2 = Column(String(255))&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerVerifications(BaseModel):&#10;    __tablename__ = &quot;customer_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;class Bookings(BaseModel):&#10;    __tablename__ = &quot;bookings&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    status = Column(SQLAlchemyEnum(BookingStatus), default=BookingStatus.SCHEDULED)&#10;    start_at = Column(DateTime, nullable=False)&#10;    end_at = Column(DateTime, nullable=False)&#10;    total_price = Column(Integer, nullable=False)&#10;    notes = Column(Text)&#10;&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    customer = relationship(&quot;Customers&quot;, back_populates=&quot;booking&quot;)&#10;    booking_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;booking&quot;)&#10;&#10;&#10;class CompanyCategories(BaseModel):&#10;    __tablename__ = &quot;company_categories&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(100), nullable=False)&#10;    description = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;company_category&quot;)&#10;&#10;&#10;class CategoryServices(BaseModel):&#10;    __tablename__ = &quot;category_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    category_id = Column(UUID, ForeignKey(&quot;company_categories.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(255))&#10;    duration = Column(Integer)&#10;    price = Column(Integer)&#10;    discount_price = Column(Integer)&#10;    additional_info = Column(Text)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    buffer_before = Column(Integer, default=0)  # in minutes&#10;    buffer_after = Column(Integer, default=0)   # in minutes&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company_category = relationship(&quot;CompanyCategories&quot;, back_populates=&quot;category_service&quot;)&#10;    booking_category_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;category_service&quot;)&#10;&#10;&#10;class BookingServices(BaseModel):&#10;    __tablename__ = &quot;booking_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    booking_id = Column(UUID, ForeignKey(&quot;bookings.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    category_service_id = Column(UUID, ForeignKey(&quot;category_services.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;SET NULL&quot;))&#10;    notes = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;    start_at = Column(DateTime, nullable=True)&#10;    end_at = Column(DateTime, nullable=True)&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;booking_services&quot;)&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;booking_category_services&quot;)&#10;&#10;&#10;&#10;class CompanyNotifications(BaseModel):&#10;    __tablename__ = &quot;company_notifications&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    type = Column(SQLAlchemyEnum(NotificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(NotificationStatus), default=NotificationStatus.UNREAD)&#10;    message = Column(Text, nullable=False)&#10;    data = Column(LargeBinary, nullable=True)  # JSON or additional data&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;&#10;class MembershipPlans(BaseModel):&#10;    __tablename__ = &quot;membership_plans&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(100), nullable=False, unique=True)&#10;    plan_type = Column(SQLAlchemyEnum(MembershipPlanType), nullable=False, unique=True)&#10;    description = Column(Text)&#10;    url = Column(Text)&#10;    price = Column(Integer, nullable=False)  # Price in cents&#10;    duration_days = Column(Integer, nullable=False, default=30)  # Subscription duration&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    subscriptions = relationship(&quot;CompanyMemberships&quot;, back_populates=&quot;membership_plan&quot;)&#10;&#10;&#10;class CompanyMemberships(BaseModel):&#10;    __tablename__ = &quot;company_memberships&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    membership_plan_id = Column(UUID, ForeignKey(&quot;membership_plans.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    start_date = Column(DateTime, nullable=False, default=func.now())&#10;    end_date = Column(DateTime, nullable=False)&#10;    auto_renew = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    membership_plan = relationship(&quot;MembershipPlans&quot;, back_populates=&quot;subscriptions&quot;)&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active membership at a time&#10;        Index(&#10;            'unique_active_company_membership',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class TelegramIntegrations(BaseModel):&#10;    __tablename__ = &quot;telegram_integrations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    bot_token_encrypted = Column(String(255), nullable=False)&#10;    chat_id = Column(String(255), nullable=True)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active telegram integration&#10;        Index(&#10;            'unique_active_telegram_integration',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class Invitations(BaseModel):&#10;    __tablename__ = &quot;invitations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    email = Column(String(255), nullable=False)&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)&#10;    status = Column(SQLAlchemyEnum(InvitationStatus), default=InvitationStatus.PENDING)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company = relationship(&quot;Companies&quot;, back_populates=&quot;invitations&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('email', 'company_id', name='_email_company_uc'),)" />
              <option name="updatedContent" value="import uuid&#10;&#10;from pydantic.v1 import create_model_from_typeddict&#10;from sqlalchemy import (Column, Integer, String, Boolean, DateTime, Text, Date, ForeignKey, UniqueConstraint, UUID,&#10;                        Time,&#10;                        CheckConstraint, false, BLOB, LargeBinary, Index)&#10;from sqlalchemy.dialects.postgresql import ENUM as SQLAlchemyEnum&#10;from sqlalchemy.orm import relationship&#10;from sqlalchemy.sql import func&#10;from sqlalchemy.sql import expression&#10;&#10;from app.db.base_class import BaseModel&#10;from app.models.enums import (StatusType, BookingStatus, CustomerStatusType, EmailStatusType,&#10;                              PhoneStatusType, VerificationType, VerificationStatus,&#10;                              CompanyRoleType, NotificationType, NotificationStatus, MembershipPlanType, InvitationStatus)&#10;&#10;&#10;#&#10;class Users(BaseModel):&#10;    __tablename__ = &quot;users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company_user = relationship(&quot;CompanyUsers&quot;, back_populates=&quot;user&quot;)&#10;    user_time_offs = relationship(&quot;UserTimeOffs&quot;, back_populates=&quot;user&quot;)&#10;&#10;&#10;class UserVerifications(BaseModel):&#10;    __tablename__ = &quot;user_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;&#10;class UserAvailabilities(BaseModel):&#10;    __tablename__ = &quot;user_availabilities&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    day_of_week = Column(Integer, nullable=False)  # 0=Monday, 6=Sunday&#10;    start_time = Column(Time, nullable=False)  # Store only time (HH:MM)&#10;    end_time = Column(Time, nullable=False)    # Store only time (HH:MM)&#10;    is_available = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    __table_args__ = (&#10;        # Add constraint to ensure start_time is before end_time&#10;        CheckConstraint('start_time &lt; end_time', name='check_time_order'),&#10;        # Add unique constraint to prevent overlapping time slots for the same user and day&#10;        UniqueConstraint('user_id', 'day_of_week', 'start_time', 'end_time', name='unique_user_availability')&#10;    )&#10;&#10;&#10;class UserTimeOffs(BaseModel):&#10;    __tablename__ = &quot;user_time_offs&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    start_date = Column(DateTime, nullable=False)&#10;    end_date = Column(DateTime, nullable=False)&#10;    reason = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;user_time_offs&quot;)&#10;&#10;&#10;class Companies(BaseModel):&#10;    __tablename__ = &quot;companies&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(255), nullable=False)&#10;    type = Column(String(255), nullable=False)&#10;    logo_url = Column(String(255))&#10;    website = Column(String(255))&#10;    description = Column(Text)&#10;    team_size = Column(Integer, default=1)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    invitations = relationship(&quot;Invitations&quot;, back_populates=&quot;company&quot;)&#10;&#10;&#10;class CompanyEmails(BaseModel):&#10;    __tablename__ = &quot;company_emails&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CompanyPhones(BaseModel):&#10;    __tablename__ = &quot;company_phones&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CompanyAddresses(BaseModel):&#10;    __tablename__ = &quot;company_addresses&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address = Column(String(255), nullable=False)&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;&#10;class CompanyUsers(BaseModel):&#10;    __tablename__ = &quot;company_users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)  # e.g., admin, member&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.inactive)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;company_user&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('user_id', 'company_id', name='_user_company_uc'),)&#10;&#10;&#10;class Customers(BaseModel):&#10;    __tablename__ = &quot;customers&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;customer&quot;)&#10;&#10;class CustomerEmails(BaseModel):&#10;    __tablename__ = &quot;customer_emails&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerPhones(BaseModel):&#10;    __tablename__ = &quot;customer_phones&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerAddresses(BaseModel):&#10;    __tablename__ = &quot;customer_addresses&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address_line1 = Column(String(255), nullable=False)&#10;    address_line2 = Column(String(255))&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerVerifications(BaseModel):&#10;    __tablename__ = &quot;customer_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;class Bookings(BaseModel):&#10;    __tablename__ = &quot;bookings&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    status = Column(SQLAlchemyEnum(BookingStatus), default=BookingStatus.SCHEDULED)&#10;    start_at = Column(DateTime, nullable=False)&#10;    end_at = Column(DateTime, nullable=False)&#10;    total_price = Column(Integer, nullable=False)&#10;    notes = Column(Text)&#10;&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    customer = relationship(&quot;Customers&quot;, back_populates=&quot;booking&quot;)&#10;    booking_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;booking&quot;)&#10;&#10;&#10;class CompanyCategories(BaseModel):&#10;    __tablename__ = &quot;company_categories&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(100), nullable=False)&#10;    description = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;company_category&quot;)&#10;&#10;&#10;class CategoryServices(BaseModel):&#10;    __tablename__ = &quot;category_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    category_id = Column(UUID, ForeignKey(&quot;company_categories.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(255))&#10;    duration = Column(Integer)&#10;    price = Column(Integer)&#10;    discount_price = Column(Integer)&#10;    additional_info = Column(Text)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    buffer_before = Column(Integer, default=0)  # in minutes&#10;    buffer_after = Column(Integer, default=0)   # in minutes&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company_category = relationship(&quot;CompanyCategories&quot;, back_populates=&quot;category_service&quot;)&#10;    booking_category_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;category_service&quot;)&#10;&#10;&#10;class BookingServices(BaseModel):&#10;    __tablename__ = &quot;booking_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    booking_id = Column(UUID, ForeignKey(&quot;bookings.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    category_service_id = Column(UUID, ForeignKey(&quot;category_services.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;SET NULL&quot;))&#10;    notes = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;    start_at = Column(DateTime, nullable=True)&#10;    end_at = Column(DateTime, nullable=True)&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;booking_services&quot;)&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;booking_category_services&quot;)&#10;&#10;&#10;&#10;class CompanyNotifications(BaseModel):&#10;    __tablename__ = &quot;company_notifications&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    type = Column(SQLAlchemyEnum(NotificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(NotificationStatus), default=NotificationStatus.UNREAD)&#10;    message = Column(Text, nullable=False)&#10;    data = Column(LargeBinary, nullable=True)  # JSON or additional data&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;&#10;class MembershipPlans(BaseModel):&#10;    __tablename__ = &quot;membership_plans&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(100), nullable=False, unique=True)&#10;    plan_type = Column(SQLAlchemyEnum(MembershipPlanType), nullable=False, unique=True)&#10;    description = Column(Text)&#10;    url = Column(Text)&#10;    price = Column(Integer, nullable=False)  # Price in cents&#10;    duration_days = Column(Integer, nullable=False, default=30)  # Subscription duration&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    subscriptions = relationship(&quot;CompanyMemberships&quot;, back_populates=&quot;membership_plan&quot;)&#10;&#10;&#10;class CompanyMemberships(BaseModel):&#10;    __tablename__ = &quot;company_memberships&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    membership_plan_id = Column(UUID, ForeignKey(&quot;membership_plans.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    start_date = Column(DateTime, nullable=False, default=func.now())&#10;    end_date = Column(DateTime, nullable=False)&#10;    auto_renew = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    membership_plan = relationship(&quot;MembershipPlans&quot;, back_populates=&quot;subscriptions&quot;)&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active membership at a time&#10;        Index(&#10;            'unique_active_company_membership',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class TelegramIntegrations(BaseModel):&#10;    __tablename__ = &quot;telegram_integrations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    bot_token_encrypted = Column(String(255), nullable=False)&#10;    chat_id = Column(String(255), nullable=True)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active telegram integration&#10;        Index(&#10;            'unique_active_telegram_integration',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class Invitations(BaseModel):&#10;    __tablename__ = &quot;invitations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    email = Column(String(255), nullable=False)&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)&#10;    status = Column(SQLAlchemyEnum(InvitationStatus), default=InvitationStatus.PENDING)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company = relationship(&quot;Companies&quot;, back_populates=&quot;invitations&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('email', 'company_id', name='_email_company_uc'),)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/auth.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/auth.py" />
              <option name="originalContent" value="from datetime import datetime, timedelta&#10;from typing import Optional, Dict, Any&#10;from jose import JWTError, jwt&#10;from jose.exceptions import ExpiredSignatureError&#10;from passlib.context import CryptContext&#10;from fastapi import HTTPException, status&#10;from app.core.config import settings&#10;import datetime as dt_obj&#10;&#10;# Configuration&#10;SECRET_KEY = settings.SECRET_KEY&#10;ALGORITHM = &quot;HS256&quot;&#10;ACCESS_TOKEN_EXPIRE_MINUTES = 0.3  # 30 minutes&#10;REFRESH_TOKEN_EXPIRE_DAYS = 7  # 1 week&#10;&#10;pwd_context = CryptContext(&#10;    schemes=[&quot;bcrypt&quot;],&#10;    deprecated=&quot;auto&quot;,&#10;    bcrypt__rounds=12&#10;)&#10;&#10;&#10;def hash_password(password: str) -&gt; str:&#10;    &quot;&quot;&quot;Hash a password using bcrypt.&quot;&quot;&quot;&#10;    return pwd_context.hash(password)&#10;&#10;&#10;def verify_password(plain_password: str, hashed_password: str) -&gt; bool:&#10;    &quot;&quot;&quot;Verify a password against its hash.&quot;&quot;&quot;&#10;    return pwd_context.verify(plain_password, hashed_password)&#10;&#10;&#10;def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -&gt; str:&#10;    &quot;&quot;&quot;Create a JWT access token.&quot;&quot;&quot;&#10;    to_encode = data.copy()&#10;    &#10;    if expires_delta:&#10;        expire = datetime.now(dt_obj.UTC) + expires_delta&#10;    else:&#10;        expire = datetime.now(dt_obj.UTC) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)&#10;&#10;    to_encode.update({&quot;exp&quot;: expire, &quot;type&quot;: &quot;access&quot;})&#10;    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)&#10;    return encoded_jwt&#10;&#10;&#10;def create_refresh_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -&gt; str:&#10;    &quot;&quot;&quot;Create a JWT refresh token.&quot;&quot;&quot;&#10;    to_encode = data.copy()&#10;    &#10;    if expires_delta:&#10;        expire = datetime.now(dt_obj.UTC) + expires_delta&#10;    else:&#10;        expire = datetime.now(dt_obj.UTC) + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)&#10;&#10;    to_encode.update({&quot;exp&quot;: expire, &quot;type&quot;: &quot;refresh&quot;})&#10;    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)&#10;    return encoded_jwt&#10;&#10;&#10;def create_token_pair(id: str, email: str, actor: str, ver: str = '1', company_id: Optional[str] = None) -&gt; Dict:&#10;    &quot;&quot;&quot;Create both access and refresh tokens.&quot;&quot;&quot;&#10;    data = {&quot;sub&quot;: str(id), &quot;email&quot;: email, &quot;actor&quot;: actor, &quot;ver&quot;: ver, 'company_id': company_id}&#10;    access_token = create_access_token(data)&#10;    &#10;    # For testing: Create refresh token with 30 seconds expiration&#10;    refresh_token = create_refresh_token(data, expires_delta=timedelta(seconds=30))&#10;    &#10;    return {&#10;        &quot;access_token&quot;: access_token,&#10;        &quot;refresh_token&quot;: refresh_token,&#10;        &quot;token_type&quot;: &quot;bearer&quot;,&#10;        &quot;at_expires_in&quot;: int(ACCESS_TOKEN_EXPIRE_MINUTES * 60), # seconds&#10;        &quot;rt_expires_in&quot;: 30  # seconds (for testing)&#10;    }&#10;&#10;&#10;def verify_token(token: str, token_type: str = &quot;access&quot;) -&gt; Optional[Dict[str, Any]]:&#10;    &quot;&quot;&quot;Verify and decode a JWT token.&quot;&quot;&quot;&#10;    try:&#10;        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])&#10;        &#10;        # Check token type&#10;        if payload.get(&quot;type&quot;) != token_type:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid token type&quot;,&#10;                headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;            )&#10;&#10;        # Check expiration&#10;        exp = payload.get(&quot;exp&quot;)&#10;        if exp is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Token missing expiration&quot;,&#10;                headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;            )&#10;&#10;        if datetime.fromtimestamp(exp, dt_obj.UTC) &lt; datetime.now(dt_obj.UTC):&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Access token has expired. Please refresh your token or login again.&quot;,&#10;                headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;            )&#10;&#10;        return payload&#10;&#10;    except ExpiredSignatureError:&#10;        # Handle expired token specifically&#10;        print(&quot;Token has expired&quot;)&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Access token has expired&quot;,&#10;            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;        )&#10;    except JWTError as ex:&#10;        # Handle all other JWT errors (invalid signature, malformed token, etc.)&#10;        print(f&quot;Token verification error: {ex}&quot;)&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Could not validate credentials&quot;,&#10;            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;        )&#10;&#10;&#10;def get_current_id(token: str):&#10;    &quot;&quot;&quot;Extract user ID from access token.&quot;&quot;&quot;&#10;    payload = verify_token(token, &quot;access&quot;)&#10;    if payload is None:&#10;        return None&#10;&#10;    user_id = payload.get(&quot;sub&quot;)&#10;    if user_id is None:&#10;        return None&#10;        &#10;    try:&#10;        return user_id&#10;    except (ValueError, TypeError):&#10;        return None&#10;&#10;&#10;def refresh_access_token(refresh_token: str) -&gt; Optional[Dict[str, str]]:&#10;    &quot;&quot;&quot;Create a new access token using a refresh token.&quot;&quot;&quot;&#10;    payload = verify_token(refresh_token, &quot;refresh&quot;)&#10;    if payload is None:&#10;        return None&#10;        &#10;    id = payload.get(&quot;sub&quot;)&#10;    email = payload.get(&quot;email&quot;)&#10;    actor = payload.get(&quot;actor&quot;)&#10;    ver = payload.get(&quot;ver&quot;)&#10;&#10;    if not id or not email:&#10;        return None&#10;        &#10;    try:&#10;        data = {&quot;sub&quot;: id, &quot;email&quot;: email, &quot;actor&quot;: actor, &quot;ver&quot;: ver}&#10;        access_token = create_access_token(data)&#10;        return {&#10;            &quot;access_token&quot;: access_token,&#10;            'refresh_token': refresh_token,&#10;            &quot;token_type&quot;: &quot;bearer&quot;,&#10;            &quot;expires_in&quot;: ACCESS_TOKEN_EXPIRE_MINUTES * 60  # seconds&#10;        }&#10;    except (ValueError, TypeError):&#10;        return None&#10;" />
              <option name="updatedContent" value="from datetime import datetime, timedelta&#10;from typing import Optional, Dict, Any&#10;from jose import JWTError, jwt&#10;from jose.exceptions import ExpiredSignatureError&#10;from passlib.context import CryptContext&#10;from fastapi import HTTPException, status&#10;from app.core.config import settings&#10;import datetime as dt_obj&#10;&#10;# Configuration&#10;SECRET_KEY = settings.SECRET_KEY&#10;ALGORITHM = &quot;HS256&quot;&#10;ACCESS_TOKEN_EXPIRE_MINUTES = 0.3  # 30 minutes&#10;REFRESH_TOKEN_EXPIRE_DAYS = 7  # 1 week&#10;&#10;pwd_context = CryptContext(&#10;    schemes=[&quot;bcrypt&quot;],&#10;    deprecated=&quot;auto&quot;,&#10;    bcrypt__rounds=12&#10;)&#10;&#10;&#10;def hash_password(password: str) -&gt; str:&#10;    &quot;&quot;&quot;Hash a password using bcrypt.&quot;&quot;&quot;&#10;    return pwd_context.hash(password)&#10;&#10;&#10;def verify_password(plain_password: str, hashed_password: str) -&gt; bool:&#10;    &quot;&quot;&quot;Verify a password against its hash.&quot;&quot;&quot;&#10;    return pwd_context.verify(plain_password, hashed_password)&#10;&#10;&#10;def create_access_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -&gt; str:&#10;    &quot;&quot;&quot;Create a JWT access token.&quot;&quot;&quot;&#10;    to_encode = data.copy()&#10;    &#10;    if expires_delta:&#10;        expire = datetime.now(dt_obj.UTC) + expires_delta&#10;    else:&#10;        expire = datetime.now(dt_obj.UTC) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)&#10;&#10;    to_encode.update({&quot;exp&quot;: expire, &quot;type&quot;: &quot;access&quot;})&#10;    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)&#10;    return encoded_jwt&#10;&#10;&#10;def create_refresh_token(data: Dict[str, Any], expires_delta: Optional[timedelta] = None) -&gt; str:&#10;    &quot;&quot;&quot;Create a JWT refresh token.&quot;&quot;&quot;&#10;    to_encode = data.copy()&#10;    &#10;    if expires_delta:&#10;        expire = datetime.now(dt_obj.UTC) + expires_delta&#10;    else:&#10;        expire = datetime.now(dt_obj.UTC) + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)&#10;&#10;    to_encode.update({&quot;exp&quot;: expire, &quot;type&quot;: &quot;refresh&quot;})&#10;    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)&#10;    return encoded_jwt&#10;&#10;&#10;def create_token_pair(id: str, email: str, actor: str, ver: str = '1', company_id: Optional[str] = None) -&gt; Dict:&#10;    &quot;&quot;&quot;Create both access and refresh tokens.&quot;&quot;&quot;&#10;    data = {&quot;sub&quot;: str(id), &quot;email&quot;: email, &quot;actor&quot;: actor, &quot;ver&quot;: ver, 'company_id': company_id}&#10;    access_token = create_access_token(data)&#10;    &#10;    # For testing: Create refresh token with 30 seconds expiration&#10;    refresh_token = create_refresh_token(data, expires_delta=timedelta(seconds=30))&#10;    &#10;    return {&#10;        &quot;access_token&quot;: access_token,&#10;        &quot;refresh_token&quot;: refresh_token,&#10;        &quot;token_type&quot;: &quot;bearer&quot;,&#10;        &quot;at_expires_in&quot;: int(ACCESS_TOKEN_EXPIRE_MINUTES * 60), # seconds&#10;        &quot;rt_expires_in&quot;: 30  # seconds (for testing)&#10;    }&#10;&#10;&#10;def verify_token(token: str, token_type: str = &quot;access&quot;) -&gt; Optional[Dict[str, Any]]:&#10;    &quot;&quot;&quot;Verify and decode a JWT token.&quot;&quot;&quot;&#10;    try:&#10;        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])&#10;        &#10;        # Check token type&#10;        if payload.get(&quot;type&quot;) != token_type:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid token type&quot;,&#10;                headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;            )&#10;&#10;        # Check expiration&#10;        exp = payload.get(&quot;exp&quot;)&#10;        if exp is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Token missing expiration&quot;,&#10;                headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;            )&#10;&#10;        if datetime.fromtimestamp(exp, dt_obj.UTC) &lt; datetime.now(dt_obj.UTC):&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Access token has expired. Please refresh your token or login again.&quot;,&#10;                headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;            )&#10;&#10;        return payload&#10;&#10;    except ExpiredSignatureError:&#10;        # Handle expired token specifically&#10;        print(&quot;Token has expired&quot;)&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Access token has expired&quot;,&#10;            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;        )&#10;    except JWTError as ex:&#10;        # Handle all other JWT errors (invalid signature, malformed token, etc.)&#10;        print(f&quot;Token verification error: {ex}&quot;)&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Could not validate credentials&quot;,&#10;            headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;        )&#10;&#10;&#10;def get_current_id(token: str):&#10;    &quot;&quot;&quot;Extract user ID from access token.&quot;&quot;&quot;&#10;    payload = verify_token(token, &quot;access&quot;)&#10;    if payload is None:&#10;        return None&#10;&#10;    user_id = payload.get(&quot;sub&quot;)&#10;    if user_id is None:&#10;        return None&#10;        &#10;    try:&#10;        return user_id&#10;    except (ValueError, TypeError):&#10;        return None&#10;&#10;&#10;def refresh_access_token(refresh_token: str) -&gt; Optional[Dict[str, str]]:&#10;    &quot;&quot;&quot;Create a new access token using a refresh token.&quot;&quot;&quot;&#10;    payload = verify_token(refresh_token, &quot;refresh&quot;)&#10;    if payload is None:&#10;        return None&#10;        &#10;    id = payload.get(&quot;sub&quot;)&#10;    email = payload.get(&quot;email&quot;)&#10;    actor = payload.get(&quot;actor&quot;)&#10;    ver = payload.get(&quot;ver&quot;)&#10;&#10;    if not id or not email:&#10;        return None&#10;        &#10;    try:&#10;        data = {&quot;sub&quot;: id, &quot;email&quot;: email, &quot;actor&quot;: actor, &quot;ver&quot;: ver}&#10;        access_token = create_access_token(data)&#10;        return {&#10;            &quot;access_token&quot;: access_token,&#10;            'refresh_token': refresh_token,&#10;            &quot;token_type&quot;: &quot;bearer&quot;,&#10;            &quot;expires_in&quot;: ACCESS_TOKEN_EXPIRE_MINUTES * 60  # seconds&#10;        }&#10;    except (ValueError, TypeError):&#10;        return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/company.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/company.py" />
              <option name="originalContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import date&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyRoleType, StatusType, UserAvailabilities, UserTimeOffs, CategoryServices, \&#10;    CompanyCategories, CompanyEmails, CompanyPhones, Users&#10;from app.models.models import CompanyUsers, Companies&#10;from app.schemas import CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, UserCreate, CompanyUser&#10;from app.schemas.schemas import (&#10;    CompanyCreate,&#10;    User&#10;)&#10;from app.services.auth import hash_password&#10;&#10;&#10;def get(db: Session, id: str) -&gt; Optional[Companies]:&#10;    return db.query(Companies).filter(Companies.id == id).first()&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUsers]:&#10;    &quot;&quot;&quot;Get all users belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyUsers).filter(CompanyUsers.company_id == company_id).all())&#10;&#10;&#10;def get_company_user(db: Session, company_id: str, user_id: str) -&gt; Optional[CompanyUser]:&#10;    &quot;&quot;&quot;Get company user with user details.&quot;&quot;&quot;&#10;    company_user = (db.query(CompanyUsers)&#10;                    .join(Users, Users.id == CompanyUsers.user_id)&#10;                    .filter(CompanyUsers.company_id == company_id, CompanyUsers.user_id == user_id)&#10;                    .first())&#10;    &#10;    if not company_user:&#10;        return None&#10;    &#10;    # Convert SQLAlchemy model to Pydantic schema&#10;    return CompanyUser.model_validate(company_user)&#10;&#10;&#10;def get_company_services(db: Session, company_id: str) -&gt; List[CompanyCategories]:&#10;    &quot;&quot;&quot;Get all services belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyCategories).join(CategoryServices, CategoryServices.category_id==CompanyCategories.id)&#10;                .filter(CompanyCategories.company_id == company_id).all())&#10;&#10;&#10;def get_company_all_users_availabilities(db: Session, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_user_availabilities(db: Session, user_id: str, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_all_users_time_offs(db: Session, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def get_company_user_time_offs(db: Session, user_id: str, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def create(db: Session, *, obj_in: CompanyCreate, current_user: User) -&gt; Companies:&#10;&#10;    db_obj = Companies(**obj_in.model_dump())&#10;    # db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    cmp_usr_obj = CompanyUsers(user_id=current_user.id,&#10;                               company_id=db_obj.id,&#10;                               role=CompanyRoleType.admin,&#10;                               status=StatusType.active)&#10;    db.add(cmp_usr_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Companies, obj_in: dict) -&gt; Companies:&#10;    &quot;&quot;&quot;&#10;    Update company information&#10;&#10;    Args:&#10;        db: Database session&#10;        db_obj: Existing company object to update&#10;        obj_in: Data to update the company with&#10;&#10;    Returns:&#10;        Updated company object&#10;    &quot;&quot;&quot;&#10;    for field, value in obj_in.items():&#10;        if value is not None:&#10;            setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def create_company_email(db: Session, *, obj_in: CompanyEmailCreate):&#10;    &quot;&quot;&quot;&#10;    Create new emails for a company, handling duplicate emails&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company emails to add&#10;&#10;    Returns:&#10;        List of created/updated email objects&#10;    &quot;&quot;&quot;&#10;    # Get existing emails for this company to check duplicates&#10;    existing_emails = db.query(CompanyEmails).filter(&#10;        CompanyEmails.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing email addresses for efficient lookup&#10;    existing_email_set = {str(email.email).lower() for email in existing_emails}&#10;&#10;    for email in obj_in.emails:&#10;        # Check if this email already exists for this company&#10;        if str(email.email).lower() in existing_email_set:&#10;            # Skip this email as it already exists&#10;            continue&#10;&#10;        # Create new email record&#10;        db_obj = CompanyEmails(&#10;            company_id=obj_in.company_id,&#10;            email=str(email.email).lower(),&#10;            status=email.status.lower()&#10;        )&#10;        db_obj.id = str(uuid.uuid4())&#10;        db.add(db_obj)&#10;&#10;    # Commit all new emails at once&#10;    db.commit()&#10;&#10;&#10;def get_company_emails(db: Session, company_id: str) -&gt; List[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get all emails for a specific company&#10;    &quot;&quot;&quot;&#10;    company_emails = db.query(CompanyEmails).filter(CompanyEmails.company_id == company_id).all()&#10;&#10;    return company_emails&#10;&#10;&#10;&#10;def get_company_email(db: Session, email_id: str) -&gt; Optional[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company email by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyEmails).filter(CompanyEmails.id == email_id).first()&#10;&#10;&#10;def delete_company_email(db: Session, email_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company email&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyEmails).filter(&#10;        CompanyEmails.id == email_id,&#10;        CompanyEmails.company_id == company_id&#10;    ).first()&#10;&#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_phone(db: Session, *, obj_in: CompanyPhoneCreate) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Create new phone numbers for a company, handling duplicate phone numbers&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company phone numbers to add&#10;&#10;    Returns:&#10;        List of created phone number objects&#10;    &quot;&quot;&quot;&#10;    # Get existing phone numbers for this company to check duplicates&#10;    existing_phones = db.query(CompanyPhones).filter(&#10;        CompanyPhones.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing phone numbers for efficient lookup&#10;    existing_phone_set = {phone.phone for phone in existing_phones}&#10;&#10;    created_phones = []&#10;    for phone_data in obj_in.company_phones:&#10;        # Check if this phone number already exists for this company&#10;        if phone_data.phone in existing_phone_set:&#10;            # Skip this phone number as it already exists&#10;            continue&#10;&#10;        # Create new phone number record&#10;        db_obj = CompanyPhones(&#10;            company_id=obj_in.company_id,&#10;            phone=phone_data.phone,&#10;            is_primary=phone_data.is_primary,&#10;            status=phone_data.status&#10;        )&#10;        # db_obj.id = str(uuid.uuid4())&#10;        &#10;        db.add(db_obj)&#10;        created_phones.append(db_obj)&#10;        &#10;    # Commit all new phone numbers at once&#10;    db.commit()&#10;&#10;    # Refresh all newly created objects&#10;    for phone in created_phones:&#10;        db.refresh(phone)&#10;&#10;    return created_phones&#10;&#10;&#10;def get_company_phones(db: Session, company_id: str) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers for a specific company&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.company_id == company_id).all()&#10;&#10;&#10;def get_company_phone(db: Session, phone_id: str) -&gt; Optional[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company phone by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.id == phone_id).first()&#10;&#10;&#10;def delete_company_phone(db: Session, phone_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company phone number&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyPhones).filter(&#10;        CompanyPhones.id == phone_id,&#10;        CompanyPhones.company_id == company_id&#10;    ).first()&#10;    &#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_member(db: Session, *, user_in: UserCreate, company_id: str, role: CompanyRoleType) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to a company with the specified role.&#10;&#10;    Args:&#10;        db: Database session&#10;        user_in: User creation data&#10;        company_id: Company ID to add the user to&#10;        role: Role to assign to the user in the company&#10;&#10;    Returns:&#10;        CompanyUsers object with the user relationship&#10;    &quot;&quot;&quot;&#10;    # Check if user with this email already exists&#10;    existing_user = db.query(Users).filter(Users.email == user_in.email).first()&#10;&#10;    if existing_user:&#10;        # Check if user is already part of this company&#10;        existing_company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == company_id&#10;        ).first()&#10;&#10;        if existing_company_user:&#10;            raise ValueError(&quot;User is already a member of this company&quot;)&#10;&#10;        # Add existing user to the company&#10;        company_user = CompanyUsers(&#10;            user_id=existing_user.id,&#10;            company_id=company_id,&#10;            role=role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;        db.commit()&#10;        db.refresh(company_user)&#10;        return company_user&#10;&#10;    # Create new user&#10;    user_data = user_in.model_dump()&#10;    user_data['password'] = hash_password(user_data['password'])&#10;&#10;    new_user = Users(**user_data)&#10;    new_user.id = str(uuid.uuid4())&#10;    new_user.status = StatusType.active&#10;&#10;    db.add(new_user)&#10;    db.commit()&#10;    db.refresh(new_user)&#10;&#10;    # Add user to company&#10;    company_user = CompanyUsers(&#10;        user_id=new_user.id,&#10;        company_id=company_id,&#10;        role=role,&#10;        status=StatusType.active&#10;    )&#10;    db.add(company_user)&#10;    db.commit()&#10;    db.refresh(company_user)&#10;&#10;    return company_user&#10;" />
              <option name="updatedContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import date&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyRoleType, StatusType, UserAvailabilities, UserTimeOffs, CategoryServices, \&#10;    CompanyCategories, CompanyEmails, CompanyPhones, Users&#10;from app.models.models import CompanyUsers, Companies&#10;from app.schemas import CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, UserCreate, CompanyUser&#10;from app.schemas.schemas import (&#10;    CompanyCreate,&#10;    User&#10;)&#10;from app.services.auth import hash_password&#10;&#10;&#10;def get(db: Session, id: str) -&gt; Optional[Companies]:&#10;    return db.query(Companies).filter(Companies.id == id).first()&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUsers]:&#10;    &quot;&quot;&quot;Get all users belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyUsers).filter(CompanyUsers.company_id == company_id).all())&#10;&#10;&#10;def get_company_user(db: Session, company_id: str, user_id: str) -&gt; Optional[CompanyUser]:&#10;    &quot;&quot;&quot;Get company user with user details.&quot;&quot;&quot;&#10;    company_user = (db.query(CompanyUsers)&#10;                    .join(Users, Users.id == CompanyUsers.user_id)&#10;                    .filter(CompanyUsers.company_id == company_id, CompanyUsers.user_id == user_id)&#10;                    .first())&#10;    &#10;    if not company_user:&#10;        return None&#10;    &#10;    # Convert SQLAlchemy model to Pydantic schema&#10;    return CompanyUser.model_validate(company_user)&#10;&#10;&#10;def get_company_services(db: Session, company_id: str) -&gt; List[CompanyCategories]:&#10;    &quot;&quot;&quot;Get all services belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyCategories).join(CategoryServices, CategoryServices.category_id==CompanyCategories.id)&#10;                .filter(CompanyCategories.company_id == company_id).all())&#10;&#10;&#10;def get_company_all_users_availabilities(db: Session, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_user_availabilities(db: Session, user_id: str, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_all_users_time_offs(db: Session, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def get_company_user_time_offs(db: Session, user_id: str, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def create(db: Session, *, obj_in: CompanyCreate, current_user: User) -&gt; Companies:&#10;&#10;    db_obj = Companies(**obj_in.model_dump())&#10;    # db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    cmp_usr_obj = CompanyUsers(user_id=current_user.id,&#10;                               company_id=db_obj.id,&#10;                               role=CompanyRoleType.admin,&#10;                               status=StatusType.active)&#10;    db.add(cmp_usr_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Companies, obj_in: dict) -&gt; Companies:&#10;    &quot;&quot;&quot;&#10;    Update company information&#10;&#10;    Args:&#10;        db: Database session&#10;        db_obj: Existing company object to update&#10;        obj_in: Data to update the company with&#10;&#10;    Returns:&#10;        Updated company object&#10;    &quot;&quot;&quot;&#10;    for field, value in obj_in.items():&#10;        if value is not None:&#10;            setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def create_company_email(db: Session, *, obj_in: CompanyEmailCreate):&#10;    &quot;&quot;&quot;&#10;    Create new emails for a company, handling duplicate emails&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company emails to add&#10;&#10;    Returns:&#10;        List of created/updated email objects&#10;    &quot;&quot;&quot;&#10;    # Get existing emails for this company to check duplicates&#10;    existing_emails = db.query(CompanyEmails).filter(&#10;        CompanyEmails.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing email addresses for efficient lookup&#10;    existing_email_set = {str(email.email).lower() for email in existing_emails}&#10;&#10;    for email in obj_in.emails:&#10;        # Check if this email already exists for this company&#10;        if str(email.email).lower() in existing_email_set:&#10;            # Skip this email as it already exists&#10;            continue&#10;&#10;        # Create new email record&#10;        db_obj = CompanyEmails(&#10;            company_id=obj_in.company_id,&#10;            email=str(email.email).lower(),&#10;            status=email.status.lower()&#10;        )&#10;        db_obj.id = str(uuid.uuid4())&#10;        db.add(db_obj)&#10;&#10;    # Commit all new emails at once&#10;    db.commit()&#10;&#10;&#10;def get_company_emails(db: Session, company_id: str) -&gt; List[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get all emails for a specific company&#10;    &quot;&quot;&quot;&#10;    company_emails = db.query(CompanyEmails).filter(CompanyEmails.company_id == company_id).all()&#10;&#10;    return company_emails&#10;&#10;&#10;&#10;def get_company_email(db: Session, email_id: str) -&gt; Optional[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company email by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyEmails).filter(CompanyEmails.id == email_id).first()&#10;&#10;&#10;def delete_company_email(db: Session, email_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company email&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyEmails).filter(&#10;        CompanyEmails.id == email_id,&#10;        CompanyEmails.company_id == company_id&#10;    ).first()&#10;&#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_phone(db: Session, *, obj_in: CompanyPhoneCreate) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Create new phone numbers for a company, handling duplicate phone numbers&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company phone numbers to add&#10;&#10;    Returns:&#10;        List of created phone number objects&#10;    &quot;&quot;&quot;&#10;    # Get existing phone numbers for this company to check duplicates&#10;    existing_phones = db.query(CompanyPhones).filter(&#10;        CompanyPhones.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing phone numbers for efficient lookup&#10;    existing_phone_set = {phone.phone for phone in existing_phones}&#10;&#10;    created_phones = []&#10;    for phone_data in obj_in.company_phones:&#10;        # Check if this phone number already exists for this company&#10;        if phone_data.phone in existing_phone_set:&#10;            # Skip this phone number as it already exists&#10;            continue&#10;&#10;        # Create new phone number record&#10;        db_obj = CompanyPhones(&#10;            company_id=obj_in.company_id,&#10;            phone=phone_data.phone,&#10;            is_primary=phone_data.is_primary,&#10;            status=phone_data.status&#10;        )&#10;        # db_obj.id = str(uuid.uuid4())&#10;        &#10;        db.add(db_obj)&#10;        created_phones.append(db_obj)&#10;        &#10;    # Commit all new phone numbers at once&#10;    db.commit()&#10;&#10;    # Refresh all newly created objects&#10;    for phone in created_phones:&#10;        db.refresh(phone)&#10;&#10;    return created_phones&#10;&#10;&#10;def get_company_phones(db: Session, company_id: str) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers for a specific company&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.company_id == company_id).all()&#10;&#10;&#10;def get_company_phone(db: Session, phone_id: str) -&gt; Optional[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company phone by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.id == phone_id).first()&#10;&#10;&#10;def delete_company_phone(db: Session, phone_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company phone number&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyPhones).filter(&#10;        CompanyPhones.id == phone_id,&#10;        CompanyPhones.company_id == company_id&#10;    ).first()&#10;    &#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_member(db: Session, *, user_in: UserCreate, company_id: str, role: CompanyRoleType) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to a company with the specified role.&#10;&#10;    Args:&#10;        db: Database session&#10;        user_in: User creation data&#10;        company_id: Company ID to add the user to&#10;        role: Role to assign to the user in the company&#10;&#10;    Returns:&#10;        CompanyUsers object with the user relationship&#10;    &quot;&quot;&quot;&#10;    # Check if user with this email already exists&#10;    existing_user = db.query(Users).filter(Users.email == user_in.email).first()&#10;&#10;    if existing_user:&#10;        # Check if user is already part of this company&#10;        existing_company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == company_id&#10;        ).first()&#10;&#10;        if existing_company_user:&#10;            raise ValueError(&quot;User is already a member of this company&quot;)&#10;&#10;        # Add existing user to the company&#10;        company_user = CompanyUsers(&#10;            user_id=existing_user.id,&#10;            company_id=company_id,&#10;            role=role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;        db.commit()&#10;        db.refresh(company_user)&#10;        return company_user&#10;&#10;    # Create new user&#10;    user_data = user_in.model_dump()&#10;    user_data['password'] = hash_password(user_data['password'])&#10;&#10;    new_user = Users(**user_data)&#10;    new_user.id = str(uuid.uuid4())&#10;    new_user.status = StatusType.active&#10;&#10;    db.add(new_user)&#10;    db.commit()&#10;    db.refresh(new_user)&#10;&#10;    # Add user to company&#10;    company_user = CompanyUsers(&#10;        user_id=new_user.id,&#10;        company_id=company_id,&#10;        role=role,&#10;        status=StatusType.active&#10;    )&#10;    db.add(company_user)&#10;    db.commit()&#10;    db.refresh(company_user)&#10;&#10;    return company_user" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>