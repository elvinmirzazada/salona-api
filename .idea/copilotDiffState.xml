<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/alembic/versions/add_membership_tables.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic/versions/add_membership_tables.py" />
              <option name="originalContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/bookings.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/bookings.py" />
              <option name="originalContent" value="from collections import defaultdict&#10;from datetime import datetime, timezone, date, timedelta&#10;from typing import List, Optional&#10;&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Header&#10;from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from app.db.session import get_db&#10;from app.core.redis_client import publish_event&#10;from app.schemas import CompanyNotificationCreate&#10;from app.services.notification_service import notification_service&#10;from app.services.email_service import email_service&#10;from app.schemas.schemas import Booking, BookingCreate, BookingUpdate, AvailabilityResponse, CustomerCreate&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import customer as crud_customer&#10;from app.api.dependencies import get_current_company_id, get_token_payload&#10;from app.schemas.responses import DataResponse&#10;from app.api.dependencies import get_current_customer&#10;from app.models import BookingServices, BookingStatus, NotificationType, CompanyUsers, CompanyRoleType, Users&#10;&#10;from app.services.auth import verify_token&#10;import uuid&#10;import json&#10;&#10;&#10;router = APIRouter()&#10;security = HTTPBearer(auto_error=False)&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[List[Booking]], status_code=status.HTTP_200_OK)&#10;async def get_all_bookings(&#10;        *,&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        start_date: Optional[date] = Query(None, description=&quot;Start date in YYYY-MM-DD format&quot;),&#10;        end_date: Optional[date] = Query(None, description=&quot;End date in YYYY-MM-DD format&quot;)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get bookings with details for a company within a date range.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Company ID is required&quot;&#10;        )&#10;    if not start_date:&#10;        # Get timezone-aware datetime for start of week&#10;        now = datetime.now(timezone.utc)&#10;        start_date = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0).date()&#10;    if not end_date:&#10;        # Get timezone-aware datetime for end of week&#10;        now = datetime.now(timezone.utc)&#10;        end_date = (now - timedelta(days=now.weekday()) + timedelta(days=7)).replace(hour=23, minute=59, second=59, microsecond=999999).date()&#10;&#10;    bookings: List[Booking] = await crud_booking.get_all_bookings_in_range_by_company(db=db,&#10;                                                                 company_id=company_id,&#10;                                                                 start_date=start_date,&#10;                                                                 end_date=end_date)&#10;&#10;    if not bookings:&#10;        return DataResponse.success_response(&#10;            message=&quot;No bookings found&quot;,&#10;            data=[],&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=bookings,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/users/create_booking&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;async def create_booking_by_user(&#10;        *,&#10;        db: AsyncSession = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id),&#10;&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;    if not booking_in.company_id:&#10;        booking_in.company_id = company_id&#10;&#10;&#10;    # For unregistered customers, we need customer_info in the booking_in&#10;    if not booking_in.customer_info:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Customer information required for unregistered booking&quot;&#10;        )&#10;    if booking_in.customer_info.id:&#10;        # If customer_info contains an ID, try to fetch that customer&#10;        existing_customer = await crud_customer.get(db, id=booking_in.customer_info.id)&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Customer with provided ID not found&quot;&#10;            )&#10;        # If we found the customer by ID, we can skip creating a new one&#10;        booking_in.customer_info = None  # Clear to avoid confusion later&#10;&#10;    # Create a new customer from the provided information&#10;    if booking_in.customer_info:&#10;        customer_data = CustomerCreate(&#10;            first_name=booking_in.customer_info.first_name,&#10;            last_name=booking_in.customer_info.last_name,&#10;            email=booking_in.customer_info.email,&#10;            phone=booking_in.customer_info.phone,&#10;            password=str(uuid.uuid4())  # Random password for inactive account&#10;        )&#10;&#10;        # Check if customer with this email already exists&#10;        existing_customer = await crud_customer.get_by_email(db, email=str(customer_data.email))&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            customer = await crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Verify that the company exists&#10;    selected_company = await crud_company.get(db=db, id=booking_in.company_id)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Selected company not found&quot;&#10;        )&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;&#10;    # Calculate the start and end time for each service to check staff availability&#10;    current_start_time = booking_in.start_time&#10;    &#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = await crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        selected_user = await crud_user.get(db=db, id=selected_company_service.user_id)&#10;        if not selected_user:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                data = None,&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;User not found or doesn't belong to this company&quot;&#10;            )&#10;        &#10;        # Calculate end time for this service&#10;        service_end_time = current_start_time + timedelta(minutes=company_service.duration)&#10;        &#10;        # Check if the staff member is available for this service time slot&#10;        is_available, conflict_message = await crud_booking.check_staff_availability(&#10;            db=db,&#10;            user_id=selected_company_service.user_id,&#10;            start_time=current_start_time,&#10;            end_time=service_end_time&#10;        )&#10;        &#10;        if not is_available:&#10;            response.status_code = status.HTTP_409_CONFLICT&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_409_CONFLICT,&#10;                message=conflict_message&#10;            )&#10;        &#10;        # Move to the next service start time&#10;        current_start_time = service_end_time&#10;&#10;    try:&#10;        booking = await crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        # await publish_event('booking_created', str({'info': f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;}))&#10;&#10;        # Create confirmation notification for the assigned staff member&#10;        booking_data = json.dumps({&#10;            'booking_id': str(booking.id),&#10;            'company_id': str(booking.company_id)&#10;        }).encode('utf-8')&#10;        &#10;        res = await notification_service.create_notification(&#10;            db=db,&#10;            notification_request=CompanyNotificationCreate(&#10;                company_id=booking_in.company_id,&#10;                type=NotificationType.BOOKING_CREATED,&#10;                message=f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;,&#10;                data=booking_data&#10;            )&#10;        )&#10;        booking = Booking.model_validate(booking)&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;@router.put(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def update_booking(&#10;        *,&#10;        db: AsyncSession = Depends(get_db),&#10;        booking_id: str,&#10;        booking_in: BookingUpdate,&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update booking information.&#10;    Can update status, start_time, end_time, services, or notes.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the existing booking&#10;        booking = await crud_booking.get(db=db, id=booking_id)&#10;        if not booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        # Check if booking belongs to the company&#10;        if str(booking.company_id) != company_id:&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                message=&quot;You don't have permission to update this booking&quot;&#10;            )&#10;&#10;        # If updating time, validate it's not in the past&#10;        if booking_in.start_time and booking_in.start_time &lt; datetime.now(timezone.utc):&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Cannot update booking time to the past&quot;&#10;            )&#10;&#10;        # If services are being updated, validate them&#10;        if booking_in.services:&#10;            current_start_time = booking_in.start_time or booking.start_at&#10;&#10;            for selected_company_service in booking_in.services:&#10;                # Verify service exists and belongs to company&#10;                company_service = await crud_service.get_service(&#10;                    db=db,&#10;                    service_id=selected_company_service.category_service_id,&#10;                    company_id=company_id&#10;                )&#10;                if not company_service:&#10;                    response.status_code = status.HTTP_404_NOT_FOUND&#10;                    return DataResponse.error_response(&#10;                        status_code=status.HTTP_404_NOT_FOUND,&#10;                        message=&quot;Service not found or doesn't belong to this company&quot;&#10;                    )&#10;&#10;                # Verify user exists and belongs to company&#10;                selected_user = await crud_user.get(db=db, id=selected_company_service.user_id)&#10;                if not selected_user:&#10;                    response.status_code = status.HTTP_404_NOT_FOUND&#10;                    return DataResponse.error_response(&#10;                        data=None,&#10;                        status_code=status.HTTP_404_NOT_FOUND,&#10;                        message=&quot;User not found or doesn't belong to this company&quot;&#10;                    )&#10;&#10;                # Calculate end time for this service&#10;                service_end_time = current_start_time + timedelta(minutes=company_service.duration)&#10;&#10;                # Check staff availability (excluding current booking)&#10;                is_available, conflict_message = await crud_booking.check_staff_availability(&#10;                    db=db,&#10;                    user_id=selected_company_service.user_id,&#10;                    start_time=current_start_time,&#10;                    end_time=service_end_time,&#10;                    exclude_booking_id=booking_id&#10;                )&#10;&#10;                if not is_available:&#10;                    response.status_code = status.HTTP_409_CONFLICT&#10;                    return DataResponse.error_response(&#10;                        status_code=status.HTTP_409_CONFLICT,&#10;                        message=conflict_message&#10;                    )&#10;&#10;                current_start_time = service_end_time&#10;&#10;        # Update the booking&#10;        updated_booking = await crud_booking.update(db=db, db_obj=booking, obj_in=booking_in)&#10;&#10;        # Create notification for status change&#10;        if booking_in.status and booking_in.status != booking.status:&#10;            booking_data = json.dumps({&#10;                'booking_id': str(booking.id),&#10;                'company_id': str(booking.company_id),&#10;                'old_status': str(booking.status),&#10;                'new_status': str(booking_in.status)&#10;            }).encode('utf-8')&#10;&#10;            await notification_service.create_notification(&#10;                db=db,&#10;                notification_request=CompanyNotificationCreate(&#10;                    company_id=company_id,&#10;                    type=NotificationType.BOOKING_UPDATED,&#10;                    message=f&quot;Booking status changed from {booking.status} to {booking_in.status}&quot;,&#10;                    data=booking_data&#10;                )&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking updated successfully&quot;,&#10;            data=updated_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update booking: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.patch(&quot;/{booking_id}/no-show&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def mark_booking_no_show(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Mark a booking as NO_SHOW when the customer doesn't show up.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = await crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to modify this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot mark a cancelled booking as no-show&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot mark a completed booking as no-show&quot;&#10;        )&#10;&#10;    # Check if booking is already marked as no-show&#10;    if existing_booking.status == BookingStatus.NO_SHOW:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Booking is already marked as no-show&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD no_show function to mark the booking as no-show&#10;        no_show_booking = await crud_booking.no_show(db=db, booking_id=booking_uuid)&#10;        if not no_show_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        await db.commit()&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking marked as no-show successfully&quot;,&#10;            data=no_show_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to mark booking as no-show: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def delete_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by ID (marks as cancelled instead of deleting).&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = await crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to cancel this booking&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD cancel function to mark the booking as cancelled&#10;        cancelled_booking = await crud_booking.cancel(db=db, booking_id=booking_uuid)&#10;        if not cancelled_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        await db.commit()&#10;&#10;        company = await crud_company.get(db, id=cancelled_booking.company_id)&#10;&#10;        email_service.send_booking_cancellation_to_customer_email(&#10;            to_email=cancelled_booking.customer.email,&#10;            customer_name=cancelled_booking.customer.first_name,&#10;            company_name=company.name,&#10;            booking_date=cancelled_booking.start_at.isoformat(),&#10;            services=[service.category_service.name for service in cancelled_booking.booking_services],&#10;            company_id=company.id&#10;        )&#10;&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking cancelled successfully&quot;,&#10;            data=cancelled_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to cancel booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.patch(&quot;/{booking_id}/confirm&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def confirm_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = await crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to confirm this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot confirm a cancelled booking&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot confirm a completed booking&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD confirm function to mark the booking as confirmed&#10;        confirmed_booking = await crud_booking.confirm(db=db, booking_id=booking_uuid)&#10;        if not confirmed_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        await db.commit()&#10;        company = await crud_company.get(db, id=confirmed_booking.company_id)&#10;&#10;        # Get company address for calendar location&#10;        from app.models.models import CompanyAddresses&#10;        from sqlalchemy import select&#10;        stmt = select(CompanyAddresses).filter(&#10;            CompanyAddresses.company_id == confirmed_booking.company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        company_address = result.scalar_one_or_none()&#10;&#10;        # Format location string&#10;        location = None&#10;        if company_address:&#10;            location = f&quot;{company_address.address}, {company_address.city}, {company_address.country}&quot;&#10;            if company_address.zip:&#10;                location = f&quot;{company_address.address}, {company_address.city}, {company_address.zip}, {company_address.country}&quot;&#10;&#10;        email_service.send_booking_confirmation_to_customer_email(&#10;            to_email=confirmed_booking.customer.email,&#10;            customer_name=confirmed_booking.customer.first_name,&#10;            company_name=company.name,&#10;            booking_date=confirmed_booking.start_at.isoformat(),&#10;            services=[service.category_service.name for service in confirmed_booking.booking_services],&#10;            start_datetime=confirmed_booking.start_at,&#10;            end_datetime=confirmed_booking.end_at,&#10;            location=location&#10;        )&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking confirmed successfully&quot;,&#10;            data=confirmed_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to confirm booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.patch(&quot;/{booking_id}/complete&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def complete_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Complete a booking by setting its status to COMPLETED.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = await crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to complete this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot complete a cancelled booking&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Booking is already completed&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD complete function to mark the booking as completed&#10;        completed_booking = await crud_booking.complete(db=db, booking_id=booking_uuid)&#10;        if not completed_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        await db.commit()&#10;        company = await crud_company.get(db, id=completed_booking.company_id)&#10;        email_service.send_booking_completed_to_customer_email(&#10;            to_email=completed_booking.customer.email,&#10;            customer_name=completed_booking.customer.first_name,&#10;            company_name=company.name,&#10;            booking_date=completed_booking.start_at.isoformat(),&#10;            services=[service.category_service.name for service in completed_booking.booking_services],&#10;            total_price=completed_booking.total_price / 100.0&#10;        )&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking completed successfully&quot;,&#10;            data=completed_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to complete booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;" />
              <option name="updatedContent" value="from collections import defaultdict&#10;from datetime import datetime, timezone, date, timedelta&#10;from typing import List, Optional&#10;&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Header&#10;from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from app.db.session import get_db&#10;from app.core.redis_client import publish_event&#10;from app.schemas import CompanyNotificationCreate&#10;from app.services.notification_service import notification_service&#10;from app.services.email_service import email_service&#10;from app.schemas.schemas import Booking, BookingCreate, BookingUpdate, AvailabilityResponse, CustomerCreate&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import customer as crud_customer&#10;from app.api.dependencies import get_current_company_id, get_token_payload&#10;from app.schemas.responses import DataResponse&#10;from app.api.dependencies import get_current_customer&#10;from app.models import BookingServices, BookingStatus, NotificationType, CompanyUsers, CompanyRoleType, Users&#10;&#10;from app.services.auth import verify_token&#10;import uuid&#10;import json&#10;&#10;&#10;router = APIRouter()&#10;security = HTTPBearer(auto_error=False)&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[List[Booking]], status_code=status.HTTP_200_OK)&#10;async def get_all_bookings(&#10;        *,&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        start_date: Optional[date] = Query(None, description=&quot;Start date in YYYY-MM-DD format&quot;),&#10;        end_date: Optional[date] = Query(None, description=&quot;End date in YYYY-MM-DD format&quot;)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get bookings with details for a company within a date range.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Company ID is required&quot;&#10;        )&#10;    if not start_date:&#10;        # Get timezone-aware datetime for start of week&#10;        now = datetime.now(timezone.utc)&#10;        start_date = (now - timedelta(days=now.weekday())).replace(hour=0, minute=0, second=0, microsecond=0).date()&#10;    if not end_date:&#10;        # Get timezone-aware datetime for end of week&#10;        now = datetime.now(timezone.utc)&#10;        end_date = (now - timedelta(days=now.weekday()) + timedelta(days=7)).replace(hour=23, minute=59, second=59, microsecond=999999).date()&#10;&#10;    bookings: List[Booking] = await crud_booking.get_all_bookings_in_range_by_company(db=db,&#10;                                                                 company_id=company_id,&#10;                                                                 start_date=start_date,&#10;                                                                 end_date=end_date)&#10;&#10;    if not bookings:&#10;        return DataResponse.success_response(&#10;            message=&quot;No bookings found&quot;,&#10;            data=[],&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=bookings,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/users/create_booking&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;async def create_booking_by_user(&#10;        *,&#10;        db: AsyncSession = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id),&#10;&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;    if not booking_in.company_id:&#10;        booking_in.company_id = company_id&#10;&#10;&#10;    # For unregistered customers, we need customer_info in the booking_in&#10;    if not booking_in.customer_info:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Customer information required for unregistered booking&quot;&#10;        )&#10;    if booking_in.customer_info.id:&#10;        # If customer_info contains an ID, try to fetch that customer&#10;        existing_customer = await crud_customer.get(db, id=booking_in.customer_info.id)&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Customer with provided ID not found&quot;&#10;            )&#10;        # If we found the customer by ID, we can skip creating a new one&#10;        booking_in.customer_info = None  # Clear to avoid confusion later&#10;&#10;    # Create a new customer from the provided information&#10;    if booking_in.customer_info:&#10;        customer_data = CustomerCreate(&#10;            first_name=booking_in.customer_info.first_name,&#10;            last_name=booking_in.customer_info.last_name,&#10;            email=booking_in.customer_info.email,&#10;            phone=booking_in.customer_info.phone,&#10;            password=str(uuid.uuid4())  # Random password for inactive account&#10;        )&#10;&#10;        # Check if customer with this email already exists&#10;        existing_customer = await crud_customer.get_by_email(db, email=str(customer_data.email))&#10;        if existing_customer:&#10;            customer = existing_customer&#10;        else:&#10;            customer = await crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Verify that the company exists&#10;    selected_company = await crud_company.get(db=db, id=booking_in.company_id)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Selected company not found&quot;&#10;        )&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;&#10;    # Calculate the start and end time for each service to check staff availability&#10;    current_start_time = booking_in.start_time&#10;    &#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = await crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        selected_user = await crud_user.get(db=db, id=selected_company_service.user_id)&#10;        if not selected_user:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                data = None,&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;User not found or doesn't belong to this company&quot;&#10;            )&#10;        &#10;        # Calculate end time for this service&#10;        service_end_time = current_start_time + timedelta(minutes=company_service.duration)&#10;        &#10;        # Check if the staff member is available for this service time slot&#10;        is_available, conflict_message = await crud_booking.check_staff_availability(&#10;            db=db,&#10;            user_id=selected_company_service.user_id,&#10;            start_time=current_start_time,&#10;            end_time=service_end_time&#10;        )&#10;        &#10;        if not is_available:&#10;            response.status_code = status.HTTP_409_CONFLICT&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_409_CONFLICT,&#10;                message=conflict_message&#10;            )&#10;        &#10;        # Move to the next service start time&#10;        current_start_time = service_end_time&#10;&#10;    try:&#10;        booking = await crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        # await publish_event('booking_created', str({'info': f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;}))&#10;&#10;        # Create confirmation notification for the assigned staff member&#10;        booking_data = json.dumps({&#10;            'booking_id': str(booking.id),&#10;            'company_id': str(booking.company_id)&#10;        }).encode('utf-8')&#10;        &#10;        res = await notification_service.create_notification(&#10;            db=db,&#10;            notification_request=CompanyNotificationCreate(&#10;                company_id=booking_in.company_id,&#10;                type=NotificationType.BOOKING_CREATED,&#10;                message=f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;,&#10;                data=booking_data&#10;            )&#10;        )&#10;        booking = Booking.model_validate(booking)&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;@router.put(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def update_booking(&#10;        *,&#10;        db: AsyncSession = Depends(get_db),&#10;        booking_id: str,&#10;        booking_in: BookingUpdate,&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update booking information.&#10;    Can update status, start_time, end_time, services, or notes.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the existing booking&#10;        booking = await crud_booking.get(db=db, id=booking_id)&#10;        if not booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        # Check if booking belongs to the company&#10;        if str(booking.company_id) != company_id:&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                message=&quot;You don't have permission to update this booking&quot;&#10;            )&#10;&#10;        # If updating time, validate it's not in the past&#10;        if booking_in.start_time and booking_in.start_time &lt; datetime.now(timezone.utc):&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Cannot update booking time to the past&quot;&#10;            )&#10;&#10;        # If services are being updated, validate them&#10;        if booking_in.services:&#10;            current_start_time = booking_in.start_time or booking.start_at&#10;&#10;            for selected_company_service in booking_in.services:&#10;                # Verify service exists and belongs to company&#10;                company_service = await crud_service.get_service(&#10;                    db=db,&#10;                    service_id=selected_company_service.category_service_id,&#10;                    company_id=company_id&#10;                )&#10;                if not company_service:&#10;                    response.status_code = status.HTTP_404_NOT_FOUND&#10;                    return DataResponse.error_response(&#10;                        status_code=status.HTTP_404_NOT_FOUND,&#10;                        message=&quot;Service not found or doesn't belong to this company&quot;&#10;                    )&#10;&#10;                # Verify user exists and belongs to company&#10;                selected_user = await crud_user.get(db=db, id=selected_company_service.user_id)&#10;                if not selected_user:&#10;                    response.status_code = status.HTTP_404_NOT_FOUND&#10;                    return DataResponse.error_response(&#10;                        data=None,&#10;                        status_code=status.HTTP_404_NOT_FOUND,&#10;                        message=&quot;User not found or doesn't belong to this company&quot;&#10;                    )&#10;&#10;                # Calculate end time for this service&#10;                service_end_time = current_start_time + timedelta(minutes=company_service.duration)&#10;&#10;                # Check staff availability (excluding current booking)&#10;                is_available, conflict_message = await crud_booking.check_staff_availability(&#10;                    db=db,&#10;                    user_id=selected_company_service.user_id,&#10;                    start_time=current_start_time,&#10;                    end_time=service_end_time,&#10;                    exclude_booking_id=booking_id&#10;                )&#10;&#10;                if not is_available:&#10;                    response.status_code = status.HTTP_409_CONFLICT&#10;                    return DataResponse.error_response(&#10;                        status_code=status.HTTP_409_CONFLICT,&#10;                        message=conflict_message&#10;                    )&#10;&#10;                current_start_time = service_end_time&#10;&#10;        # Update the booking&#10;        updated_booking = await crud_booking.update(db=db, db_obj=booking, obj_in=booking_in)&#10;&#10;        # Create notification for status change&#10;        if booking_in.status and booking_in.status != booking.status:&#10;            booking_data = json.dumps({&#10;                'booking_id': str(booking.id),&#10;                'company_id': str(booking.company_id),&#10;                'old_status': str(booking.status),&#10;                'new_status': str(booking_in.status)&#10;            }).encode('utf-8')&#10;&#10;            await notification_service.create_notification(&#10;                db=db,&#10;                notification_request=CompanyNotificationCreate(&#10;                    company_id=company_id,&#10;                    type=NotificationType.BOOKING_UPDATED,&#10;                    message=f&quot;Booking status changed from {booking.status} to {booking_in.status}&quot;,&#10;                    data=booking_data&#10;                )&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking updated successfully&quot;,&#10;            data=updated_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update booking: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.patch(&quot;/{booking_id}/no-show&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def mark_booking_no_show(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Mark a booking as NO_SHOW when the customer doesn't show up.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = await crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to modify this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot mark a cancelled booking as no-show&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot mark a completed booking as no-show&quot;&#10;        )&#10;&#10;    # Check if booking is already marked as no-show&#10;    if existing_booking.status == BookingStatus.NO_SHOW:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Booking is already marked as no-show&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD no_show function to mark the booking as no-show&#10;        no_show_booking = await crud_booking.no_show(db=db, booking_id=booking_uuid)&#10;        if not no_show_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        await db.commit()&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking marked as no-show successfully&quot;,&#10;            data=no_show_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to mark booking as no-show: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/{booking_id}&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def delete_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by ID (marks as cancelled instead of deleting).&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = await crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to cancel this booking&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD cancel function to mark the booking as cancelled&#10;        cancelled_booking = await crud_booking.cancel(db=db, booking_id=booking_uuid)&#10;        if not cancelled_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        await db.commit()&#10;&#10;        company = await crud_company.get(db, id=cancelled_booking.company_id)&#10;&#10;        email_service.send_booking_cancellation_to_customer_email(&#10;            to_email=cancelled_booking.customer.email,&#10;            customer_name=cancelled_booking.customer.first_name,&#10;            company_name=company.name,&#10;            booking_date=cancelled_booking.start_at.isoformat(),&#10;            services=[service.category_service.name for service in cancelled_booking.booking_services],&#10;            company_id=company.id&#10;        )&#10;&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking cancelled successfully&quot;,&#10;            data=cancelled_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to cancel booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.patch(&quot;/{booking_id}/confirm&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def confirm_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = await crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to confirm this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot confirm a cancelled booking&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot confirm a completed booking&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD confirm function to mark the booking as confirmed&#10;        confirmed_booking = await crud_booking.confirm(db=db, booking_id=booking_uuid)&#10;        if not confirmed_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        await db.commit()&#10;        company = await crud_company.get(db, id=confirmed_booking.company_id)&#10;&#10;        # Get company address for calendar location&#10;        from app.models.models import CompanyAddresses&#10;        from sqlalchemy import select&#10;        stmt = select(CompanyAddresses).filter(&#10;            CompanyAddresses.company_id == confirmed_booking.company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        company_address = result.scalar_one_or_none()&#10;&#10;        # Format location string&#10;        location = None&#10;        if company_address:&#10;            location = f&quot;{company_address.address}, {company_address.city}, {company_address.country}&quot;&#10;            if company_address.zip:&#10;                location = f&quot;{company_address.address}, {company_address.city}, {company_address.zip}, {company_address.country}&quot;&#10;&#10;        email_service.send_booking_confirmation_to_customer_email(&#10;            to_email=confirmed_booking.customer.email,&#10;            customer_name=confirmed_booking.customer.first_name,&#10;            company_name=company.name,&#10;            booking_date=confirmed_booking.start_at.isoformat(),&#10;            services=[service.category_service.name for service in confirmed_booking.booking_services],&#10;            start_datetime=confirmed_booking.start_at,&#10;            end_datetime=confirmed_booking.end_at,&#10;            location=location&#10;        )&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking confirmed successfully&quot;,&#10;            data=confirmed_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to confirm booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.patch(&quot;/{booking_id}/complete&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_200_OK)&#10;async def complete_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response,&#10;        company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Complete a booking by setting its status to COMPLETED.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        booking_uuid = UUID4(booking_id)&#10;    except ValueError:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Invalid booking ID format&quot;&#10;        )&#10;&#10;    # Get the existing booking&#10;    existing_booking = await crud_booking.get(db=db, id=booking_uuid)&#10;    if not existing_booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;&#10;    # Verify that the booking belongs to the company&#10;    if str(existing_booking.company_id) != company_id:&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            message=&quot;You don't have permission to complete this booking&quot;&#10;        )&#10;&#10;    # Check if booking is already cancelled&#10;    if existing_booking.status == BookingStatus.CANCELLED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot complete a cancelled booking&quot;&#10;        )&#10;&#10;    # Check if booking is already completed&#10;    if existing_booking.status == BookingStatus.COMPLETED:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Booking is already completed&quot;&#10;        )&#10;&#10;    try:&#10;        # Use the CRUD complete function to mark the booking as completed&#10;        completed_booking = await crud_booking.complete(db=db, booking_id=booking_uuid)&#10;        if not completed_booking:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Booking not found&quot;&#10;            )&#10;&#10;        await db.commit()&#10;        company = await crud_company.get(db, id=completed_booking.company_id)&#10;        email_service.send_booking_completed_to_customer_email(&#10;            to_email=completed_booking.customer.email,&#10;            customer_name=completed_booking.customer.first_name,&#10;            company_name=company.name,&#10;            booking_date=completed_booking.start_at.isoformat(),&#10;            services=[service.category_service.name for service in completed_booking.booking_services],&#10;            total_price=completed_booking.total_price / 100.0&#10;        )&#10;        response.status_code = status.HTTP_200_OK&#10;        return DataResponse.success_response(&#10;            message=&quot;Booking completed successfully&quot;,&#10;            data=completed_booking,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to complete booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/companies.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/companies.py" />
              <option name="originalContent" value="import uuid&#10;from typing import List&#10;from datetime import date, timedelta, datetime&#10;from fastapi import APIRouter, Depends, HTTPException, status, Query, Response, File, UploadFile&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy import select&#10;from app.api.dependencies import (&#10;    get_current_active_user,&#10;    get_current_active_customer,&#10;    get_current_company_id,&#10;    require_admin_or_owner,&#10;    require_owner,&#10;    require_staff_or_higher,&#10;    get_current_user_role&#10;)&#10;from app.db.session import get_db&#10;from app.models import CompanyAddresses&#10;from app.models.models import Users, CompanyUsers&#10;from app.models.enums import CompanyRoleType, StatusType, InvitationStatus&#10;from app.schemas import (&#10;    CompanyCreate, User, Company, AvailabilityResponse, AvailabilityType, CompanyUser, CompanyUserUpdate,&#10;    CategoryServiceResponse, CompanyCategoryWithServicesResponse, Customer, TimeOff, CompanyUpdate,&#10;    CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, CompanyPhone, UserCreate,&#10;    Invitation, InvitationCreate, InvitationAccept, CompanyAddressResponse, CompanyAddressCreate, CompanyCustomer&#10;)&#10;from app.schemas.responses import DataResponse&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import customer as crud_customer&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import user_availability as crud_user_availability&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_user_time_off&#10;from app.services.crud import invitation as crud_invitation&#10;from app.services.email_service import email_service&#10;from app.services.auth import hash_password&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Company], status_code=status.HTTP_201_CREATED)&#10;async def create_company(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_in: CompanyCreate,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new company.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.create(db=db, obj_in=company_in, current_user=current_user)&#10;    return DataResponse.success_response(&#10;        data=company,&#10;        message=&quot;Company created successfully&quot;,&#10;        status_code=status.HTTP_201_CREATED&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}/users/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        service_ids: List[str] = Query(None, description=&quot;List of service IDs to calculate availability based on combined service duration&quot;),&#10;        response: Response,&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;&#10;    If service_ids are provided, the last available slot will be calculated based on the total duration of all services.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get company to access timezone setting&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Company not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        company_timezone = company.timezone or &quot;UTC&quot;&#10;        &#10;        # Calculate total service duration if service_ids are provided&#10;        service_duration_minutes = None&#10;        if service_ids:&#10;            total_duration = 0&#10;            for service_id in service_ids:&#10;                service = await crud_service.get_service(db=db, service_id=service_id, company_id=company_id)&#10;                if service:&#10;                    total_duration += service.duration&#10;            service_duration_minutes = total_duration if total_duration &gt; 0 else None&#10;&#10;        # Get user's regular availability&#10;        availabilities = await crud_company.get_company_user_availabilities(db, user_id=user_id, company_id=company_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_200_OK&#10;            return DataResponse.success_response(&#10;                data=AvailabilityResponse(&#10;                    user_id=None,&#10;                    availability_type=availability_type,&#10;                    daily=None&#10;                ),&#10;                message=&quot;No availability schedule found for this user&quot;&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = await crud_company.get_company_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = await crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, existing bookings, and service duration&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from,&#10;                service_duration_minutes=service_duration_minutes,&#10;                company_timezone=company_timezone&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/{company_id}/availabilities&quot;, response_model=DataResponse[list[AvailabilityResponse]])&#10;async def get_company_all_users_availabilities(&#10;        *,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[list[AvailabilityResponse]]:&#10;    &quot;&quot;&quot;&#10;    Get availabilities for all users for a specific time range. Optimized to fetch all data in bulk and group bookings by user via BookingServices.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get company to access timezone setting&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Company not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        company_timezone = company.timezone or &quot;UTC&quot;&#10;        &#10;        company_users = await crud_company.get_company_users(db, company_id)&#10;        if not company_users:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No users found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        # Bulk fetch all related data&#10;        availabilities = await crud_company.get_company_all_users_availabilities(db, company_id)&#10;        time_offs = await crud_company.get_company_all_users_time_offs(&#10;            db,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        booking_tuples = await crud_booking.get_all_bookings_in_range(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        # Group data by user&#10;        avail_map = {}&#10;        for a in availabilities:&#10;            avail_map.setdefault(str(a.user_id), []).append(a)&#10;        timeoff_map = {}&#10;        for t in time_offs:&#10;            timeoff_map.setdefault(str(t.user_id), []).append(t)&#10;        booking_map = {}&#10;        for booking, user_id in booking_tuples:&#10;            booking_map.setdefault(str(user_id), []).append(booking)&#10;        results = []&#10;        for user in company_users:&#10;            user_id = str(user.user_id)&#10;            user_avails = avail_map.get(user_id, [])&#10;            if not user_avails:&#10;                continue&#10;            user_timeoffs = timeoff_map.get(user_id, [])&#10;            user_bookings = booking_map.get(user_id, [])&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=user_avails,&#10;                time_offs=user_timeoffs,&#10;                bookings=user_bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from,&#10;                company_timezone=company_timezone&#10;            )&#10;            results.append(availability)&#10;        if not results:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availabilities found for any user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        return DataResponse.success_response(&#10;            data=results,&#10;            message=&quot;Availabilities retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availabilities: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/users&quot;, response_model=DataResponse[List[CompanyUser]])&#10;async def get_company_users(&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can list staff&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all staff/users in the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        return DataResponse.error_response(&#10;            message=&quot;No company associated with the current user&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;    users = await crud_company.get_company_users(&#10;        db=db, company_id=company_id&#10;    )&#10;    return DataResponse.success_response(&#10;        data=users,&#10;        message=&quot;Company users retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;/services&quot;, response_model=DataResponse[List[CompanyCategoryWithServicesResponse]])&#10;async def get_company_services(&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all businesses owned by the authenticated professional.&#10;    &quot;&quot;&quot;&#10;    services = await crud_service.get_company_services(&#10;        db=db, company_id=company_id&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=services,&#10;        message=&quot;Company services retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/customers', response_model=DataResponse[List[CompanyCustomer]])&#10;async def get_company_customers(&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)  # Staff and above can view customers&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all customers who have bookings with the company.&#10;    Requires staff, admin, or owner role.&#10;    &quot;&quot;&quot;&#10;    customers = await crud_customer.get_company_customers(&#10;        db=db, company_id=company_id&#10;    )&#10;    customers = [Customer.model_validate(customer) for customer in customers]&#10;    return DataResponse.success_response(&#10;        data=customers,&#10;        message=&quot;Company customers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/user-time-offs', response_model=DataResponse[List[TimeOff]])&#10;async def get_company_user_time_offs(&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all user time offs for the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    start_date = date_from&#10;    end_date = date_from + timedelta(&#10;        days=1 if availability_type == AvailabilityType.DAILY else&#10;        7 if availability_type == AvailabilityType.WEEKLY else 31&#10;    )&#10;    time_offs = await crud_user_time_off.get_company_user_time_offs(&#10;        db=db, company_id=company_id, start_date=start_date, end_date=end_date&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=time_offs,&#10;        message=&quot;Company user time offs retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[Company])&#10;async def get_company(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}&quot;, response_model=DataResponse[Company])&#10;async def get_company_by_id(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;&#10;@router.get(&quot;/slug/{slug}&quot;, response_model=DataResponse[Company])&#10;async def get_company_by_slug(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    slug: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get_by_slug(db=db, slug=slug)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;@router.get(&quot;/{company_id}/address&quot;, response_model=DataResponse[CompanyAddressResponse])&#10;async def get_company_address(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get the company's address by company_id.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        stmt = select(CompanyAddresses).filter(&#10;            CompanyAddresses.company_id == company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        address = result.scalar_one_or_none()&#10;&#10;        if not address:&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Company address not found&quot;&#10;            )&#10;&#10;        # Convert ORM object to Pydantic response schema&#10;        address_response = CompanyAddressResponse.model_validate(address)&#10;&#10;        return DataResponse.success_response(&#10;            data=address_response,&#10;            message=&quot;Company address retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve company address: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/address&quot;, response_model=DataResponse[CompanyAddressResponse], status_code=status.HTTP_201_CREATED)&#10;async def create_company_address(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    address_in: CompanyAddressCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can add address&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create or update a company address.&#10;    If an address already exists for the company, it will be updated.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if address already exists for this company&#10;        stmt = select(CompanyAddresses).filter(&#10;            CompanyAddresses.company_id == company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        existing_address = result.scalar_one_or_none()&#10;&#10;        if existing_address:&#10;            # Update existing address&#10;            for field, value in address_in.model_dump(exclude_unset=True).items():&#10;                setattr(existing_address, field, value)&#10;            existing_address.updated_at = datetime.now()&#10;            db.add(existing_address)&#10;            await db.commit()&#10;            await db.refresh(existing_address)&#10;&#10;            return DataResponse.success_response(&#10;                data=CompanyAddressResponse.model_validate(existing_address),&#10;                message=&quot;Company address updated successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            # Create new address&#10;            new_address = CompanyAddresses(&#10;                id=uuid.uuid4(),&#10;                company_id=company_id,&#10;                **address_in.model_dump()&#10;            )&#10;            db.add(new_address)&#10;            await db.commit()&#10;            await db.refresh(new_address)&#10;&#10;            return DataResponse.success_response(&#10;                data=CompanyAddressResponse.model_validate(new_address),&#10;                message=&quot;Company address created successfully&quot;,&#10;                status_code=status.HTTP_201_CREATED&#10;            )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to save company address: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.patch(&quot;&quot;, response_model=DataResponse[Company])&#10;async def update_company(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_in: CompanyUpdate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can update company&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update company information.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;&#10;    try:&#10;        updated_company = await crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=company_in&#10;        )&#10;        return DataResponse.success_response(&#10;            data=updated_company,&#10;            message=&quot;Company information updated successfully&quot;&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company information: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/logo&quot;, response_model=DataResponse[dict])&#10;async def upload_company_logo(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    file: UploadFile = File(...),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can upload logo&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Upload company logo to S3 and update company record.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Validate file type&#10;        allowed_types = [&quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/jpg&quot;, &quot;image/webp&quot;]&#10;        if file.content_type not in allowed_types:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invalid file type. Only JPEG, PNG, and WebP are allowed&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Validate file size (e.g., max 5MB)&#10;        file_content = await file.read()&#10;        if len(file_content) &gt; 5 * 1024 * 1024:&#10;            return DataResponse.error_response(&#10;                message=&quot;File size exceeds 5MB limit&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Upload to S3&#10;        from app.services.file_storage import file_storage_service&#10;        logo_url = await file_storage_service.upload_file(&#10;            file_content=file_content,&#10;            file_name=f&quot;companies/{company_id}/logo.{file.filename.split('.')[-1]}&quot;,&#10;            content_type=file.content_type&#10;        )&#10;&#10;        # Update company record&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Company not found&quot;&#10;            )&#10;&#10;        _ = await crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=CompanyUpdate(logo_url=logo_url)&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Company logo uploaded successfully&quot;,&#10;            data={&quot;logo_url&quot;: logo_url}&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to upload company logo: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/logo&quot;, response_model=DataResponse)&#10;async def delete_company_logo(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can delete logo&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete company logo and update company record.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get company&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Company not found&quot;&#10;            )&#10;&#10;        # Update company record to remove logo&#10;        _ = await crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=CompanyUpdate(logo_url=None)&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Company logo deleted successfully&quot;&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to delete company logo: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/emails&quot;, response_model=DataResponse, status_code=status.HTTP_201_CREATED)&#10;async def add_company_email(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    email_in: CompanyEmailCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add a new email address to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        email_in.company_id = company_id&#10;        await crud_company.create_company_email(db=db, obj_in=email_in)&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Emails added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add emails: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/emails&quot;, response_model=DataResponse[List[CompanyEmail]])&#10;async def get_company_emails(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all email addresses associated with the company.&#10;    &quot;&quot;&quot;&#10;    emails = await crud_company.get_company_emails(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=emails,&#10;        message=&quot;Company emails retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/emails/{email_id}&quot;, response_model=DataResponse)&#10;async def delete_company_email(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    email_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete an email address from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = await crud_company.delete_company_email(db=db, email_id=email_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Email not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Email deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/phones&quot;, response_model=DataResponse[List[CompanyPhone]], status_code=status.HTTP_201_CREATED)&#10;async def add_company_phone(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    phone_in: CompanyPhoneCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add new phone numbers to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Set the company ID from the authenticated user's context&#10;        phone_in.company_id = company_id&#10;        phones = await crud_company.create_company_phone(db=db, obj_in=phone_in)&#10;&#10;        return DataResponse.success_response(&#10;            data=phones,&#10;            message=&quot;Phone numbers added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add phone numbers: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/phones&quot;, response_model=DataResponse[List[CompanyPhone]])&#10;async def get_company_phones(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers associated with the company.&#10;    &quot;&quot;&quot;&#10;    phones = await crud_company.get_company_phones(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=phones,&#10;        message=&quot;Company phone numbers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/phones/{phone_id}&quot;, response_model=DataResponse)&#10;async def delete_company_phone(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    phone_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a phone number from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = await crud_company.delete_company_phone(db=db, phone_id=phone_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Phone number not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Phone number deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;@router.post(&quot;/members&quot;, response_model=DataResponse[CompanyUser], status_code=status.HTTP_201_CREATED)&#10;async def add_company_member(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    user_in: UserCreate,&#10;    role: CompanyRoleType = Query(..., description=&quot;Role to assign to the user in the company&quot;),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can add members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to the company with a specified role.&#10;    If a user with the email already exists, they will be added to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_user = await crud_company.create_company_member(&#10;            db=db,&#10;            user_in=user_in,&#10;            company_id=company_id,&#10;            role=role&#10;        )&#10;        return DataResponse.success_response(&#10;            data=company_user,&#10;            message=&quot;Member added to company successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add member to company: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/members/{user_id}&quot;, response_model=DataResponse[CompanyUser])&#10;async def update_company_member(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    user_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_update: CompanyUserUpdate,&#10;    _: None = Depends(require_admin_or_owner)  # Only admin or owner can update members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update a company member's role or status.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Validate that the update data is not empty&#10;        update_data = user_update.model_dump(exclude_unset=True)&#10;        if not update_data:&#10;            return DataResponse.error_response(&#10;                message=&quot;No fields to update&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the company user&#10;        updated_company_user = await crud_company.update_company_user(&#10;            db=db,&#10;            company_id=company_id,&#10;            user_id=user_id,&#10;            obj_in=user_update&#10;        )&#10;&#10;        if not updated_company_user:&#10;            return DataResponse.error_response(&#10;                message=&quot;Company user not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=updated_company_user,&#10;            message=&quot;Company member updated successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company member&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/members/{user_id}&quot;, response_model=DataResponse)&#10;async def remove_company_member(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    user_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    _: None = Depends(require_admin_or_owner)  # Only admin or owner can remove members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Remove a member from the company (soft delete by setting status to inactive).&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if the user exists in the company first&#10;        existing_user = await crud_company.get_company_user(db=db, company_id=company_id, user_id=user_id)&#10;        if not existing_user:&#10;            return DataResponse.error_response(&#10;                message=&quot;Company user not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Remove the user from the company&#10;        success = await crud_company.delete_company_user(&#10;            db=db,&#10;            company_id=company_id,&#10;            user_id=user_id&#10;        )&#10;&#10;        if not success:&#10;            return DataResponse.error_response(&#10;                message=&quot;Failed to remove user from company&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Company member removed successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to remove company member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;# ============== STAFF INVITATION ENDPOINTS ==============&#10;&#10;@router.post(&quot;/invitations&quot;, response_model=DataResponse[Invitation], status_code=status.HTTP_201_CREATED)&#10;async def invite_staff_member(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    invitation_in: InvitationCreate,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Invite a staff member to the company.&#10;&#10;    If the invited email is not registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with sign-up link&#10;&#10;    If the invited email is already registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with acceptance link&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if email is already registered&#10;        existing_user = await crud_user.get_by_email(db=db, email=invitation_in.email.lower())&#10;        is_existing_user = existing_user is not None&#10;&#10;        # Set default role to staff if not provided&#10;        role = invitation_in.role or CompanyRoleType.staff&#10;&#10;        # Create invitation&#10;        invitation = await crud_invitation.create_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation_in.email.lower(),&#10;            role=role&#10;        )&#10;&#10;        # Get company details for email&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                detail=&quot;Company not found&quot;&#10;            )&#10;&#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=invitation.email,&#10;            invitation_token=invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;&#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation created but failed to send email. Please try again.&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(invitation),&#10;            message=&quot;Staff member invited successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to invite staff member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/accept&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def accept_invitation(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    invitation_in: InvitationAccept,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Accept a staff invitation.&#10;&#10;    If the user doesn't exist (new user):&#10;    - Create user account with provided details&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role&#10;    - Activate company_users record&#10;&#10;    If the user already exists (existing user):&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role (or update if already exists)&#10;    - Activate company_users record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation&#10;        invitation = await crud_invitation.get_invitation_by_token(db=db, token=invitation_in.token)&#10;&#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if user exists&#10;        existing_user = await crud_user.get_by_email(db=db, email=invitation.email)&#10;&#10;        if not existing_user:&#10;            # Create new user&#10;            if not invitation_in.password:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;Password is required for new user registration&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST&#10;                )&#10;&#10;            # Hash password&#10;            hashed_password = hash_password(invitation_in.password)&#10;&#10;            # Create user&#10;            user_create_data = {&#10;                &quot;first_name&quot;: invitation_in.first_name,&#10;                &quot;last_name&quot;: invitation_in.last_name,&#10;                &quot;email&quot;: invitation.email,&#10;                &quot;password&quot;: hashed_password,&#10;                &quot;phone&quot;: invitation_in.phone&#10;            }&#10;&#10;            from app.schemas.schemas import UserCreate as UserCreateSchema&#10;            user_in = UserCreateSchema(**user_create_data)&#10;            new_user = await crud_user.create(db=db, obj_in=user_in)&#10;            user_id = new_user.id&#10;        else:&#10;            # Use existing user&#10;            user_id = existing_user.id&#10;&#10;        # Accept invitation (mark as USED and add to company)&#10;        await crud_invitation.accept_invitation(&#10;            db=db,&#10;            invitation=invitation,&#10;            user_id=user_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Invitation accepted successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to accept invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/{token}/resend&quot;, response_model=DataResponse[Invitation])&#10;async def resend_invitation(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    token: str,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation to a staff member.&#10;&#10;    This generates a new token and resets the invitation to PENDING status.&#10;    Only works for expired or pending invitations.&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.models import Invitations&#10;&#10;        # Get the invitation by current token using select&#10;        stmt = select(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.company_id == company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        invitation = result.scalar_one_or_none()&#10;&#10;        if not invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Resend invitation&#10;        resent_invitation = await crud_invitation.resend_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation.email&#10;        )&#10;&#10;        if not resent_invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or cannot be resent&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get company details for email&#10;        company = await crud_company.get(db=db, id=company_id)&#10;&#10;        # Check if user exists for email&#10;        existing_user = await crud_user.get_by_email(db=db, email=resent_invitation.email)&#10;        is_existing_user = existing_user is not None&#10;&#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=resent_invitation.email,&#10;            invitation_token=resent_invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;&#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation updated but failed to send email&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(resent_invitation),&#10;            message=&quot;Invitation resent successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to resend invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/invitations&quot;, response_model=DataResponse[List[Invitation]])&#10;async def get_company_invitations(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    status_filter: str = Query(None, description=&quot;Filter by status: pending, used, expired, declined&quot;),&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company.&#10;&#10;    Optional status filter: pending, used, expired, declined&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.enums import InvitationStatus&#10;&#10;        # Parse status filter&#10;        status_enum = None&#10;        if status_filter:&#10;            status_enum = InvitationStatus(status_filter.upper())&#10;&#10;        invitations = await crud_invitation.get_company_invitations(&#10;            db=db,&#10;            company_id=company_id,&#10;            status=status_enum&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=[Invitation.model_validate(inv) for inv in invitations],&#10;            message=&quot;Company invitations retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except ValueError:&#10;        return DataResponse.error_response(&#10;            message=&quot;Invalid status filter&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve invitations: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/{token}/check-and-join&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def check_invitation_and_join(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    token: str,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Check if the email from invitation is registered.&#10;    If registered, add user to company and return status.&#10;    If not registered, return different status so UI knows to show signup form.&#10;&#10;    Returns:&#10;    - status: &quot;user_exists&quot; - User is registered, added to company, ready to accept&#10;    - status: &quot;user_not_found&quot; - User not registered, show signup form&#10;    - status: &quot;invitation_expired&quot; - Invitation has expired&#10;    - status: &quot;already_member&quot; - User already a member of this company&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation by token&#10;        invitation = await crud_invitation.get_invitation_by_token(db=db, token=token)&#10;&#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                data={&quot;status&quot;: &quot;invitation_expired&quot;}&#10;            )&#10;&#10;        # Check if user exists with this email&#10;        existing_user = await crud_user.get_by_email(db=db, email=invitation.email)&#10;&#10;        if not existing_user:&#10;            # User doesn't exist - return status for UI to show signup form&#10;            return DataResponse.success_response(&#10;                message=&quot;Email not registered. Please sign up.&quot;,&#10;                status_code=status.HTTP_200_OK,&#10;                data={&#10;                    &quot;status&quot;: &quot;user_not_found&quot;,&#10;                    &quot;email&quot;: invitation.email,&#10;                    &quot;company_id&quot;: str(invitation.company_id),&#10;                    &quot;role&quot;: invitation.role,&#10;                    &quot;token&quot;: token&#10;                }&#10;            )&#10;&#10;        # Check if user is already a member of this company&#10;        stmt = select(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == invitation.company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        existing_company_user = result.scalar_one_or_none()&#10;&#10;        if existing_company_user:&#10;            # User already a member&#10;            if existing_company_user.status == StatusType.active:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;User is already a member of this company&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST,&#10;                    data={&quot;status&quot;: &quot;already_member&quot;}&#10;                )&#10;            else:&#10;                # Update status to active and role based on invitation&#10;                existing_company_user.status = StatusType.active&#10;                existing_company_user.role = invitation.role&#10;                db.add(existing_company_user)&#10;&#10;                # Mark invitation as used&#10;                invitation.status = InvitationStatus.USED&#10;                invitation.updated_at = datetime.now()&#10;                db.add(invitation)&#10;                await db.commit()&#10;&#10;                return DataResponse.success_response(&#10;                    message=&quot;User successfully joined the company&quot;,&#10;                    status_code=status.HTTP_200_OK,&#10;                    data={&#10;                        &quot;status&quot;: &quot;user_exists&quot;,&#10;                        &quot;user_id&quot;: str(existing_user.id),&#10;                        &quot;email&quot;: existing_user.email,&#10;                        &quot;first_name&quot;: existing_user.first_name,&#10;                        &quot;last_name&quot;: existing_user.last_name,&#10;                        &quot;company_id&quot;: str(invitation.company_id),&#10;                        &quot;role&quot;: invitation.role,&#10;                        &quot;message&quot;: &quot;Rejoined the company&quot;&#10;                    }&#10;                )&#10;&#10;        # User exists but not yet a member - add them to company&#10;        company_user = CompanyUsers(&#10;            id=uuid.uuid4(),&#10;            user_id=existing_user.id,&#10;            company_id=invitation.company_id,&#10;            role=invitation.role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;&#10;        # Mark invitation as used&#10;        # invitation.status = InvitationStatus.USED&#10;        invitation.updated_at = datetime.now()&#10;        db.add(invitation)&#10;        await db.commit()&#10;&#10;        # User exists and has been added to company&#10;        return DataResponse.success_response(&#10;            message=&quot;Registered user added to company successfully&quot;,&#10;            status_code=status.HTTP_200_OK,&#10;            data={&#10;                &quot;status&quot;: &quot;user_exists&quot;,&#10;                &quot;user_id&quot;: str(existing_user.id),&#10;                &quot;email&quot;: existing_user.email,&#10;                &quot;first_name&quot;: existing_user.first_name,&#10;                &quot;last_name&quot;: existing_user.last_name,&#10;                &quot;company_id&quot;: str(invitation.company_id),&#10;                &quot;role&quot;: invitation.role,&#10;                &quot;message&quot;: &quot;User joined the company&quot;&#10;            }&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to process invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;" />
              <option name="updatedContent" value="import uuid&#10;from typing import List&#10;from datetime import date, timedelta, datetime&#10;from fastapi import APIRouter, Depends, HTTPException, status, Query, Response, File, UploadFile&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy import select&#10;from app.api.dependencies import (&#10;    get_current_active_user,&#10;    get_current_active_customer,&#10;    get_current_company_id,&#10;    require_admin_or_owner,&#10;    require_owner,&#10;    require_staff_or_higher,&#10;    get_current_user_role&#10;)&#10;from app.db.session import get_db&#10;from app.models import CompanyAddresses&#10;from app.models.models import Users, CompanyUsers&#10;from app.models.enums import CompanyRoleType, StatusType, InvitationStatus&#10;from app.schemas import (&#10;    CompanyCreate, User, Company, AvailabilityResponse, AvailabilityType, CompanyUser, CompanyUserUpdate,&#10;    CategoryServiceResponse, CompanyCategoryWithServicesResponse, Customer, TimeOff, CompanyUpdate,&#10;    CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, CompanyPhone, UserCreate,&#10;    Invitation, InvitationCreate, InvitationAccept, CompanyAddressResponse, CompanyAddressCreate, CompanyCustomer&#10;)&#10;from app.schemas.responses import DataResponse&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import customer as crud_customer&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import user_availability as crud_user_availability&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_user_time_off&#10;from app.services.crud import invitation as crud_invitation&#10;from app.services.email_service import email_service&#10;from app.services.auth import hash_password&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Company], status_code=status.HTTP_201_CREATED)&#10;async def create_company(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_in: CompanyCreate,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new company.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.create(db=db, obj_in=company_in, current_user=current_user)&#10;    return DataResponse.success_response(&#10;        data=company,&#10;        message=&quot;Company created successfully&quot;,&#10;        status_code=status.HTTP_201_CREATED&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}/users/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        service_ids: List[str] = Query(None, description=&quot;List of service IDs to calculate availability based on combined service duration&quot;),&#10;        response: Response,&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;&#10;    If service_ids are provided, the last available slot will be calculated based on the total duration of all services.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get company to access timezone setting&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Company not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        company_timezone = company.timezone or &quot;UTC&quot;&#10;        &#10;        # Calculate total service duration if service_ids are provided&#10;        service_duration_minutes = None&#10;        if service_ids:&#10;            total_duration = 0&#10;            for service_id in service_ids:&#10;                service = await crud_service.get_service(db=db, service_id=service_id, company_id=company_id)&#10;                if service:&#10;                    total_duration += service.duration&#10;            service_duration_minutes = total_duration if total_duration &gt; 0 else None&#10;&#10;        # Get user's regular availability&#10;        availabilities = await crud_company.get_company_user_availabilities(db, user_id=user_id, company_id=company_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_200_OK&#10;            return DataResponse.success_response(&#10;                data=AvailabilityResponse(&#10;                    user_id=None,&#10;                    availability_type=availability_type,&#10;                    daily=None&#10;                ),&#10;                message=&quot;No availability schedule found for this user&quot;&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = await crud_company.get_company_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = await crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, existing bookings, and service duration&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from,&#10;                service_duration_minutes=service_duration_minutes,&#10;                company_timezone=company_timezone&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/{company_id}/availabilities&quot;, response_model=DataResponse[list[AvailabilityResponse]])&#10;async def get_company_all_users_availabilities(&#10;        *,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[list[AvailabilityResponse]]:&#10;    &quot;&quot;&quot;&#10;    Get availabilities for all users for a specific time range. Optimized to fetch all data in bulk and group bookings by user via BookingServices.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get company to access timezone setting&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Company not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        company_timezone = company.timezone or &quot;UTC&quot;&#10;        &#10;        company_users = await crud_company.get_company_users(db, company_id)&#10;        if not company_users:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No users found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        # Bulk fetch all related data&#10;        availabilities = await crud_company.get_company_all_users_availabilities(db, company_id)&#10;        time_offs = await crud_company.get_company_all_users_time_offs(&#10;            db,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        booking_tuples = await crud_booking.get_all_bookings_in_range(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        # Group data by user&#10;        avail_map = {}&#10;        for a in availabilities:&#10;            avail_map.setdefault(str(a.user_id), []).append(a)&#10;        timeoff_map = {}&#10;        for t in time_offs:&#10;            timeoff_map.setdefault(str(t.user_id), []).append(t)&#10;        booking_map = {}&#10;        for booking, user_id in booking_tuples:&#10;            booking_map.setdefault(str(user_id), []).append(booking)&#10;        results = []&#10;        for user in company_users:&#10;            user_id = str(user.user_id)&#10;            user_avails = avail_map.get(user_id, [])&#10;            if not user_avails:&#10;                continue&#10;            user_timeoffs = timeoff_map.get(user_id, [])&#10;            user_bookings = booking_map.get(user_id, [])&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=user_avails,&#10;                time_offs=user_timeoffs,&#10;                bookings=user_bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from,&#10;                company_timezone=company_timezone&#10;            )&#10;            results.append(availability)&#10;        if not results:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availabilities found for any user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        return DataResponse.success_response(&#10;            data=results,&#10;            message=&quot;Availabilities retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availabilities: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/users&quot;, response_model=DataResponse[List[CompanyUser]])&#10;async def get_company_users(&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can list staff&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all staff/users in the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        return DataResponse.error_response(&#10;            message=&quot;No company associated with the current user&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;    users = await crud_company.get_company_users(&#10;        db=db, company_id=company_id&#10;    )&#10;    return DataResponse.success_response(&#10;        data=users,&#10;        message=&quot;Company users retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;/services&quot;, response_model=DataResponse[List[CompanyCategoryWithServicesResponse]])&#10;async def get_company_services(&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all businesses owned by the authenticated professional.&#10;    &quot;&quot;&quot;&#10;    services = await crud_service.get_company_services(&#10;        db=db, company_id=company_id&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=services,&#10;        message=&quot;Company services retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/customers', response_model=DataResponse[List[CompanyCustomer]])&#10;async def get_company_customers(&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)  # Staff and above can view customers&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all customers who have bookings with the company.&#10;    Requires staff, admin, or owner role.&#10;    &quot;&quot;&quot;&#10;    customers = await crud_customer.get_company_customers(&#10;        db=db, company_id=company_id&#10;    )&#10;    customers = [Customer.model_validate(customer) for customer in customers]&#10;    return DataResponse.success_response(&#10;        data=customers,&#10;        message=&quot;Company customers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/user-time-offs', response_model=DataResponse[List[TimeOff]])&#10;async def get_company_user_time_offs(&#10;        db: AsyncSession = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all user time offs for the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    start_date = date_from&#10;    end_date = date_from + timedelta(&#10;        days=1 if availability_type == AvailabilityType.DAILY else&#10;        7 if availability_type == AvailabilityType.WEEKLY else 31&#10;    )&#10;    time_offs = await crud_user_time_off.get_company_user_time_offs(&#10;        db=db, company_id=company_id, start_date=start_date, end_date=end_date&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=time_offs,&#10;        message=&quot;Company user time offs retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[Company])&#10;async def get_company(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}&quot;, response_model=DataResponse[Company])&#10;async def get_company_by_id(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;&#10;@router.get(&quot;/slug/{slug}&quot;, response_model=DataResponse[Company])&#10;async def get_company_by_slug(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    slug: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get_by_slug(db=db, slug=slug)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;@router.get(&quot;/{company_id}/address&quot;, response_model=DataResponse[CompanyAddressResponse])&#10;async def get_company_address(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get the company's address by company_id.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        stmt = select(CompanyAddresses).filter(&#10;            CompanyAddresses.company_id == company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        address = result.scalar_one_or_none()&#10;&#10;        if not address:&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Company address not found&quot;&#10;            )&#10;&#10;        # Convert ORM object to Pydantic response schema&#10;        address_response = CompanyAddressResponse.model_validate(address)&#10;&#10;        return DataResponse.success_response(&#10;            data=address_response,&#10;            message=&quot;Company address retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve company address: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/address&quot;, response_model=DataResponse[CompanyAddressResponse], status_code=status.HTTP_201_CREATED)&#10;async def create_company_address(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    address_in: CompanyAddressCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can add address&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create or update a company address.&#10;    If an address already exists for the company, it will be updated.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if address already exists for this company&#10;        stmt = select(CompanyAddresses).filter(&#10;            CompanyAddresses.company_id == company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        existing_address = result.scalar_one_or_none()&#10;&#10;        if existing_address:&#10;            # Update existing address&#10;            for field, value in address_in.model_dump(exclude_unset=True).items():&#10;                setattr(existing_address, field, value)&#10;            existing_address.updated_at = datetime.now()&#10;            db.add(existing_address)&#10;            await db.commit()&#10;            await db.refresh(existing_address)&#10;&#10;            return DataResponse.success_response(&#10;                data=CompanyAddressResponse.model_validate(existing_address),&#10;                message=&quot;Company address updated successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            # Create new address&#10;            new_address = CompanyAddresses(&#10;                id=uuid.uuid4(),&#10;                company_id=company_id,&#10;                **address_in.model_dump()&#10;            )&#10;            db.add(new_address)&#10;            await db.commit()&#10;            await db.refresh(new_address)&#10;&#10;            return DataResponse.success_response(&#10;                data=CompanyAddressResponse.model_validate(new_address),&#10;                message=&quot;Company address created successfully&quot;,&#10;                status_code=status.HTTP_201_CREATED&#10;            )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to save company address: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.patch(&quot;&quot;, response_model=DataResponse[Company])&#10;async def update_company(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_in: CompanyUpdate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can update company&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update company information.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;&#10;    try:&#10;        updated_company = await crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=company_in&#10;        )&#10;        return DataResponse.success_response(&#10;            data=updated_company,&#10;            message=&quot;Company information updated successfully&quot;&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company information: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/logo&quot;, response_model=DataResponse[dict])&#10;async def upload_company_logo(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    file: UploadFile = File(...),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can upload logo&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Upload company logo to S3 and update company record.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Validate file type&#10;        allowed_types = [&quot;image/jpeg&quot;, &quot;image/png&quot;, &quot;image/jpg&quot;, &quot;image/webp&quot;]&#10;        if file.content_type not in allowed_types:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invalid file type. Only JPEG, PNG, and WebP are allowed&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Validate file size (e.g., max 5MB)&#10;        file_content = await file.read()&#10;        if len(file_content) &gt; 5 * 1024 * 1024:&#10;            return DataResponse.error_response(&#10;                message=&quot;File size exceeds 5MB limit&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Upload to S3&#10;        from app.services.file_storage import file_storage_service&#10;        logo_url = await file_storage_service.upload_file(&#10;            file_content=file_content,&#10;            file_name=f&quot;companies/{company_id}/logo.{file.filename.split('.')[-1]}&quot;,&#10;            content_type=file.content_type&#10;        )&#10;&#10;        # Update company record&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Company not found&quot;&#10;            )&#10;&#10;        _ = await crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=CompanyUpdate(logo_url=logo_url)&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Company logo uploaded successfully&quot;,&#10;            data={&quot;logo_url&quot;: logo_url}&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to upload company logo: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/logo&quot;, response_model=DataResponse)&#10;async def delete_company_logo(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can delete logo&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete company logo and update company record.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get company&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Company not found&quot;&#10;            )&#10;&#10;        # Update company record to remove logo&#10;        _ = await crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=CompanyUpdate(logo_url=None)&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Company logo deleted successfully&quot;&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to delete company logo: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/emails&quot;, response_model=DataResponse, status_code=status.HTTP_201_CREATED)&#10;async def add_company_email(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    email_in: CompanyEmailCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add a new email address to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        email_in.company_id = company_id&#10;        await crud_company.create_company_email(db=db, obj_in=email_in)&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Emails added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add emails: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/emails&quot;, response_model=DataResponse[List[CompanyEmail]])&#10;async def get_company_emails(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all email addresses associated with the company.&#10;    &quot;&quot;&quot;&#10;    emails = await crud_company.get_company_emails(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=emails,&#10;        message=&quot;Company emails retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/emails/{email_id}&quot;, response_model=DataResponse)&#10;async def delete_company_email(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    email_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete an email address from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = await crud_company.delete_company_email(db=db, email_id=email_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Email not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Email deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/phones&quot;, response_model=DataResponse[List[CompanyPhone]], status_code=status.HTTP_201_CREATED)&#10;async def add_company_phone(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    phone_in: CompanyPhoneCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add new phone numbers to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Set the company ID from the authenticated user's context&#10;        phone_in.company_id = company_id&#10;        phones = await crud_company.create_company_phone(db=db, obj_in=phone_in)&#10;&#10;        return DataResponse.success_response(&#10;            data=phones,&#10;            message=&quot;Phone numbers added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add phone numbers: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/phones&quot;, response_model=DataResponse[List[CompanyPhone]])&#10;async def get_company_phones(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers associated with the company.&#10;    &quot;&quot;&quot;&#10;    phones = await crud_company.get_company_phones(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=phones,&#10;        message=&quot;Company phone numbers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/phones/{phone_id}&quot;, response_model=DataResponse)&#10;async def delete_company_phone(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    phone_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a phone number from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = await crud_company.delete_company_phone(db=db, phone_id=phone_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Phone number not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Phone number deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;@router.post(&quot;/members&quot;, response_model=DataResponse[CompanyUser], status_code=status.HTTP_201_CREATED)&#10;async def add_company_member(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    user_in: UserCreate,&#10;    role: CompanyRoleType = Query(..., description=&quot;Role to assign to the user in the company&quot;),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can add members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to the company with a specified role.&#10;    If a user with the email already exists, they will be added to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_user = await crud_company.create_company_member(&#10;            db=db,&#10;            user_in=user_in,&#10;            company_id=company_id,&#10;            role=role&#10;        )&#10;        return DataResponse.success_response(&#10;            data=company_user,&#10;            message=&quot;Member added to company successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add member to company: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/members/{user_id}&quot;, response_model=DataResponse[CompanyUser])&#10;async def update_company_member(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    user_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_update: CompanyUserUpdate,&#10;    _: None = Depends(require_admin_or_owner)  # Only admin or owner can update members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update a company member's role or status.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Validate that the update data is not empty&#10;        update_data = user_update.model_dump(exclude_unset=True)&#10;        if not update_data:&#10;            return DataResponse.error_response(&#10;                message=&quot;No fields to update&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the company user&#10;        updated_company_user = await crud_company.update_company_user(&#10;            db=db,&#10;            company_id=company_id,&#10;            user_id=user_id,&#10;            obj_in=user_update&#10;        )&#10;&#10;        if not updated_company_user:&#10;            return DataResponse.error_response(&#10;                message=&quot;Company user not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=updated_company_user,&#10;            message=&quot;Company member updated successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company member&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/members/{user_id}&quot;, response_model=DataResponse)&#10;async def remove_company_member(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    user_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    _: None = Depends(require_admin_or_owner)  # Only admin or owner can remove members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Remove a member from the company (soft delete by setting status to inactive).&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if the user exists in the company first&#10;        existing_user = await crud_company.get_company_user(db=db, company_id=company_id, user_id=user_id)&#10;        if not existing_user:&#10;            return DataResponse.error_response(&#10;                message=&quot;Company user not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Remove the user from the company&#10;        success = await crud_company.delete_company_user(&#10;            db=db,&#10;            company_id=company_id,&#10;            user_id=user_id&#10;        )&#10;&#10;        if not success:&#10;            return DataResponse.error_response(&#10;                message=&quot;Failed to remove user from company&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Company member removed successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to remove company member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;# ============== STAFF INVITATION ENDPOINTS ==============&#10;&#10;@router.post(&quot;/invitations&quot;, response_model=DataResponse[Invitation], status_code=status.HTTP_201_CREATED)&#10;async def invite_staff_member(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    invitation_in: InvitationCreate,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Invite a staff member to the company.&#10;&#10;    If the invited email is not registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with sign-up link&#10;&#10;    If the invited email is already registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with acceptance link&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if email is already registered&#10;        existing_user = await crud_user.get_by_email(db=db, email=invitation_in.email.lower())&#10;        is_existing_user = existing_user is not None&#10;&#10;        # Set default role to staff if not provided&#10;        role = invitation_in.role or CompanyRoleType.staff&#10;&#10;        # Create invitation&#10;        invitation = await crud_invitation.create_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation_in.email.lower(),&#10;            role=role&#10;        )&#10;&#10;        # Get company details for email&#10;        company = await crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                detail=&quot;Company not found&quot;&#10;            )&#10;&#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=invitation.email,&#10;            invitation_token=invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;&#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation created but failed to send email. Please try again.&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(invitation),&#10;            message=&quot;Staff member invited successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to invite staff member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/accept&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def accept_invitation(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    invitation_in: InvitationAccept,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Accept a staff invitation.&#10;&#10;    If the user doesn't exist (new user):&#10;    - Create user account with provided details&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role&#10;    - Activate company_users record&#10;&#10;    If the user already exists (existing user):&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role (or update if already exists)&#10;    - Activate company_users record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation&#10;        invitation = await crud_invitation.get_invitation_by_token(db=db, token=invitation_in.token)&#10;&#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if user exists&#10;        existing_user = await crud_user.get_by_email(db=db, email=invitation.email)&#10;&#10;        if not existing_user:&#10;            # Create new user&#10;            if not invitation_in.password:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;Password is required for new user registration&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST&#10;                )&#10;&#10;            # Hash password&#10;            hashed_password = hash_password(invitation_in.password)&#10;&#10;            # Create user&#10;            user_create_data = {&#10;                &quot;first_name&quot;: invitation_in.first_name,&#10;                &quot;last_name&quot;: invitation_in.last_name,&#10;                &quot;email&quot;: invitation.email,&#10;                &quot;password&quot;: hashed_password,&#10;                &quot;phone&quot;: invitation_in.phone&#10;            }&#10;&#10;            from app.schemas.schemas import UserCreate as UserCreateSchema&#10;            user_in = UserCreateSchema(**user_create_data)&#10;            new_user = await crud_user.create(db=db, obj_in=user_in)&#10;            user_id = new_user.id&#10;        else:&#10;            # Use existing user&#10;            user_id = existing_user.id&#10;&#10;        # Accept invitation (mark as USED and add to company)&#10;        await crud_invitation.accept_invitation(&#10;            db=db,&#10;            invitation=invitation,&#10;            user_id=user_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Invitation accepted successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to accept invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/{token}/resend&quot;, response_model=DataResponse[Invitation])&#10;async def resend_invitation(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    token: str,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation to a staff member.&#10;&#10;    This generates a new token and resets the invitation to PENDING status.&#10;    Only works for expired or pending invitations.&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.models import Invitations&#10;&#10;        # Get the invitation by current token using select&#10;        stmt = select(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.company_id == company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        invitation = result.scalar_one_or_none()&#10;&#10;        if not invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Resend invitation&#10;        resent_invitation = await crud_invitation.resend_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation.email&#10;        )&#10;&#10;        if not resent_invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or cannot be resent&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get company details for email&#10;        company = await crud_company.get(db=db, id=company_id)&#10;&#10;        # Check if user exists for email&#10;        existing_user = await crud_user.get_by_email(db=db, email=resent_invitation.email)&#10;        is_existing_user = existing_user is not None&#10;&#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=resent_invitation.email,&#10;            invitation_token=resent_invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;&#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation updated but failed to send email&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;&#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(resent_invitation),&#10;            message=&quot;Invitation resent successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to resend invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/all/invitations&quot;, response_model=DataResponse[List[Invitation]])&#10;async def get_company_invitations(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id),&#10;    status_filter: str = Query(None, description=&quot;Filter by status: pending, used, expired, declined&quot;),&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company.&#10;&#10;    Optional status filter: pending, used, expired, declined&#10;&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.enums import InvitationStatus&#10;&#10;        # Parse status filter&#10;        status_enum = None&#10;        if status_filter:&#10;            status_enum = InvitationStatus(status_filter.upper())&#10;&#10;        invitations = await crud_invitation.get_company_invitations(&#10;            db=db,&#10;            company_id=company_id,&#10;            status=status_enum&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=[Invitation.model_validate(inv) for inv in invitations],&#10;            message=&quot;Company invitations retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;&#10;    except ValueError:&#10;        return DataResponse.error_response(&#10;            message=&quot;Invalid status filter&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve invitations: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/{token}/check-and-join&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def check_invitation_and_join(&#10;    *,&#10;    db: AsyncSession = Depends(get_db),&#10;    token: str,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Check if the email from invitation is registered.&#10;    If registered, add user to company and return status.&#10;    If not registered, return different status so UI knows to show signup form.&#10;&#10;    Returns:&#10;    - status: &quot;user_exists&quot; - User is registered, added to company, ready to accept&#10;    - status: &quot;user_not_found&quot; - User not registered, show signup form&#10;    - status: &quot;invitation_expired&quot; - Invitation has expired&#10;    - status: &quot;already_member&quot; - User already a member of this company&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation by token&#10;        invitation = await crud_invitation.get_invitation_by_token(db=db, token=token)&#10;&#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                data={&quot;status&quot;: &quot;invitation_expired&quot;}&#10;            )&#10;&#10;        # Check if user exists with this email&#10;        existing_user = await crud_user.get_by_email(db=db, email=invitation.email)&#10;&#10;        if not existing_user:&#10;            # User doesn't exist - return status for UI to show signup form&#10;            return DataResponse.success_response(&#10;                message=&quot;Email not registered. Please sign up.&quot;,&#10;                status_code=status.HTTP_200_OK,&#10;                data={&#10;                    &quot;status&quot;: &quot;user_not_found&quot;,&#10;                    &quot;email&quot;: invitation.email,&#10;                    &quot;company_id&quot;: str(invitation.company_id),&#10;                    &quot;role&quot;: invitation.role,&#10;                    &quot;token&quot;: token&#10;                }&#10;            )&#10;&#10;        # Check if user is already a member of this company&#10;        stmt = select(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == invitation.company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        existing_company_user = result.scalar_one_or_none()&#10;&#10;        if existing_company_user:&#10;            # User already a member&#10;            if existing_company_user.status == StatusType.active:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;User is already a member of this company&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST,&#10;                    data={&quot;status&quot;: &quot;already_member&quot;}&#10;                )&#10;            else:&#10;                # Update status to active and role based on invitation&#10;                existing_company_user.status = StatusType.active&#10;                existing_company_user.role = invitation.role&#10;                db.add(existing_company_user)&#10;&#10;                # Mark invitation as used&#10;                invitation.status = InvitationStatus.USED&#10;                invitation.updated_at = datetime.now()&#10;                db.add(invitation)&#10;                await db.commit()&#10;&#10;                return DataResponse.success_response(&#10;                    message=&quot;User successfully joined the company&quot;,&#10;                    status_code=status.HTTP_200_OK,&#10;                    data={&#10;                        &quot;status&quot;: &quot;user_exists&quot;,&#10;                        &quot;user_id&quot;: str(existing_user.id),&#10;                        &quot;email&quot;: existing_user.email,&#10;                        &quot;first_name&quot;: existing_user.first_name,&#10;                        &quot;last_name&quot;: existing_user.last_name,&#10;                        &quot;company_id&quot;: str(invitation.company_id),&#10;                        &quot;role&quot;: invitation.role,&#10;                        &quot;message&quot;: &quot;Rejoined the company&quot;&#10;                    }&#10;                )&#10;&#10;        # User exists but not yet a member - add them to company&#10;        company_user = CompanyUsers(&#10;            id=uuid.uuid4(),&#10;            user_id=existing_user.id,&#10;            company_id=invitation.company_id,&#10;            role=invitation.role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;&#10;        # Mark invitation as used&#10;        # invitation.status = InvitationStatus.USED&#10;        invitation.updated_at = datetime.now()&#10;        db.add(invitation)&#10;        await db.commit()&#10;&#10;        # User exists and has been added to company&#10;        return DataResponse.success_response(&#10;            message=&quot;Registered user added to company successfully&quot;,&#10;            status_code=status.HTTP_200_OK,&#10;            data={&#10;                &quot;status&quot;: &quot;user_exists&quot;,&#10;                &quot;user_id&quot;: str(existing_user.id),&#10;                &quot;email&quot;: existing_user.email,&#10;                &quot;first_name&quot;: existing_user.first_name,&#10;                &quot;last_name&quot;: existing_user.last_name,&#10;                &quot;company_id&quot;: str(invitation.company_id),&#10;                &quot;role&quot;: invitation.role,&#10;                &quot;message&quot;: &quot;User joined the company&quot;&#10;            }&#10;        )&#10;&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to process invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/public.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/public.py" />
              <option name="originalContent" value="import json&#10;import uuid&#10;from collections import defaultdict&#10;from datetime import datetime, timezone, date, timedelta&#10;from typing import List&#10;from pydantic.v1 import UUID4&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query&#10;from sqlalchemy import select&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy.orm import Session, selectinload&#10;&#10;from app.db.session import get_db&#10;from app.models import NotificationType&#10;from app.schemas import CompanyNotificationCreate&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import Booking, BookingCreate, AvailabilityResponse, CustomerCreate&#10;from app.schemas.schemas import (CompanyCategoryWithServicesResponse, CompanyUser, AvailabilityType)&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import customer as crud_customer&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_availability as crud_user_availability&#10;from app.services.email_service import email_service&#10;from app.services.notification_service import notification_service&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.get(&quot;/companies/{company_slug}/services&quot;, response_model=DataResponse[List[CompanyCategoryWithServicesResponse]])&#10;async def get_company_services(&#10;    company_slug: str,&#10;    db: AsyncSession = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get service by company ID with details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get_by_slug(db=db, slug=company_slug)&#10;    if not company:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            detail=&quot;Company not found&quot;&#10;        )&#10;    company_id = str(company.id)&#10;    services = await crud_service.get_company_services(db=db, company_id=company_id)&#10;    if not services:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            detail=&quot;Service not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=services,&#10;        message=&quot;Services fetched successfully&quot;&#10;    )&#10;&#10;&#10;@router.get(&quot;/companies/{company_slug}/staff&quot;, response_model=DataResponse[List[CompanyUser]])&#10;async def get_company_users(&#10;    company_slug: str,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get users by company ID with details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get_by_slug(db=db, slug=company_slug)&#10;    if not company:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            detail=&quot;Company not found&quot;&#10;        )&#10;    company_id = str(company.id)&#10;    users = await crud_user.get_company_users(db=db, company_id=company_id)&#10;    if not users:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            detail=&quot;Service not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=users,&#10;        message=&quot;Services fetched successfully&quot;&#10;    )&#10;&#10;&#10;@router.get(&quot;/companies/{company_slug}/users/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        service_ids: List[str] = Query(None, description=&quot;List of service IDs to calculate availability based on combined service duration&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_slug: str&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;&#10;    If service_ids are provided, the last available slot will be calculated based on the total duration of all services.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company = await crud_company.get_by_slug(db=db, slug=company_slug)&#10;        if not company:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Company not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        company_id = str(company.id)&#10;        company_timezone = company.timezone or &quot;UTC&quot;&#10;&#10;        # Calculate total service duration if service_ids are provided&#10;        service_duration_minutes = None&#10;        if service_ids:&#10;            total_duration = 0&#10;            for service_id in service_ids:&#10;                service = await crud_service.get_service(db=db, service_id=service_id, company_id=company_id)&#10;                if service:&#10;                    total_duration += service.duration&#10;            service_duration_minutes = total_duration if total_duration &gt; 0 else None&#10;&#10;        # Get user's regular availability&#10;        availabilities = await crud_company.get_company_user_availabilities(db, user_id=user_id, company_id=company_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_200_OK&#10;            return DataResponse.success_response(&#10;                data=AvailabilityResponse(&#10;                    user_id=None,&#10;                    availability_type=availability_type,&#10;                    daily=None&#10;                ),&#10;                message=&quot;No availability schedule found for this user&quot;&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = await crud_company.get_company_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = await crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, existing bookings, and service duration&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from,&#10;                service_duration_minutes=service_duration_minutes,&#10;                company_timezone=company_timezone&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;&#10;@router.post(&quot;/companies/{company_slug}/bookings&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;async def create_booking(&#10;        *,&#10;        db: AsyncSession = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        company_slug: str,&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;&#10;    # Verify that the company exists&#10;    selected_company = await crud_company.get_by_slug(db=db, slug=company_slug)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    booking_in.company_id = str(selected_company.id)&#10;&#10;    # If no valid customer found, create a new inactive one&#10;    if not customer:&#10;        # For unregistered customers, we need customer_info in the booking_in&#10;        if not booking_in.customer_info:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Customer information required for unregistered booking&quot;&#10;            )&#10;        if booking_in.customer_info.id:&#10;            # If customer_info contains an ID, try to fetch that customer&#10;            existing_customer = await crud_customer.get(db, id=booking_in.customer_info.id)&#10;            if existing_customer:&#10;                customer = existing_customer&#10;            else:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                raise DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;Customer with provided ID not found&quot;&#10;                )&#10;            # If we found the customer by ID, we can skip creating a new one&#10;            booking_in.customer_info = None  # Clear to avoid confusion later&#10;&#10;        # Create a new customer from the provided information&#10;        if booking_in.customer_info:&#10;            customer_data = CustomerCreate(&#10;                first_name=booking_in.customer_info.first_name,&#10;                last_name=booking_in.customer_info.last_name,&#10;                email=booking_in.customer_info.email,&#10;                phone=booking_in.customer_info.phone,&#10;                password=str(uuid.uuid4())  # Random password for inactive account&#10;            )&#10;&#10;            # Check if customer with this email already exists&#10;            existing_customer = await crud_customer.get_by_email(db, email=str(customer_data.email))&#10;            if existing_customer:&#10;                customer = existing_customer&#10;            else:&#10;                customer = await crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;    selected_company_users = defaultdict(list)&#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = await crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        if selected_company_service.user_id:&#10;            selected_user = await crud_user.get(db=db, id=selected_company_service.user_id)&#10;            if not selected_user:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                raise DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;User not found or doesn't belong to this company&quot;&#10;                )&#10;            selected_company_users[selected_user[0].id].append((selected_user[0], company_service))&#10;&#10;    try:&#10;        booking = await crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        # publish_event('booking_created', str({'info': f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;}))&#10;&#10;        # Create confirmation notification for the assigned staff member&#10;        booking_data = json.dumps({&#10;            'booking_id': str(booking.id),&#10;            'company_id': str(booking.company_id)&#10;        }).encode('utf-8')&#10;&#10;        _ = await notification_service.create_notification(&#10;            db=db,&#10;            notification_request=CompanyNotificationCreate(&#10;                company_id=booking_in.company_id,&#10;                type=NotificationType.BOOKING_CREATED,&#10;                message=f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;,&#10;                data=booking_data&#10;            )&#10;        )&#10;&#10;        # Get company address for calendar location&#10;        from app.models.models import CompanyAddresses&#10;        stmt = (select(CompanyAddresses)&#10;                .filter(CompanyAddresses.company_id == selected_company.id))&#10;&#10;        result = await db.execute(stmt)&#10;        company_address = result.first()&#10;        location = None&#10;        if company_address:&#10;            location = f&quot;{company_address.address}, {company_address.city}, {company_address.country}&quot;&#10;            if company_address.zip:&#10;                location = f&quot;{company_address.address}, {company_address.city}, {company_address.zip}, {company_address.country}&quot;&#10;&#10;        _ = email_service.send_booking_confirmation_to_customer_email(&#10;            to_email=customer.email,&#10;            customer_name=customer.first_name,&#10;            company_name=selected_company.name,&#10;            booking_date=booking.start_at.isoformat(),&#10;            services=[service.category_service.name for service in booking.booking_services],&#10;            start_datetime=booking.start_at,&#10;            end_datetime=booking.end_at,&#10;            booking_id=booking.id,&#10;            location=location&#10;        )&#10;&#10;        for user_id, item in selected_company_users.items():&#10;            selected_service_names = []&#10;            company_user = item[0][0]&#10;            for user, company_service in item:&#10;                selected_service_names.append(company_service.name)&#10;            # Send email notification to assigned staff member&#10;            _ = email_service.send_booking_request_to_business_email(&#10;                to_email=company_user.email,&#10;                staff_name=company_user.first_name,&#10;                customer_name=booking_in.customer_info.first_name + ' ' + booking_in.customer_info.last_name,&#10;                company_name=selected_company.name,&#10;                booking_date=booking.start_at.isoformat(),&#10;                services=selected_service_names,&#10;                booking_notes=booking_in.notes,&#10;                booking_id=booking.id&#10;            )&#10;&#10;        await db.commit()&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;&#10;@router.get(&quot;/bookings/{booking_id}&quot;, response_model=DataResponse[Booking])&#10;async def get_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get booking by ID with details.&#10;    &quot;&quot;&quot;&#10;    booking_id = UUID4(booking_id)&#10;    booking = await crud_booking.get(db=db, id=booking_id)&#10;    if not booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;    response.status_code = status.HTTP_200_OK&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=booking,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;" />
              <option name="updatedContent" value="import json&#10;import uuid&#10;from collections import defaultdict&#10;from datetime import datetime, timezone, date, timedelta&#10;from typing import List&#10;from pydantic.v1 import UUID4&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query&#10;from sqlalchemy import select&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy.orm import Session, selectinload&#10;&#10;from app.db.session import get_db&#10;from app.models import NotificationType&#10;from app.schemas import CompanyNotificationCreate&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import Booking, BookingCreate, AvailabilityResponse, CustomerCreate&#10;from app.schemas.schemas import (CompanyCategoryWithServicesResponse, CompanyUser, AvailabilityType)&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import customer as crud_customer&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_availability as crud_user_availability&#10;from app.services.email_service import email_service&#10;from app.services.notification_service import notification_service&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.get(&quot;/companies/{company_slug}/services&quot;, response_model=DataResponse[List[CompanyCategoryWithServicesResponse]])&#10;async def get_company_services(&#10;    company_slug: str,&#10;    db: AsyncSession = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get service by company ID with details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get_by_slug(db=db, slug=company_slug)&#10;    if not company:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            detail=&quot;Company not found&quot;&#10;        )&#10;    company_id = str(company.id)&#10;    services = await crud_service.get_company_services(db=db, company_id=company_id)&#10;    if not services:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            detail=&quot;Service not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=services,&#10;        message=&quot;Services fetched successfully&quot;&#10;    )&#10;&#10;&#10;@router.get(&quot;/companies/{company_slug}/staff&quot;, response_model=DataResponse[List[CompanyUser]])&#10;async def get_company_users(&#10;    company_slug: str,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get users by company ID with details.&#10;    &quot;&quot;&quot;&#10;    company = await crud_company.get_by_slug(db=db, slug=company_slug)&#10;    if not company:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            detail=&quot;Company not found&quot;&#10;        )&#10;    company_id = str(company.id)&#10;    users = await crud_user.get_company_users(db=db, company_id=company_id)&#10;    if not users:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            detail=&quot;Service not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=users,&#10;        message=&quot;Services fetched successfully&quot;&#10;    )&#10;&#10;&#10;@router.get(&quot;/companies/{company_slug}/users/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        service_ids: List[str] = Query(None, description=&quot;List of service IDs to calculate availability based on combined service duration&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_slug: str&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;&#10;    If service_ids are provided, the last available slot will be calculated based on the total duration of all services.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company = await crud_company.get_by_slug(db=db, slug=company_slug)&#10;        if not company:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Company not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        company_id = str(company.id)&#10;        company_timezone = company.timezone or &quot;UTC&quot;&#10;&#10;        # Calculate total service duration if service_ids are provided&#10;        service_duration_minutes = None&#10;        if service_ids:&#10;            total_duration = 0&#10;            for service_id in service_ids:&#10;                service = await crud_service.get_service(db=db, service_id=service_id, company_id=company_id)&#10;                if service:&#10;                    total_duration += service.duration&#10;            service_duration_minutes = total_duration if total_duration &gt; 0 else None&#10;&#10;        # Get user's regular availability&#10;        availabilities = await crud_company.get_company_user_availabilities(db, user_id=user_id, company_id=company_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_200_OK&#10;            return DataResponse.success_response(&#10;                data=AvailabilityResponse(&#10;                    user_id=None,&#10;                    availability_type=availability_type,&#10;                    daily=None&#10;                ),&#10;                message=&quot;No availability schedule found for this user&quot;&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = await crud_company.get_company_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = await crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, existing bookings, and service duration&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from,&#10;                service_duration_minutes=service_duration_minutes,&#10;                company_timezone=company_timezone&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;&#10;@router.post(&quot;/companies/{company_slug}/bookings&quot;, response_model=DataResponse[Booking], status_code=status.HTTP_201_CREATED)&#10;async def create_booking(&#10;        *,&#10;        db: AsyncSession = Depends(get_db),&#10;        booking_in: BookingCreate,&#10;        company_slug: str,&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new booking for both registered and unregistered customers.&#10;    If customer is registered (token provided), use that customer.&#10;    If not, create a new inactive customer using provided customer_info.&#10;    &quot;&quot;&quot;&#10;    # Try to get customer from token if provided&#10;    customer = None&#10;&#10;    # Verify that the company exists&#10;    selected_company = await crud_company.get_by_slug(db=db, slug=company_slug)&#10;    if not selected_company:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    booking_in.company_id = str(selected_company.id)&#10;&#10;    # If no valid customer found, create a new inactive one&#10;    if not customer:&#10;        # For unregistered customers, we need customer_info in the booking_in&#10;        if not booking_in.customer_info:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Customer information required for unregistered booking&quot;&#10;            )&#10;        if booking_in.customer_info.id:&#10;            # If customer_info contains an ID, try to fetch that customer&#10;            existing_customer = await crud_customer.get(db, id=booking_in.customer_info.id)&#10;            if existing_customer:&#10;                customer = existing_customer&#10;            else:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                raise DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;Customer with provided ID not found&quot;&#10;                )&#10;            # If we found the customer by ID, we can skip creating a new one&#10;            booking_in.customer_info = None  # Clear to avoid confusion later&#10;&#10;        # Create a new customer from the provided information&#10;        if booking_in.customer_info:&#10;            customer_data = CustomerCreate(&#10;                first_name=booking_in.customer_info.first_name,&#10;                last_name=booking_in.customer_info.last_name,&#10;                email=booking_in.customer_info.email,&#10;                phone=booking_in.customer_info.phone,&#10;                password=str(uuid.uuid4())  # Random password for inactive account&#10;            )&#10;&#10;            # Check if customer with this email already exists&#10;            existing_customer = await crud_customer.get_by_email(db, email=str(customer_data.email))&#10;            if existing_customer:&#10;                customer = existing_customer&#10;            else:&#10;                customer = await crud_customer.create(db, obj_in=customer_data)&#10;&#10;    # Validate booking times&#10;    if booking_in.start_time &lt; datetime.now(timezone.utc):&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            message=&quot;Cannot create booking in the past&quot;&#10;        )&#10;    selected_company_users = defaultdict(list)&#10;    for selected_company_service in booking_in.services:&#10;        # Verify that the service exists and belongs to the company&#10;        company_service = await crud_service.get_service(db=db, service_id=selected_company_service.category_service_id,&#10;                                                   company_id=selected_company.id)&#10;        if not company_service:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            raise DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Service not found or doesn't belong to this company&quot;&#10;            )&#10;&#10;        # Verify that the user(worker) exists and belongs to the company&#10;        if selected_company_service.user_id:&#10;            selected_user = await crud_user.get(db=db, id=selected_company_service.user_id)&#10;            if not selected_user:&#10;                response.status_code = status.HTTP_404_NOT_FOUND&#10;                raise DataResponse.error_response(&#10;                    status_code=status.HTTP_404_NOT_FOUND,&#10;                    message=&quot;User not found or doesn't belong to this company&quot;&#10;                )&#10;            selected_company_users[selected_user[0].id].append((selected_user[0], company_service))&#10;&#10;    try:&#10;        booking = await crud_booking.create(db=db, obj_in=booking_in, customer_id=customer.id)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        # publish_event('booking_created', str({'info': f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;}))&#10;&#10;        # Create confirmation notification for the assigned staff member&#10;        booking_data = json.dumps({&#10;            'booking_id': str(booking.id),&#10;            'company_id': str(booking.company_id)&#10;        }).encode('utf-8')&#10;&#10;        _ = await notification_service.create_notification(&#10;            db=db,&#10;            notification_request=CompanyNotificationCreate(&#10;                company_id=booking_in.company_id,&#10;                type=NotificationType.BOOKING_CREATED,&#10;                message=f&quot;A new booking has been created by {customer.first_name} {customer.last_name}&quot;,&#10;                data=booking_data&#10;            )&#10;        )&#10;&#10;        # Get company address for calendar location&#10;        from app.models.models import CompanyAddresses&#10;        stmt = (select(CompanyAddresses)&#10;                .filter(CompanyAddresses.company_id == selected_company.id))&#10;&#10;        result = await db.execute(stmt)&#10;        company_address = result.first()&#10;        location = None&#10;        if company_address:&#10;            location = f&quot;{company_address.address}, {company_address.city}, {company_address.country}&quot;&#10;            if company_address.zip:&#10;                location = f&quot;{company_address.address}, {company_address.city}, {company_address.zip}, {company_address.country}&quot;&#10;&#10;        _ = email_service.send_booking_confirmation_to_customer_email(&#10;            to_email=customer.email,&#10;            customer_name=customer.first_name,&#10;            company_name=selected_company.name,&#10;            booking_date=booking.start_at.isoformat(),&#10;            services=[service.category_service.name for service in booking.booking_services],&#10;            start_datetime=booking.start_at,&#10;            end_datetime=booking.end_at,&#10;            booking_id=booking.id,&#10;            location=location&#10;        )&#10;&#10;        for user_id, item in selected_company_users.items():&#10;            selected_service_names = []&#10;            company_user = item[0][0]&#10;            for user, company_service in item:&#10;                selected_service_names.append(company_service.name)&#10;            # Send email notification to assigned staff member&#10;            _ = email_service.send_booking_request_to_business_email(&#10;                to_email=company_user.email,&#10;                staff_name=company_user.first_name,&#10;                customer_name=booking_in.customer_info.first_name + ' ' + booking_in.customer_info.last_name,&#10;                company_name=selected_company.name,&#10;                booking_date=booking.start_at.isoformat(),&#10;                services=selected_service_names,&#10;                booking_notes=booking_in.notes,&#10;                booking_id=booking.id&#10;            )&#10;&#10;        await db.commit()&#10;        return DataResponse.success_response(&#10;            message=&quot;&quot;,&#10;            data=booking,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        await db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create booking: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR)&#10;&#10;&#10;&#10;@router.get(&quot;/bookings/{booking_id}&quot;, response_model=DataResponse[Booking])&#10;async def get_booking(&#10;        *,&#10;        booking_id: str,&#10;        db: AsyncSession = Depends(get_db),&#10;        response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get booking by ID with details.&#10;    &quot;&quot;&quot;&#10;    booking_id = UUID4(booking_id)&#10;    booking = await crud_booking.get(db=db, id=booking_id)&#10;    if not booking:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        raise DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Booking not found&quot;&#10;        )&#10;    response.status_code = status.HTTP_200_OK&#10;    return DataResponse.success_response(&#10;        message=&quot;&quot;,&#10;        data=booking,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/models/enums.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/models/enums.py" />
              <option name="originalContent" value="from enum import Enum&#10;&#10;&#10;class GenderType(str, Enum):&#10;    MALE = &quot;male&quot;&#10;    FEMALE = &quot;female&quot;&#10;    OTHER = &quot;other&quot;&#10;    PREFER_NOT_TO_SAY = &quot;prefer_not_to_say&quot;&#10;&#10;&#10;class StatusType(str, Enum):&#10;    active = &quot;active&quot;&#10;    inactive = &quot;inactive&quot;&#10;    suspended = &quot;suspended&quot;&#10;&#10;&#10;class EmailStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class CustomerEmailStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class PhoneStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class CompanyRoleType(str, Enum):&#10;    owner = &quot;owner&quot;&#10;    admin = &quot;admin&quot;&#10;    staff = &quot;staff&quot;&#10;    viewer = &quot;viewer&quot;&#10;&#10;class CustomerStatusType(str, Enum):&#10;    active = &quot;active&quot;&#10;    pending_verification = &quot;pending_verification&quot;&#10;    disabled = &quot;disabled&quot;&#10;&#10;class PriceType(str, Enum):&#10;    FIXED = &quot;fixed&quot;&#10;    FROM = &quot;from&quot;&#10;    FREE = &quot;free&quot;&#10;&#10;&#10;class SourceType(str, Enum):&#10;    WALK_IN = &quot;walk_in&quot;&#10;    WEBSITE = &quot;website&quot;&#10;    REFERRAL = &quot;referral&quot;&#10;    SOCIAL_MEDIA = &quot;social_media&quot;&#10;    OTHER = &quot;other&quot;&#10;&#10;&#10;class BookingStatus(str, Enum):&#10;    SCHEDULED = &quot;scheduled&quot;&#10;    CONFIRMED = &quot;confirmed&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    COMPLETED = &quot;completed&quot;&#10;    NO_SHOW = &quot;no_show&quot;&#10;&#10;class VerificationType(str, Enum):&#10;    EMAIL = &quot;email&quot;&#10;    SMS = &quot;sms&quot;&#10;    TWO_FACTOR = &quot;two_factor&quot;&#10;&#10;class VerificationStatus(str, Enum):&#10;    PENDING = &quot;pending&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;    VERIFIED = &quot;verified&quot;&#10;&#10;class AvailabilityType(str, Enum):&#10;    DAILY = &quot;daily&quot;&#10;    WEEKLY = &quot;weekly&quot;&#10;    MONTHLY = &quot;monthly&quot;&#10;&#10;&#10;class NotificationType(str, Enum):&#10;    BOOKING_CREATED = &quot;booking_created&quot;&#10;    BOOKING_CONFIRMED = &quot;booking_confirmed&quot;&#10;    BOOKING_CANCELLED = &quot;booking_cancelled&quot;&#10;    BOOKING_UPDATED = &quot;booking_updated&quot;&#10;    BOOKING_REMINDER = &quot;booking_reminder&quot;&#10;    PAYMENT_SUCCESS = &quot;payment_success&quot;&#10;    PAYMENT_FAILED = &quot;payment_failed&quot;&#10;    GENERAL = &quot;general&quot;&#10;&#10;&#10;class NotificationStatus(str, Enum):&#10;    UNREAD = &quot;unread&quot;&#10;    READ = &quot;read&quot;&#10;    ARCHIVED = &quot;archived&quot;&#10;&#10;&#10;class MembershipPlanType(str, Enum):&#10;    standard = &quot;standard&quot;&#10;    premium = &quot;premium&quot;&#10;    vip = &quot;vip&quot;&#10;    free = &quot;free&quot;&#10;&#10;class InvitationStatus(str, Enum):&#10;    PENDING = &quot;pending&quot;&#10;    USED = &quot;used&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;    DECLINED = &quot;declined&quot;&#10;" />
              <option name="updatedContent" value="from enum import Enum&#10;&#10;&#10;class GenderType(str, Enum):&#10;    MALE = &quot;male&quot;&#10;    FEMALE = &quot;female&quot;&#10;    OTHER = &quot;other&quot;&#10;    PREFER_NOT_TO_SAY = &quot;prefer_not_to_say&quot;&#10;&#10;&#10;class StatusType(str, Enum):&#10;    active = &quot;active&quot;&#10;    inactive = &quot;inactive&quot;&#10;    suspended = &quot;suspended&quot;&#10;&#10;&#10;class EmailStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class CustomerEmailStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class PhoneStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class CompanyRoleType(str, Enum):&#10;    owner = &quot;owner&quot;&#10;    admin = &quot;admin&quot;&#10;    staff = &quot;staff&quot;&#10;    viewer = &quot;viewer&quot;&#10;&#10;class CustomerStatusType(str, Enum):&#10;    active = &quot;active&quot;&#10;    pending_verification = &quot;pending_verification&quot;&#10;    disabled = &quot;disabled&quot;&#10;&#10;class PriceType(str, Enum):&#10;    FIXED = &quot;fixed&quot;&#10;    FROM = &quot;from&quot;&#10;    FREE = &quot;free&quot;&#10;&#10;&#10;class SourceType(str, Enum):&#10;    WALK_IN = &quot;walk_in&quot;&#10;    WEBSITE = &quot;website&quot;&#10;    REFERRAL = &quot;referral&quot;&#10;    SOCIAL_MEDIA = &quot;social_media&quot;&#10;    OTHER = &quot;other&quot;&#10;&#10;&#10;class BookingStatus(str, Enum):&#10;    SCHEDULED = &quot;scheduled&quot;&#10;    CONFIRMED = &quot;confirmed&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    COMPLETED = &quot;completed&quot;&#10;    NO_SHOW = &quot;no_show&quot;&#10;&#10;class VerificationType(str, Enum):&#10;    EMAIL = &quot;email&quot;&#10;    SMS = &quot;sms&quot;&#10;    TWO_FACTOR = &quot;two_factor&quot;&#10;&#10;class VerificationStatus(str, Enum):&#10;    PENDING = &quot;pending&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;    VERIFIED = &quot;verified&quot;&#10;&#10;class AvailabilityType(str, Enum):&#10;    DAILY = &quot;daily&quot;&#10;    WEEKLY = &quot;weekly&quot;&#10;    MONTHLY = &quot;monthly&quot;&#10;&#10;&#10;class NotificationType(str, Enum):&#10;    BOOKING_CREATED = &quot;booking_created&quot;&#10;    BOOKING_CONFIRMED = &quot;booking_confirmed&quot;&#10;    BOOKING_CANCELLED = &quot;booking_cancelled&quot;&#10;    BOOKING_UPDATED = &quot;booking_updated&quot;&#10;    BOOKING_REMINDER = &quot;booking_reminder&quot;&#10;    PAYMENT_SUCCESS = &quot;payment_success&quot;&#10;    PAYMENT_FAILED = &quot;payment_failed&quot;&#10;    GENERAL = &quot;general&quot;&#10;&#10;&#10;class NotificationStatus(str, Enum):&#10;    UNREAD = &quot;unread&quot;&#10;    READ = &quot;read&quot;&#10;    ARCHIVED = &quot;archived&quot;&#10;&#10;&#10;class MembershipPlanType(str, Enum):&#10;    standard = &quot;standard&quot;&#10;    premium = &quot;premium&quot;&#10;    vip = &quot;vip&quot;&#10;    free = &quot;free&quot;&#10;&#10;class InvitationStatus(str, Enum):&#10;    PENDING = &quot;pending&quot;&#10;    USED = &quot;used&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;    DECLINED = &quot;declined&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/schemas/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/schemas/schemas.py" />
              <option name="originalContent" value="from datetime import datetime, date, time, timezone&#10;from decimal import Decimal&#10;from typing import Optional, List, Annotated&#10;from pydantic import BaseModel, Field, field_validator, ConfigDict, UUID4, EmailStr&#10;&#10;from app.models import CustomerStatusType, CompanyCategories&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType, EmailStatusType, PhoneStatusType, NotificationType, NotificationStatus, CompanyRoleType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;    languages: Optional[str] = &quot;English&quot;&#10;    position: Optional[str] = 'Professional'&#10;    profile_photo_url: Optional[str] = None&#10;&#10;&#10;# User Availability schemas&#10;class UserAvailabilityBase(BaseModel):&#10;    day_of_week: int = Field(..., ge=0, le=6, description=&quot;Day of week: 0=Monday, 6=Sunday&quot;)&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool = True&#10;&#10;&#10;class UserAvailabilityCreate(UserAvailabilityBase):&#10;    pass&#10;&#10;&#10;class UserAvailabilityUpdate(BaseModel):&#10;    start_time: Optional[time] = None&#10;    end_time: Optional[time] = None&#10;    is_available: Optional[bool] = None&#10;&#10;&#10;class UserAvailability(UserAvailabilityBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = []&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;    languages: Optional[str] = None&#10;    position: Optional[str] = None&#10;    profile_photo_url: Optional[str] = None&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    company_id: Optional[UUID4] = None&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(TimestampedModel):&#10;    id: UUID4&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;&#10;    user: Optional[User] = None&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;&#10;class CompanyUserUpdate(BaseModel):&#10;    role: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    phone: Optional[str] = None&#10;    languages: Optional[str] = None&#10;    position: Optional[str] = None&#10;    profile_photo_url: Optional[str] = None&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = None&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    timezone: Optional[str] = &quot;UTC&quot;&#10;    status: StatusType = StatusType.active&#10;    slug: Optional[str] = None&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class CompanyUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    type: Optional[str] = None&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = None&#10;    timezone: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    id: Optional[UUID4] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: Optional[UUID4] = None&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: Optional[UUID4] = None&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    start_time: Optional[datetime] = None&#10;    notes: Optional[str] = None&#10;    status: Optional[BookingStatus] = None&#10;    services: Optional[List[BookingServiceRequest]] = None&#10;&#10;&#10;class ServiceStaff(BaseModel):&#10;    &quot;&quot;&quot;Schema for the service_staff junction table linking services to staff members&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;    # Optional nested user information&#10;    user: Optional['User'] = None&#10;&#10;&#10;class ServiceStaffCreate(BaseModel):&#10;    &quot;&quot;&quot;Schema for creating service-staff assignments&quot;&quot;&quot;&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;class ServiceStaffResponse(BaseModel):&#10;    &quot;&quot;&quot;Simplified response schema for staff assigned to a service&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    image_url: Optional[str] = None&#10;    service_staff: Optional[List['ServiceStaff']] = []  # List of staff assigned to this service&#10;&#10;&#10;class StaffMember(BaseModel):&#10;    &quot;&quot;&quot;Simple staff member schema for booking assignments&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class BookingService(TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    booking_id: UUID4&#10;    category_service_id: Optional[UUID4] = None  # Make optional to handle None values&#10;    user_id: Optional[UUID4] = None  # Make optional to handle None values&#10;    notes: Optional[str] = None&#10;    start_at: Optional[datetime] = None  # Changed from start_date to match DB column&#10;    end_at: Optional[datetime] = None    # Changed from end_date to match DB column&#10;&#10;    category_service: Optional[CategoryServiceResponse] = None&#10;    user: Optional[User] = None  # Changed from assigned_staff to match the model relationship&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;    customer: Optional[Customer] = None&#10;    booking_services: Optional[List[BookingService]] = []&#10;    user_ids: set[str] = set([])&#10;&#10;&#10;#&#10;class CompanyCustomer(Customer):&#10;    email_verified: bool = False&#10;    total_bookings: int = 0&#10;    total_spent: int = 0&#10;    last_visit: Optional[datetime] = None&#10;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: Optional[str]&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceBase(BaseModel):&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    image_url: Optional[str] = None&#10;&#10;class CategoryServiceCreate(CategoryServiceBase):&#10;    category_id: str&#10;    staff_ids: List[UUID4] = []  # List of staff member IDs to assign to this service&#10;&#10;class CategoryServiceUpdate(BaseModel):&#10;    category_id: Optional[str] = None  # Allow changing the category&#10;    name: Optional[str] = None&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: Optional[int] = None&#10;    price: Optional[float] = None&#10;    discount_price: Optional[float] = 0&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    buffer_before: Optional[int] = None&#10;    buffer_after: Optional[int] = None&#10;    staff_ids: Optional[List[UUID4]] = None  # List of staff member IDs to assign to this service&#10;    image_url: Optional[str] = None&#10;    remove_image: Optional[bool] = False  # Set to True to remove the current image&#10;&#10;&#10;class CompanyCategoryBase(BaseModel):&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    description: Optional[str] = None&#10;    description_en: Optional[str] = None&#10;    description_ee: Optional[str] = None&#10;    description_ru: Optional[str] = None&#10;    parent_category_id: Optional[UUID4] = None&#10;&#10;class CompanyCategoryCreate(CompanyCategoryBase):&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyCategoryUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    description: Optional[str] = None&#10;    description_en: Optional[str] = None&#10;    description_ee: Optional[str] = None&#10;    description_ru: Optional[str] = None&#10;    company_id: Optional[str] = None&#10;    parent_category_id: Optional[UUID4] = None&#10;&#10;class CompanyCategory(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    services_count: int = 0  # Optional field to store the count of services in this category&#10;    has_subcategories: bool = False&#10;&#10;&#10;# Hierarchical category response with subcategories&#10;class CompanyCategoryHierarchical(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    services_count: int = 0&#10;    has_subcategories: bool = False&#10;    subcategories: List['CompanyCategoryHierarchical'] = []&#10;&#10;&#10;# CompanyCategoryWithServicesResponse already exists&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []&#10;    parent_category_id: Optional[UUID4] = None&#10;    subcategories: List['CompanyCategoryWithServicesResponse'] = []&#10;&#10;&#10;# Time Off schemas&#10;class TimeOffBase(BaseModel):&#10;    start_date: datetime&#10;    end_date: datetime&#10;    user_id: UUID4&#10;    reason: Optional[str] = None&#10;&#10;class TimeOffCreate(TimeOffBase):&#10;    pass&#10;&#10;class TimeOffUpdate(BaseModel):&#10;    start_date: Optional[date] = None&#10;    end_date: Optional[date] = None&#10;    reason: Optional[str] = None&#10;&#10;class TimeOff(TimeOffBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user: User&#10;&#10;&#10;class CompanyEmailBase(BaseModel):&#10;    email: EmailStr&#10;    status: EmailStatusType = EmailStatusType.unverified&#10;&#10;class CompanyEmailCreate(BaseModel):&#10;    emails: List[CompanyEmailBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyEmail(CompanyEmailBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyPhoneBase(BaseModel):&#10;    phone: str&#10;    is_primary: bool = False&#10;    status: PhoneStatusType = PhoneStatusType.unverified&#10;&#10;class CompanyPhoneCreate(BaseModel):&#10;    company_phones: List[CompanyPhoneBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyPhone(CompanyPhoneBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;# Company Address schemas&#10;class CompanyAddressBase(BaseModel):&#10;    address: str&#10;    city: str&#10;    zip: Optional[str] = None&#10;    country: str&#10;    is_primary: bool = False&#10;&#10;&#10;class CompanyAddressCreate(CompanyAddressBase):&#10;    pass&#10;&#10;&#10;class CompanyAddressResponse(CompanyAddressBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class NotificationBase(BaseModel):&#10;    type: NotificationType&#10;    message: str&#10;    data: Optional[bytes] = None&#10;    status: NotificationStatus = NotificationStatus.UNREAD&#10;    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))&#10;&#10;&#10;class NotificationCreate(NotificationBase):&#10;    pass&#10;&#10;&#10;class CompanyNotificationCreate(NotificationCreate):&#10;    company_id: Optional[UUID4] = None&#10;&#10;&#10;class NotificationUpdate(BaseModel):&#10;    status: Optional[NotificationStatus] = None&#10;&#10;class Notification(NotificationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyMemberCreate(BaseModel):&#10;    user: UserCreate&#10;    company_id: UUID4&#10;    role: CompanyRoleType&#10;&#10;&#10;# Telegram Integration schemas&#10;class TelegramIntegrationBase(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;&#10;&#10;class TelegramIntegrationCreate(TelegramIntegrationBase):&#10;    bot_token: str&#10;&#10;&#10;class TelegramIntegrationUpdate(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    bot_token: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class TelegramIntegration(TelegramIntegrationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    bot_token: Optional[str] = None  # Decrypted token returned in response&#10;&#10;&#10;# Invitation schemas&#10;class InvitationBase(BaseModel):&#10;    email: str&#10;    role: Optional[CompanyRoleType] = CompanyRoleType.staff&#10;&#10;&#10;class InvitationCreate(InvitationBase):&#10;    pass&#10;&#10;&#10;class InvitationAccept(BaseModel):&#10;    token: str&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    phone: Optional[str] = None&#10;    password: Optional[str] = None  # Only required if user doesn't exist&#10;&#10;&#10;class Invitation(InvitationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    token: Optional[str] = None  # Don't expose token in responses&#10;    status: str&#10;" />
              <option name="updatedContent" value="from datetime import datetime, date, time, timezone&#10;from decimal import Decimal&#10;from typing import Optional, List, Annotated&#10;from pydantic import BaseModel, Field, field_validator, ConfigDict, UUID4, EmailStr&#10;&#10;from app.models import CustomerStatusType, CompanyCategories&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType, EmailStatusType, PhoneStatusType, NotificationType, NotificationStatus, CompanyRoleType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;    languages: Optional[str] = &quot;English&quot;&#10;    position: Optional[str] = 'Professional'&#10;    profile_photo_url: Optional[str] = None&#10;&#10;&#10;# User Availability schemas&#10;class UserAvailabilityBase(BaseModel):&#10;    day_of_week: int = Field(..., ge=0, le=6, description=&quot;Day of week: 0=Monday, 6=Sunday&quot;)&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool = True&#10;&#10;&#10;class UserAvailabilityCreate(UserAvailabilityBase):&#10;    pass&#10;&#10;&#10;class UserAvailabilityUpdate(BaseModel):&#10;    start_time: Optional[time] = None&#10;    end_time: Optional[time] = None&#10;    is_available: Optional[bool] = None&#10;&#10;&#10;class UserAvailability(UserAvailabilityBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = []&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;    languages: Optional[str] = None&#10;    position: Optional[str] = None&#10;    profile_photo_url: Optional[str] = None&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    company_id: Optional[UUID4] = None&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(TimestampedModel):&#10;    id: UUID4&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;&#10;    user: Optional[User] = None&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;&#10;class CompanyUserUpdate(BaseModel):&#10;    role: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    phone: Optional[str] = None&#10;    languages: Optional[str] = None&#10;    position: Optional[str] = None&#10;    profile_photo_url: Optional[str] = None&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = None&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    timezone: Optional[str] = &quot;UTC&quot;&#10;    status: StatusType = StatusType.active&#10;    slug: Optional[str] = None&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class CompanyUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    type: Optional[str] = None&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = None&#10;    timezone: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    id: Optional[UUID4] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: Optional[UUID4] = None&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: Optional[UUID4] = None&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    start_time: Optional[datetime] = None&#10;    notes: Optional[str] = None&#10;    status: Optional[BookingStatus] = None&#10;    services: Optional[List[BookingServiceRequest]] = None&#10;&#10;&#10;class ServiceStaff(BaseModel):&#10;    &quot;&quot;&quot;Schema for the service_staff junction table linking services to staff members&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;    # Optional nested user information&#10;    user: Optional['User'] = None&#10;&#10;&#10;class ServiceStaffCreate(BaseModel):&#10;    &quot;&quot;&quot;Schema for creating service-staff assignments&quot;&quot;&quot;&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;class ServiceStaffResponse(BaseModel):&#10;    &quot;&quot;&quot;Simplified response schema for staff assigned to a service&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    image_url: Optional[str] = None&#10;    service_staff: Optional[List['ServiceStaff']] = []  # List of staff assigned to this service&#10;&#10;&#10;class StaffMember(BaseModel):&#10;    &quot;&quot;&quot;Simple staff member schema for booking assignments&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class BookingService(TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    booking_id: UUID4&#10;    category_service_id: Optional[UUID4] = None  # Make optional to handle None values&#10;    user_id: Optional[UUID4] = None  # Make optional to handle None values&#10;    notes: Optional[str] = None&#10;    start_at: Optional[datetime] = None  # Changed from start_date to match DB column&#10;    end_at: Optional[datetime] = None    # Changed from end_date to match DB column&#10;&#10;    category_service: Optional[CategoryServiceResponse] = None&#10;    user: Optional[User] = None  # Changed from assigned_staff to match the model relationship&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;    customer: Optional[Customer] = None&#10;    booking_services: Optional[List[BookingService]] = []&#10;    user_ids: set[str] = set([])&#10;&#10;&#10;#&#10;class CompanyCustomer(Customer):&#10;    email_verified: bool = False&#10;    total_bookings: int = 0&#10;    total_spent: int = 0&#10;    last_visit: Optional[datetime] = None&#10;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: Optional[str]&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceBase(BaseModel):&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    image_url: Optional[str] = None&#10;&#10;class CategoryServiceCreate(CategoryServiceBase):&#10;    category_id: str&#10;    staff_ids: List[UUID4] = []  # List of staff member IDs to assign to this service&#10;&#10;class CategoryServiceUpdate(BaseModel):&#10;    category_id: Optional[str] = None  # Allow changing the category&#10;    name: Optional[str] = None&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: Optional[int] = None&#10;    price: Optional[float] = None&#10;    discount_price: Optional[float] = 0&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    buffer_before: Optional[int] = None&#10;    buffer_after: Optional[int] = None&#10;    staff_ids: Optional[List[UUID4]] = None  # List of staff member IDs to assign to this service&#10;    image_url: Optional[str] = None&#10;    remove_image: Optional[bool] = False  # Set to True to remove the current image&#10;&#10;&#10;class CompanyCategoryBase(BaseModel):&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    description: Optional[str] = None&#10;    description_en: Optional[str] = None&#10;    description_ee: Optional[str] = None&#10;    description_ru: Optional[str] = None&#10;    parent_category_id: Optional[UUID4] = None&#10;&#10;class CompanyCategoryCreate(CompanyCategoryBase):&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyCategoryUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    description: Optional[str] = None&#10;    description_en: Optional[str] = None&#10;    description_ee: Optional[str] = None&#10;    description_ru: Optional[str] = None&#10;    company_id: Optional[str] = None&#10;    parent_category_id: Optional[UUID4] = None&#10;&#10;class CompanyCategory(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    services_count: int = 0  # Optional field to store the count of services in this category&#10;    has_subcategories: bool = False&#10;&#10;&#10;# Hierarchical category response with subcategories&#10;class CompanyCategoryHierarchical(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    services_count: int = 0&#10;    has_subcategories: bool = False&#10;    subcategories: List['CompanyCategoryHierarchical'] = []&#10;&#10;&#10;# CompanyCategoryWithServicesResponse already exists&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []&#10;    parent_category_id: Optional[UUID4] = None&#10;    subcategories: List['CompanyCategoryWithServicesResponse'] = []&#10;&#10;&#10;# Time Off schemas&#10;class TimeOffBase(BaseModel):&#10;    start_date: datetime&#10;    end_date: datetime&#10;    user_id: UUID4&#10;    reason: Optional[str] = None&#10;&#10;class TimeOffCreate(TimeOffBase):&#10;    pass&#10;&#10;class TimeOffUpdate(BaseModel):&#10;    start_date: Optional[date] = None&#10;    end_date: Optional[date] = None&#10;    reason: Optional[str] = None&#10;&#10;class TimeOff(TimeOffBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user: User&#10;&#10;&#10;class CompanyEmailBase(BaseModel):&#10;    email: EmailStr&#10;    status: EmailStatusType = EmailStatusType.unverified&#10;&#10;class CompanyEmailCreate(BaseModel):&#10;    emails: List[CompanyEmailBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyEmail(CompanyEmailBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyPhoneBase(BaseModel):&#10;    phone: str&#10;    is_primary: bool = False&#10;    status: PhoneStatusType = PhoneStatusType.unverified&#10;&#10;class CompanyPhoneCreate(BaseModel):&#10;    company_phones: List[CompanyPhoneBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyPhone(CompanyPhoneBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;# Company Address schemas&#10;class CompanyAddressBase(BaseModel):&#10;    address: str&#10;    city: str&#10;    zip: Optional[str] = None&#10;    country: str&#10;    is_primary: bool = False&#10;&#10;&#10;class CompanyAddressCreate(CompanyAddressBase):&#10;    pass&#10;&#10;&#10;class CompanyAddressResponse(CompanyAddressBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class NotificationBase(BaseModel):&#10;    type: NotificationType&#10;    message: str&#10;    data: Optional[bytes] = None&#10;    status: NotificationStatus = NotificationStatus.UNREAD&#10;    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))&#10;&#10;&#10;class NotificationCreate(NotificationBase):&#10;    pass&#10;&#10;&#10;class CompanyNotificationCreate(NotificationCreate):&#10;    company_id: Optional[UUID4] = None&#10;&#10;&#10;class NotificationUpdate(BaseModel):&#10;    status: Optional[NotificationStatus] = None&#10;&#10;class Notification(NotificationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyMemberCreate(BaseModel):&#10;    user: UserCreate&#10;    company_id: UUID4&#10;    role: CompanyRoleType&#10;&#10;&#10;# Telegram Integration schemas&#10;class TelegramIntegrationBase(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;&#10;&#10;class TelegramIntegrationCreate(TelegramIntegrationBase):&#10;    bot_token: str&#10;&#10;&#10;class TelegramIntegrationUpdate(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    bot_token: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class TelegramIntegration(TelegramIntegrationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    bot_token: Optional[str] = None  # Decrypted token returned in response&#10;&#10;&#10;# Invitation schemas&#10;class InvitationBase(BaseModel):&#10;    email: str&#10;    role: Optional[CompanyRoleType] = CompanyRoleType.staff&#10;&#10;&#10;class InvitationCreate(InvitationBase):&#10;    pass&#10;&#10;&#10;class InvitationAccept(BaseModel):&#10;    token: str&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    phone: Optional[str] = None&#10;    password: Optional[str] = None  # Only required if user doesn't exist&#10;&#10;&#10;class Invitation(InvitationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    token: Optional[str] = None  # Don't expose token in responses&#10;    status: str&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/user_availability.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/user_availability.py" />
              <option name="originalContent" value="from typing import List, Optional, Any&#10;from datetime import datetime, date, time, timedelta&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy import select, delete&#10;import uuid&#10;from app.models.models import UserAvailabilities, UserTimeOffs&#10;from app.models.enums import AvailabilityType&#10;from app.schemas.schemas import (&#10;    TimeSlot,&#10;    DailyAvailability,&#10;    WeeklyAvailability,&#10;    MonthlyAvailability,&#10;    AvailabilityResponse,&#10;    UserAvailabilityCreate&#10;)&#10;from app.core.datetime_utils import utcnow, convert_utc_to_timezone&#10;&#10;&#10;async def create_user_availability(db: AsyncSession, user_id: str, availability_in: UserAvailabilityCreate) -&gt; UserAvailabilities:&#10;    &quot;&quot;&quot;Create a new availability entry for a user&quot;&quot;&quot;&#10;    db_availability = UserAvailabilities(&#10;        id=str(uuid.uuid4()),&#10;        user_id=user_id,&#10;        day_of_week=availability_in.day_of_week,&#10;        start_time=availability_in.start_time,&#10;        end_time=availability_in.end_time,&#10;        is_available=availability_in.is_available,&#10;        created_at=utcnow(),&#10;        updated_at=utcnow()&#10;    )&#10;    db.add(db_availability)&#10;    await db.commit()&#10;    await db.refresh(db_availability)&#10;    return db_availability&#10;&#10;&#10;async def bulk_create_user_availabilities(db: AsyncSession, user_id: str, availabilities: List[UserAvailabilityCreate]) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Create multiple availability entries for a user&quot;&quot;&quot;&#10;    db_availabilities = []&#10;    for availability_in in availabilities:&#10;        db_availability = UserAvailabilities(&#10;            id=str(uuid.uuid4()),&#10;            user_id=user_id,&#10;            day_of_week=availability_in.day_of_week,&#10;            start_time=availability_in.start_time,&#10;            end_time=availability_in.end_time,&#10;            is_available=availability_in.is_available,&#10;            created_at=utcnow(),&#10;            updated_at=utcnow()&#10;        )&#10;        db_availabilities.append(db_availability)&#10;    &#10;    db.add_all(db_availabilities)&#10;    await db.commit()&#10;    for db_availability in db_availabilities:&#10;        await db.refresh(db_availability)&#10;    return db_availabilities&#10;&#10;&#10;async def delete_user_availabilities(db: AsyncSession, user_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;Delete all availability entries for a user&quot;&quot;&quot;&#10;    stmt = delete(UserAvailabilities).filter(UserAvailabilities.user_id == user_id)&#10;    await db.execute(stmt)&#10;    await db.commit()&#10;    return True&#10;&#10;&#10;async def update_user_availabilities(db: AsyncSession, user_id: str, availabilities: List[UserAvailabilityCreate]) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Replace all availability entries for a user with new ones&quot;&quot;&quot;&#10;    # Delete existing availabilities&#10;    await delete_user_availabilities(db, user_id)&#10;&#10;    # Create new availabilities&#10;    if availabilities:&#10;        return await bulk_create_user_availabilities(db, user_id, availabilities)&#10;    return []&#10;&#10;&#10;async def get_user_availabilities(db: AsyncSession, user_id: str) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Get all availability entries for a user&quot;&quot;&quot;&#10;    stmt = select(UserAvailabilities).filter(&#10;        UserAvailabilities.user_id == user_id,&#10;        UserAvailabilities.is_available == True&#10;    )&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;&#10;async def get_user_time_offs(&#10;    db: AsyncSession,&#10;    user_id: str,&#10;    start_date: date,&#10;    end_date: date&#10;) -&gt; List[&quot;UserTimeOffs&quot;]:&#10;    &quot;&quot;&quot;Get all time-offs for a user within a date range&quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    )&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;&#10;async def get_all_availabilities(db: AsyncSession):&#10;    &quot;&quot;&quot;Get all available user availabilities&quot;&quot;&quot;&#10;    stmt = select(UserAvailabilities).filter(UserAvailabilities.is_available == True)&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;&#10;async def get_all_time_offs(db: AsyncSession, start_date: date, end_date: date):&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    )&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;&#10;def subtract_intervals(base_start: time, base_end: time, intervals: List[tuple]) -&gt; List[tuple]:&#10;    &quot;&quot;&quot;Subtract intervals (bookings/time-offs) from a base interval. Returns list of available intervals.&quot;&quot;&quot;&#10;    result = [(base_start, base_end)]&#10;    for interval_start, interval_end in intervals:&#10;        new_result = []&#10;        for avail_start, avail_end in result:&#10;            # If no overlap, keep as is&#10;            if interval_end &lt;= avail_start or interval_start &gt;= avail_end:&#10;                new_result.append((avail_start, avail_end))&#10;            else:&#10;                # Overlap: split interval&#10;                if interval_start &gt; avail_start:&#10;                    new_result.append((avail_start, interval_start))&#10;                if interval_end &lt; avail_end:&#10;                    new_result.append((interval_end, avail_end))&#10;        result = new_result&#10;    return result&#10;&#10;def get_daily_slots(target_date: date, availabilities: List[UserAvailabilities], time_offs: List[UserTimeOffs], bookings: List[Any], service_duration_minutes: Optional[int] = None, company_timezone: str = &quot;UTC&quot;) -&gt; DailyAvailability:&#10;    day_of_week = target_date.weekday()&#10;    day_availabilities = [a for a in availabilities if a.day_of_week == day_of_week]&#10;    # Collect intervals to subtract (bookings and time-offs)&#10;    subtract_intervals_list = []&#10;    &#10;    # Process time-offs: convert from UTC to company timezone&#10;    for time_off, user_id in time_offs:&#10;        # Convert UTC datetime to company timezone&#10;        start_date_local = convert_utc_to_timezone(time_off.start_date, company_timezone)&#10;        end_date_local = convert_utc_to_timezone(time_off.end_date, company_timezone)&#10;        &#10;        if start_date_local.date() &lt;= target_date &lt;= end_date_local.date():&#10;            subtract_intervals_list.append((time(start_date_local.hour, start_date_local.minute),&#10;                                            time(end_date_local.hour, end_date_local.minute)))&#10;    &#10;    # Process bookings: convert from UTC to company timezone&#10;    for booking in bookings:&#10;        # Convert UTC datetime to company timezone&#10;        start_at_local = convert_utc_to_timezone(booking.start_at, company_timezone)&#10;        end_at_local = convert_utc_to_timezone(booking.end_at, company_timezone)&#10;        &#10;        if start_at_local.date() == target_date:&#10;            subtract_intervals_list.append((start_at_local.time(), end_at_local.time()))&#10;    &#10;    time_slots = []&#10;    for avail in day_availabilities:&#10;        available_intervals = subtract_intervals(avail.start_time, avail.end_time, subtract_intervals_list)&#10;        for start, end in available_intervals:&#10;            # If service_duration_minutes is provided, filter slots that don't have enough time&#10;            if service_duration_minutes:&#10;                # Calculate the duration of this slot in minutes&#10;                start_datetime = datetime.combine(target_date, start)&#10;                end_datetime = datetime.combine(target_date, end)&#10;                slot_duration_minutes = (end_datetime - start_datetime).total_seconds() / 60&#10;                &#10;                # Only include slots that have enough time for the service&#10;                # Adjust end_time to be service_duration_minutes before the actual end&#10;                if slot_duration_minutes &gt;= service_duration_minutes:&#10;                    # Calculate the last possible start time&#10;                    last_start_time = (datetime.combine(target_date, end) - timedelta(minutes=service_duration_minutes)).time()&#10;                    if start &lt; last_start_time:&#10;                        time_slots.append(TimeSlot(&#10;                            start_time=start,&#10;                            end_time=last_start_time,&#10;                            is_available=True&#10;                        ))&#10;            else:&#10;                # No service duration provided, include the full slot&#10;                if start &lt; end:&#10;                    time_slots.append(TimeSlot(&#10;                        start_time=start,&#10;                        end_time=end,&#10;                        is_available=True&#10;                    ))&#10;    return DailyAvailability(&#10;        date=target_date,&#10;        time_slots=time_slots&#10;    )&#10;&#10;def calculate_availability(&#10;    availabilities: List[UserAvailabilities],&#10;    time_offs: List[UserTimeOffs],&#10;    bookings: List[Any],&#10;    availability_type: AvailabilityType,&#10;    date_from: date,&#10;    service_duration_minutes: Optional[int] = None,&#10;    company_timezone: str = &quot;UTC&quot;&#10;) -&gt; AvailabilityResponse:&#10;    &quot;&quot;&quot;Calculate availability based on working hours, time-offs, and bookings&quot;&quot;&quot;&#10;    try:&#10;        if not availabilities:&#10;            return AvailabilityResponse(&#10;                user_id=None,&#10;                availability_type=availability_type,&#10;                daily=None,&#10;                weekly=None,&#10;                monthly=None&#10;            )&#10;        if availability_type == AvailabilityType.DAILY:&#10;            daily = get_daily_slots(date_from, availabilities, time_offs, bookings, service_duration_minutes, company_timezone)&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                daily=daily&#10;            )&#10;        elif availability_type == AvailabilityType.WEEKLY:&#10;            week_start = date_from&#10;            week_end = week_start + timedelta(days=6)&#10;            daily_slots = []&#10;            current_date = week_start&#10;            while current_date &lt;= week_end:&#10;                daily_slots.append(get_daily_slots(current_date, availabilities, time_offs, bookings, service_duration_minutes, company_timezone))&#10;                current_date += timedelta(days=1)&#10;            weekly = WeeklyAvailability(&#10;                week_start_date=week_start,&#10;                week_end_date=week_end,&#10;                daily_slots=daily_slots&#10;            )&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                weekly=weekly&#10;            )&#10;        else:  # MONTHLY&#10;            month_start = date_from.replace(day=1)&#10;            if month_start.month == 12:&#10;                month_end = month_start.replace(year=month_start.year + 1, month=1, day=1) - timedelta(days=1)&#10;            else:&#10;                month_end = month_start.replace(month=month_start.month + 1, day=1) - timedelta(days=1)&#10;            weekly_slots = []&#10;            current_date = month_start&#10;            while current_date &lt;= month_end:&#10;                week_start = current_date - timedelta(days=current_date.weekday())&#10;                week_end = min(week_start + timedelta(days=6), month_end)&#10;                daily_slots = []&#10;                week_date = week_start&#10;                while week_date &lt;= week_end:&#10;                    if month_start &lt;= week_date &lt;= month_end:&#10;                        daily_slots.append(get_daily_slots(week_date, availabilities, time_offs, bookings, service_duration_minutes, company_timezone))&#10;                    week_date += timedelta(days=1)&#10;                weekly_slots.append(WeeklyAvailability(&#10;                    week_start_date=week_start,&#10;                    week_end_date=week_end,&#10;                    daily_slots=daily_slots&#10;                ))&#10;                current_date = week_end + timedelta(days=1)&#10;            monthly = MonthlyAvailability(&#10;                month=date_from.month,&#10;                year=date_from.year,&#10;                weekly_slots=weekly_slots&#10;            )&#10;&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                monthly=monthly&#10;            )&#10;    except Exception as ex:&#10;        print(f&quot;Error calculating availability: {ex}&quot;)&#10;        raise" />
              <option name="updatedContent" value="from typing import List, Optional, Any&#10;from datetime import datetime, date, time, timedelta&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy import select, delete&#10;import uuid&#10;from app.models.models import UserAvailabilities, UserTimeOffs&#10;from app.models.enums import AvailabilityType&#10;from app.schemas.schemas import (&#10;    TimeSlot,&#10;    DailyAvailability,&#10;    WeeklyAvailability,&#10;    MonthlyAvailability,&#10;    AvailabilityResponse,&#10;    UserAvailabilityCreate&#10;)&#10;from app.core.datetime_utils import utcnow, convert_utc_to_timezone&#10;&#10;&#10;async def create_user_availability(db: AsyncSession, user_id: str, availability_in: UserAvailabilityCreate) -&gt; UserAvailabilities:&#10;    &quot;&quot;&quot;Create a new availability entry for a user&quot;&quot;&quot;&#10;    db_availability = UserAvailabilities(&#10;        id=str(uuid.uuid4()),&#10;        user_id=user_id,&#10;        day_of_week=availability_in.day_of_week,&#10;        start_time=availability_in.start_time,&#10;        end_time=availability_in.end_time,&#10;        is_available=availability_in.is_available,&#10;        created_at=utcnow(),&#10;        updated_at=utcnow()&#10;    )&#10;    db.add(db_availability)&#10;    await db.commit()&#10;    await db.refresh(db_availability)&#10;    return db_availability&#10;&#10;&#10;async def bulk_create_user_availabilities(db: AsyncSession, user_id: str, availabilities: List[UserAvailabilityCreate]) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Create multiple availability entries for a user&quot;&quot;&quot;&#10;    db_availabilities = []&#10;    for availability_in in availabilities:&#10;        db_availability = UserAvailabilities(&#10;            id=str(uuid.uuid4()),&#10;            user_id=user_id,&#10;            day_of_week=availability_in.day_of_week,&#10;            start_time=availability_in.start_time,&#10;            end_time=availability_in.end_time,&#10;            is_available=availability_in.is_available,&#10;            created_at=utcnow(),&#10;            updated_at=utcnow()&#10;        )&#10;        db_availabilities.append(db_availability)&#10;    &#10;    db.add_all(db_availabilities)&#10;    await db.commit()&#10;    for db_availability in db_availabilities:&#10;        await db.refresh(db_availability)&#10;    return db_availabilities&#10;&#10;&#10;async def delete_user_availabilities(db: AsyncSession, user_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;Delete all availability entries for a user&quot;&quot;&quot;&#10;    stmt = delete(UserAvailabilities).filter(UserAvailabilities.user_id == user_id)&#10;    await db.execute(stmt)&#10;    await db.commit()&#10;    return True&#10;&#10;&#10;async def update_user_availabilities(db: AsyncSession, user_id: str, availabilities: List[UserAvailabilityCreate]) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Replace all availability entries for a user with new ones&quot;&quot;&quot;&#10;    # Delete existing availabilities&#10;    await delete_user_availabilities(db, user_id)&#10;&#10;    # Create new availabilities&#10;    if availabilities:&#10;        return await bulk_create_user_availabilities(db, user_id, availabilities)&#10;    return []&#10;&#10;&#10;async def get_user_availabilities(db: AsyncSession, user_id: str) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Get all availability entries for a user&quot;&quot;&quot;&#10;    stmt = select(UserAvailabilities).filter(&#10;        UserAvailabilities.user_id == user_id,&#10;        UserAvailabilities.is_available == True&#10;    )&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;&#10;async def get_user_time_offs(&#10;    db: AsyncSession,&#10;    user_id: str,&#10;    start_date: date,&#10;    end_date: date&#10;) -&gt; List[&quot;UserTimeOffs&quot;]:&#10;    &quot;&quot;&quot;Get all time-offs for a user within a date range&quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    )&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;&#10;async def get_all_availabilities(db: AsyncSession):&#10;    &quot;&quot;&quot;Get all available user availabilities&quot;&quot;&quot;&#10;    stmt = select(UserAvailabilities).filter(UserAvailabilities.is_available == True)&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;&#10;async def get_all_time_offs(db: AsyncSession, start_date: date, end_date: date):&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    )&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;&#10;def subtract_intervals(base_start: time, base_end: time, intervals: List[tuple]) -&gt; List[tuple]:&#10;    &quot;&quot;&quot;Subtract intervals (bookings/time-offs) from a base interval. Returns list of available intervals.&quot;&quot;&quot;&#10;    result = [(base_start, base_end)]&#10;    for interval_start, interval_end in intervals:&#10;        new_result = []&#10;        for avail_start, avail_end in result:&#10;            # If no overlap, keep as is&#10;            if interval_end &lt;= avail_start or interval_start &gt;= avail_end:&#10;                new_result.append((avail_start, avail_end))&#10;            else:&#10;                # Overlap: split interval&#10;                if interval_start &gt; avail_start:&#10;                    new_result.append((avail_start, interval_start))&#10;                if interval_end &lt; avail_end:&#10;                    new_result.append((interval_end, avail_end))&#10;        result = new_result&#10;    return result&#10;&#10;def get_daily_slots(target_date: date, availabilities: List[UserAvailabilities], time_offs: List[UserTimeOffs], bookings: List[Any], service_duration_minutes: Optional[int] = None, company_timezone: str = &quot;UTC&quot;) -&gt; DailyAvailability:&#10;    day_of_week = target_date.weekday()&#10;    day_availabilities = [a for a in availabilities if a.day_of_week == day_of_week]&#10;    # Collect intervals to subtract (bookings and time-offs)&#10;    subtract_intervals_list = []&#10;    &#10;    # Process time-offs: convert from UTC to company timezone&#10;    for time_off, user_id in time_offs:&#10;        # Convert UTC datetime to company timezone&#10;        start_date_local = convert_utc_to_timezone(time_off.start_date, company_timezone)&#10;        end_date_local = convert_utc_to_timezone(time_off.end_date, company_timezone)&#10;        &#10;        if start_date_local.date() &lt;= target_date &lt;= end_date_local.date():&#10;            subtract_intervals_list.append((time(start_date_local.hour, start_date_local.minute),&#10;                                            time(end_date_local.hour, end_date_local.minute)))&#10;    &#10;    # Process bookings: convert from UTC to company timezone&#10;    for booking in bookings:&#10;        # Convert UTC datetime to company timezone&#10;        start_at_local = convert_utc_to_timezone(booking.start_at, company_timezone)&#10;        end_at_local = convert_utc_to_timezone(booking.end_at, company_timezone)&#10;        &#10;        if start_at_local.date() == target_date:&#10;            subtract_intervals_list.append((start_at_local.time(), end_at_local.time()))&#10;    &#10;    time_slots = []&#10;    for avail in day_availabilities:&#10;        available_intervals = subtract_intervals(avail.start_time, avail.end_time, subtract_intervals_list)&#10;        for start, end in available_intervals:&#10;            # If service_duration_minutes is provided, filter slots that don't have enough time&#10;            if service_duration_minutes:&#10;                # Calculate the duration of this slot in minutes&#10;                start_datetime = datetime.combine(target_date, start)&#10;                end_datetime = datetime.combine(target_date, end)&#10;                slot_duration_minutes = (end_datetime - start_datetime).total_seconds() / 60&#10;                &#10;                # Only include slots that have enough time for the service&#10;                # Adjust end_time to be service_duration_minutes before the actual end&#10;                if slot_duration_minutes &gt;= service_duration_minutes:&#10;                    # Calculate the last possible start time&#10;                    last_start_time = (datetime.combine(target_date, end) - timedelta(minutes=service_duration_minutes)).time()&#10;                    if start &lt; last_start_time:&#10;                        time_slots.append(TimeSlot(&#10;                            start_time=start,&#10;                            end_time=last_start_time,&#10;                            is_available=True&#10;                        ))&#10;            else:&#10;                # No service duration provided, include the full slot&#10;                if start &lt; end:&#10;                    time_slots.append(TimeSlot(&#10;                        start_time=start,&#10;                        end_time=end,&#10;                        is_available=True&#10;                    ))&#10;    return DailyAvailability(&#10;        date=target_date,&#10;        time_slots=time_slots&#10;    )&#10;&#10;def calculate_availability(&#10;    availabilities: List[UserAvailabilities],&#10;    time_offs: List[UserTimeOffs],&#10;    bookings: List[Any],&#10;    availability_type: AvailabilityType,&#10;    date_from: date,&#10;    service_duration_minutes: Optional[int] = None,&#10;    company_timezone: str = &quot;UTC&quot;&#10;) -&gt; AvailabilityResponse:&#10;    &quot;&quot;&quot;Calculate availability based on working hours, time-offs, and bookings&quot;&quot;&quot;&#10;    try:&#10;        if not availabilities:&#10;            return AvailabilityResponse(&#10;                user_id=None,&#10;                availability_type=availability_type,&#10;                daily=None,&#10;                weekly=None,&#10;                monthly=None&#10;            )&#10;        if availability_type == AvailabilityType.DAILY:&#10;            daily = get_daily_slots(date_from, availabilities, time_offs, bookings, service_duration_minutes, company_timezone)&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                daily=daily&#10;            )&#10;        elif availability_type == AvailabilityType.WEEKLY:&#10;            week_start = date_from&#10;            week_end = week_start + timedelta(days=6)&#10;            daily_slots = []&#10;            current_date = week_start&#10;            while current_date &lt;= week_end:&#10;                daily_slots.append(get_daily_slots(current_date, availabilities, time_offs, bookings, service_duration_minutes, company_timezone))&#10;                current_date += timedelta(days=1)&#10;            weekly = WeeklyAvailability(&#10;                week_start_date=week_start,&#10;                week_end_date=week_end,&#10;                daily_slots=daily_slots&#10;            )&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                weekly=weekly&#10;            )&#10;        else:  # MONTHLY&#10;            month_start = date_from.replace(day=1)&#10;            if month_start.month == 12:&#10;                month_end = month_start.replace(year=month_start.year + 1, month=1, day=1) - timedelta(days=1)&#10;            else:&#10;                month_end = month_start.replace(month=month_start.month + 1, day=1) - timedelta(days=1)&#10;            weekly_slots = []&#10;            current_date = month_start&#10;            while current_date &lt;= month_end:&#10;                week_start = current_date - timedelta(days=current_date.weekday())&#10;                week_end = min(week_start + timedelta(days=6), month_end)&#10;                daily_slots = []&#10;                week_date = week_start&#10;                while week_date &lt;= week_end:&#10;                    if month_start &lt;= week_date &lt;= month_end:&#10;                        daily_slots.append(get_daily_slots(week_date, availabilities, time_offs, bookings, service_duration_minutes, company_timezone))&#10;                    week_date += timedelta(days=1)&#10;                weekly_slots.append(WeeklyAvailability(&#10;                    week_start_date=week_start,&#10;                    week_end_date=week_end,&#10;                    daily_slots=daily_slots&#10;                ))&#10;                current_date = week_end + timedelta(days=1)&#10;            monthly = MonthlyAvailability(&#10;                month=date_from.month,&#10;                year=date_from.year,&#10;                weekly_slots=weekly_slots&#10;            )&#10;&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                monthly=monthly&#10;            )&#10;    except Exception as ex:&#10;        print(f&quot;Error calculating availability: {ex}&quot;)&#10;        raise" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/user_time_off.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/user_time_off.py" />
              <option name="originalContent" value="from typing import List, Optional, Any&#10;from datetime import date, datetime&#10;import uuid&#10;&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy import select, func&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import selectinload&#10;&#10;from app.models import CompanyUsers&#10;from app.models.models import UserTimeOffs&#10;from app.schemas.schemas import TimeOffCreate, TimeOffUpdate&#10;from app.core.datetime_utils import utcnow, ensure_utc&#10;&#10;&#10;async def get_user_time_offs(&#10;    db: AsyncSession,&#10;    company_id: str,&#10;    start_date: datetime = None,&#10;    end_date: datetime = None&#10;) -&gt; List[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get all time-offs for a user with optional date filtering&#10;    &quot;&quot;&quot;&#10;    stmt = (select(UserTimeOffs)&#10;            .options(selectinload(UserTimeOffs.user))&#10;            .join(CompanyUsers, CompanyUsers.user_id == UserTimeOffs.user_id)&#10;            .filter(CompanyUsers.company_id == company_id))&#10;&#10;    if start_date and end_date:&#10;        # Ensure dates are in UTC&#10;        start_date_utc = datetime.combine(start_date, datetime.min.time())&#10;        end_date_utc = datetime.combine(end_date, datetime.max.time())&#10;        # Get time offs that overlap with the given date range&#10;        stmt = stmt.filter(&#10;            UserTimeOffs.start_date &lt;= end_date_utc,&#10;            UserTimeOffs.end_date &gt;= start_date_utc&#10;        )&#10;    &#10;    result = await db.execute(stmt)&#10;    return result.scalars().all()&#10;&#10;&#10;async def get(db: AsyncSession, time_off_id: UUID4) -&gt; Optional[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get a specific time off by ID&#10;    &quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(UserTimeOffs.id == time_off_id)&#10;    result = await db.execute(stmt)&#10;    return result.scalar_one_or_none()&#10;&#10;&#10;async def create(db: AsyncSession, *, obj_in: TimeOffCreate, company_id: Optional[str]) -&gt; UserTimeOffs:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for a user&#10;&#10;    If company_id is provided, validates that the user belongs to that company&#10;    &quot;&quot;&quot;&#10;    # Validate that end_date is not before start_date&#10;    if obj_in.end_date &lt; obj_in.start_date:&#10;        raise ValueError(&quot;End date cannot be before start date&quot;)&#10;    start_date_utc = ensure_utc(obj_in.start_date)&#10;    end_date_utc = ensure_utc(obj_in.end_date)&#10;    # Check if company_id is provided, validate user belongs to this company&#10;    if company_id:&#10;        stmt = select(CompanyUsers).filter(&#10;            CompanyUsers.user_id == obj_in.user_id,&#10;            CompanyUsers.company_id == company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        company_user = result.scalar_one_or_none()&#10;&#10;        if not company_user:&#10;            raise ValueError(f&quot;User {obj_in.user_id} does not belong to company {company_id}&quot;)&#10;&#10;    db_obj = UserTimeOffs(&#10;        # id=uuid.uuid4(),&#10;        user_id=obj_in.user_id,&#10;        start_date=start_date_utc,&#10;        end_date=end_date_utc,&#10;        reason=obj_in.reason&#10;&#10;    )&#10;    db.add(db_obj)&#10;    await db.commit()&#10;    await db.refresh(db_obj, )&#10;    return db_obj&#10;&#10;&#10;async def update(db: AsyncSession, *, db_obj: UserTimeOffs, obj_in: TimeOffUpdate) -&gt; UserTimeOffs:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period&#10;    &quot;&quot;&quot;&#10;    # Update fields if provided&#10;    if obj_in.start_date is not None:&#10;        db_obj.start_date = obj_in.start_date&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    if obj_in.end_date is not None:&#10;        db_obj.end_date = obj_in.end_date&#10;        update_data['end_date'] = ensure_utc(update_data['end_date'])&#10;    if obj_in.reason is not None:&#10;        db_obj.reason = obj_in.reason&#10;    &#10;    # Validate that end_date is not before start_date after updates&#10;    if db_obj.end_date &lt; db_obj.start_date:&#10;        raise ValueError(&quot;End date cannot be before start date&quot;)&#10;    db_obj.updated_at = utcnow()&#10;&#10;    db.add(db_obj)&#10;    await db.commit()&#10;    await db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;async def delete(db: AsyncSession, *, time_off_id: UUID4) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period&#10;    &quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(UserTimeOffs.id == time_off_id)&#10;    result = await db.execute(stmt)&#10;    db_obj = result.scalar_one_or_none()&#10;&#10;    if not db_obj:&#10;        return False&#10;    &#10;    await db.delete(db_obj)&#10;    await db.commit()&#10;    return True&#10;&#10;&#10;async def check_overlapping_time_offs(&#10;    db: AsyncSession,&#10;    user_id: UUID4,&#10;    start_date: datetime,&#10;    end_date: datetime,&#10;    exclude_id: UUID4 = None&#10;) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if a new time off period overlaps with existing ones&#10;    Returns True if there are overlaps, False otherwise&#10;    &quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    )&#10;&#10;    # Exclude the current time off if updating&#10;    if exclude_id:&#10;        stmt = stmt.filter(UserTimeOffs.id != exclude_id)&#10;&#10;    result = await db.execute(stmt)&#10;    count = len(result.scalars().all())&#10;    return count &gt; 0&#10;&#10;&#10;async def get_company_user_time_offs(&#10;        db: AsyncSession,&#10;        company_id: str,&#10;        start_date: date = None,&#10;        end_date: date = None&#10;) -&gt; List[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get all time-offs for all users in a company with optional date filtering&#10;    &quot;&quot;&quot;&#10;    stmt = (select(UserTimeOffs)&#10;            .join(CompanyUsers, CompanyUsers.user_id == UserTimeOffs.user_id)&#10;            .filter(CompanyUsers.company_id == company_id))&#10;&#10;    if start_date and end_date:&#10;        # Ensure dates are in UTC&#10;        start_date_utc = datetime.combine(start_date, datetime.min.time())&#10;        end_date_utc = datetime.combine(end_date, datetime.max.time())&#10;        # Get time offs that overlap with the given date range&#10;        stmt = stmt.filter(&#10;            UserTimeOffs.start_date &lt;= end_date_utc,&#10;            UserTimeOffs.end_date &gt;= start_date_utc&#10;        )&#10;&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;" />
              <option name="updatedContent" value="from typing import List, Optional, Any&#10;from datetime import date, datetime&#10;import uuid&#10;&#10;from sqlalchemy.ext.asyncio import AsyncSession&#10;from sqlalchemy import select, func&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import selectinload&#10;&#10;from app.models import CompanyUsers&#10;from app.models.models import UserTimeOffs&#10;from app.schemas.schemas import TimeOffCreate, TimeOffUpdate&#10;from app.core.datetime_utils import utcnow, ensure_utc&#10;&#10;&#10;async def get_user_time_offs(&#10;    db: AsyncSession,&#10;    company_id: str,&#10;    start_date: datetime = None,&#10;    end_date: datetime = None&#10;) -&gt; List[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get all time-offs for a user with optional date filtering&#10;    &quot;&quot;&quot;&#10;    stmt = (select(UserTimeOffs)&#10;            .options(selectinload(UserTimeOffs.user))&#10;            .join(CompanyUsers, CompanyUsers.user_id == UserTimeOffs.user_id)&#10;            .filter(CompanyUsers.company_id == company_id))&#10;&#10;    if start_date and end_date:&#10;        # Ensure dates are in UTC&#10;        start_date_utc = datetime.combine(start_date, datetime.min.time())&#10;        end_date_utc = datetime.combine(end_date, datetime.max.time())&#10;        # Get time offs that overlap with the given date range&#10;        stmt = stmt.filter(&#10;            UserTimeOffs.start_date &lt;= end_date_utc,&#10;            UserTimeOffs.end_date &gt;= start_date_utc&#10;        )&#10;    &#10;    result = await db.execute(stmt)&#10;    return result.scalars().all()&#10;&#10;&#10;async def get(db: AsyncSession, time_off_id: UUID4) -&gt; Optional[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get a specific time off by ID&#10;    &quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(UserTimeOffs.id == time_off_id)&#10;    result = await db.execute(stmt)&#10;    return result.scalar_one_or_none()&#10;&#10;&#10;async def create(db: AsyncSession, *, obj_in: TimeOffCreate, company_id: Optional[str]) -&gt; UserTimeOffs:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for a user&#10;&#10;    If company_id is provided, validates that the user belongs to that company&#10;    &quot;&quot;&quot;&#10;    # Validate that end_date is not before start_date&#10;    if obj_in.end_date &lt; obj_in.start_date:&#10;        raise ValueError(&quot;End date cannot be before start date&quot;)&#10;    start_date_utc = ensure_utc(obj_in.start_date)&#10;    end_date_utc = ensure_utc(obj_in.end_date)&#10;    # Check if company_id is provided, validate user belongs to this company&#10;    if company_id:&#10;        stmt = select(CompanyUsers).filter(&#10;            CompanyUsers.user_id == obj_in.user_id,&#10;            CompanyUsers.company_id == company_id&#10;        )&#10;        result = await db.execute(stmt)&#10;        company_user = result.scalar_one_or_none()&#10;&#10;        if not company_user:&#10;            raise ValueError(f&quot;User {obj_in.user_id} does not belong to company {company_id}&quot;)&#10;&#10;    db_obj = UserTimeOffs(&#10;        # id=uuid.uuid4(),&#10;        user_id=obj_in.user_id,&#10;        start_date=start_date_utc,&#10;        end_date=end_date_utc,&#10;        reason=obj_in.reason&#10;&#10;    )&#10;    db.add(db_obj)&#10;    await db.commit()&#10;    await db.refresh(db_obj, )&#10;    return db_obj&#10;&#10;&#10;async def update(db: AsyncSession, *, db_obj: UserTimeOffs, obj_in: TimeOffUpdate) -&gt; UserTimeOffs:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period&#10;    &quot;&quot;&quot;&#10;    # Update fields if provided&#10;    if obj_in.start_date is not None:&#10;        db_obj.start_date = obj_in.start_date&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    if obj_in.end_date is not None:&#10;        db_obj.end_date = obj_in.end_date&#10;        update_data['end_date'] = ensure_utc(update_data['end_date'])&#10;    if obj_in.reason is not None:&#10;        db_obj.reason = obj_in.reason&#10;    &#10;    # Validate that end_date is not before start_date after updates&#10;    if db_obj.end_date &lt; db_obj.start_date:&#10;        raise ValueError(&quot;End date cannot be before start date&quot;)&#10;    db_obj.updated_at = utcnow()&#10;&#10;    db.add(db_obj)&#10;    await db.commit()&#10;    await db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;async def delete(db: AsyncSession, *, time_off_id: UUID4) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period&#10;    &quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(UserTimeOffs.id == time_off_id)&#10;    result = await db.execute(stmt)&#10;    db_obj = result.scalar_one_or_none()&#10;&#10;    if not db_obj:&#10;        return False&#10;    &#10;    await db.delete(db_obj)&#10;    await db.commit()&#10;    return True&#10;&#10;&#10;async def check_overlapping_time_offs(&#10;    db: AsyncSession,&#10;    user_id: UUID4,&#10;    start_date: datetime,&#10;    end_date: datetime,&#10;    exclude_id: UUID4 = None&#10;) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if a new time off period overlaps with existing ones&#10;    Returns True if there are overlaps, False otherwise&#10;    &quot;&quot;&quot;&#10;    stmt = select(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    )&#10;&#10;    # Exclude the current time off if updating&#10;    if exclude_id:&#10;        stmt = stmt.filter(UserTimeOffs.id != exclude_id)&#10;&#10;    result = await db.execute(stmt)&#10;    count = len(result.scalars().all())&#10;    return count &gt; 0&#10;&#10;&#10;async def get_company_user_time_offs(&#10;        db: AsyncSession,&#10;        company_id: str,&#10;        start_date: date = None,&#10;        end_date: date = None&#10;) -&gt; List[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get all time-offs for all users in a company with optional date filtering&#10;    &quot;&quot;&quot;&#10;    stmt = (select(UserTimeOffs)&#10;            .join(CompanyUsers, CompanyUsers.user_id == UserTimeOffs.user_id)&#10;            .filter(CompanyUsers.company_id == company_id))&#10;&#10;    if start_date and end_date:&#10;        # Ensure dates are in UTC&#10;        start_date_utc = datetime.combine(start_date, datetime.min.time())&#10;        end_date_utc = datetime.combine(end_date, datetime.max.time())&#10;        # Get time offs that overlap with the given date range&#10;        stmt = stmt.filter(&#10;            UserTimeOffs.start_date &lt;= end_date_utc,&#10;            UserTimeOffs.end_date &gt;= start_date_utc&#10;        )&#10;&#10;    result = await db.execute(stmt)&#10;    return list(result.scalars().all())&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>