<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/users.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/users.py" />
              <option name="originalContent" value="from fastapi import APIRouter, Depends, HTTPException, status, Response, Query&#10;from pydantic import UUID4&#10;from sqlalchemy.orm import Session&#10;from datetime import datetime, date, timedelta&#10;from app.db.session import get_db&#10;from app.schemas.auth import LoginRequest, TokenResponse&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import ResponseMessage&#10;from app.schemas.schemas import UserCreate,AvailabilityResponse&#10;from app.services.auth import hash_password, verify_password, create_token_pair&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import booking as crud_booking&#10;from app.models.enums import AvailabilityType&#10;from app.services.crud import user_availability as crud_availability&#10;&#10;&#10;router = APIRouter()&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=ResponseMessage, status_code=status.HTTP_201_CREATED)&#10;async def create_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    user_in: UserCreate&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Register a new user.&#10;    &quot;&quot;&quot;&#10;&#10;    try:&#10;        existing_customer = crud_user.get_by_email(&#10;            db=db,&#10;            email=user_in.email&#10;        )&#10;        if existing_customer:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return ResponseMessage(message=&quot;User with this email already exists for this business&quot;, status=&quot;error&quot;)&#10;&#10;        user_in.password = hash_password(user_in.password)&#10;        crud_user.create(db=db, obj_in=user_in)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return ResponseMessage(message=&quot;User created successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;# @router.get(&quot;/me&quot;, response_model=Professional)&#10;# async def get_current_professional_info(&#10;#     current_professional: Professional = Depends(get_current_active_professional)&#10;# ) -&gt; Professional:&#10;#     &quot;&quot;&quot;&#10;#     Get current professional's information from JWT token.&#10;#     &quot;&quot;&quot;&#10;#     return current_professional&#10;#&#10;#&#10;# @router.get(&quot;/{professional_id}&quot;, response_model=Professional)&#10;# async def get_professional(&#10;#     professional_id: int,&#10;#     db: Session = Depends(get_db),&#10;#     current_professional: Professional = Depends(get_current_active_professional)&#10;# ) -&gt; Professional:&#10;#     &quot;&quot;&quot;&#10;#     Get professional by ID. Requires authentication.&#10;#     &quot;&quot;&quot;&#10;#     # Check if the requesting professional is trying to access their own data or has permission&#10;#     if current_professional.id != professional_id:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_403_FORBIDDEN,&#10;#             detail=&quot;Not authorized to access this professional's information&quot;&#10;#         )&#10;#&#10;#     professional = crud_professional.get(db=db, id=professional_id)&#10;#     if not professional:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_404_NOT_FOUND,&#10;#             detail=&quot;Professional not found&quot;&#10;#         )&#10;#     return professional&#10;#&#10;#&#10;# @router.put(&quot;/{professional_id}&quot;, response_model=Professional)&#10;# async def update_professional(&#10;#     *,&#10;#     db: Session = Depends(get_db),&#10;#     professional_id: int,&#10;#     professional_in: ProfessionalUpdate,&#10;#     current_professional: Professional = Depends(get_current_active_professional)&#10;# ) -&gt; Professional:&#10;#     &quot;&quot;&quot;&#10;#     Update professional. Requires authentication.&#10;#     &quot;&quot;&quot;&#10;#     # Check if the requesting professional is trying to update their own data&#10;#     if current_professional.id != professional_id:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_403_FORBIDDEN,&#10;#             detail=&quot;Not authorized to update this professional's information&quot;&#10;#         )&#10;#&#10;#     professional = crud_professional.get(db=db, id=professional_id)&#10;#     if not professional:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_404_NOT_FOUND,&#10;#             detail=&quot;Professional not found&quot;&#10;#         )&#10;#&#10;#     professional = crud_professional.update(db=db, db_obj=professional, obj_in=professional_in)&#10;#     return professional&#10;#&#10;#&#10;# @router.get(&quot;/mobile/{mobile_number}&quot;, response_model=Professional)&#10;# async def get_professional_by_mobile(&#10;#     mobile_number: str,&#10;#     db: Session = Depends(get_db),&#10;#     current_professional: Professional = Depends(get_current_active_professional)&#10;# ) -&gt; Professional:&#10;#     &quot;&quot;&quot;&#10;#     Get professional by mobile number. Requires authentication.&#10;#     &quot;&quot;&quot;&#10;#     professional = crud_professional.get_by_mobile(db=db, mobile_number=mobile_number)&#10;#     if not professional:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_404_NOT_FOUND,&#10;#             detail=&quot;Professional not found&quot;&#10;#         )&#10;#&#10;#     # Check if the requesting professional is trying to access their own data&#10;#     if current_professional.id != professional.id:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_403_FORBIDDEN,&#10;#             detail=&quot;Not authorized to access this professional's information&quot;&#10;#         )&#10;#&#10;#     return professional&#10;#&#10;#&#10;@router.post(&quot;/auth/login&quot;, response_model=TokenResponse)&#10;async def user_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; TokenResponse:&#10;    &quot;&quot;&quot;&#10;    Login professional using mobile number or email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    # Try to get professional by mobile number first&#10;    user = crud_user.get_by_email(db, email=login_data.email)&#10;&#10;    if not user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Verify password&#10;    if not verify_password(login_data.password, user.password):&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Create token pair&#10;    tokens = create_token_pair(user.id, user.email, actor=&quot;user&quot;, ver=&quot;1&quot;)&#10;    response.set_cookie(&#10;        key=&quot;refresh_token&quot;,&#10;        value=tokens[&quot;refresh_token&quot;],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;strict&quot;&#10;    )&#10;    return TokenResponse(**tokens)&#10;&#10;#&#10;# @router.post(&quot;/refresh-token&quot;, response_model=TokenResponse)&#10;# async def refresh_token(&#10;#     refresh_data: RefreshTokenRequest&#10;# ) -&gt; TokenResponse:&#10;#     &quot;&quot;&quot;&#10;#     Refresh access token using refresh token.&#10;#     &quot;&quot;&quot;&#10;#     tokens = refresh_access_token(refresh_data.refresh_token)&#10;#     if not tokens:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_401_UNAUTHORIZED,&#10;#             detail=&quot;Invalid refresh token&quot;&#10;#         )&#10;#&#10;#     return TokenResponse(**tokens)&#10;#&#10;#&#10;@router.put(&quot;/auth/logout&quot;)&#10;async def logout_user(response: Response):&#10;    &quot;&quot;&quot;&#10;    Logout professional by clearing the refresh token cookie&#10;    &quot;&quot;&quot;&#10;    try:&#10;        response.delete_cookie(key=&quot;refresh_token&quot;)&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.get(&quot;/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db)&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get user's regular availability&#10;        availabilities = crud_availability.get_user_availabilities(db, user_id=user_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = crud_availability.get_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, and existing bookings&#10;            availability = crud_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/availabilities&quot;, response_model=DataResponse[list[AvailabilityResponse]])&#10;async def get_all_users_availabilities(&#10;    *,&#10;    availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;    date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse[list[AvailabilityResponse]]:&#10;    &quot;&quot;&quot;&#10;    Get availabilities for all users for a specific time range. Optimized to fetch all data in bulk and group bookings by user via BookingServices.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        users = crud_user.get_all(db)&#10;        if not users:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No users found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        # Bulk fetch all related data&#10;        availabilities = crud_availability.get_all_availabilities(db)&#10;        time_offs = crud_availability.get_all_time_offs(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        booking_tuples = crud_booking.get_all_bookings_in_range(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        # Group data by user&#10;        avail_map = {}&#10;        for a in availabilities:&#10;            avail_map.setdefault(str(a.user_id), []).append(a)&#10;        timeoff_map = {}&#10;        for t in time_offs:&#10;            timeoff_map.setdefault(str(t.user_id), []).append(t)&#10;        booking_map = {}&#10;        for booking, user_id in booking_tuples:&#10;            booking_map.setdefault(str(user_id), []).append(booking)&#10;        results = []&#10;        for user in users:&#10;            user_id = str(user.id)&#10;            user_avails = avail_map.get(user_id, [])&#10;            if not user_avails:&#10;                continue&#10;            user_timeoffs = timeoff_map.get(user_id, [])&#10;            user_bookings = booking_map.get(user_id, [])&#10;            availability = crud_availability.calculate_availability(&#10;                availabilities=user_avails,&#10;                time_offs=user_timeoffs,&#10;                bookings=user_bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;            results.append(availability)&#10;        if not results:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availabilities found for any user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        return DataResponse.success_response(&#10;            data=results,&#10;            message=&quot;Availabilities retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availabilities: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;" />
              <option name="updatedContent" value="from fastapi import APIRouter, Depends, HTTPException, status, Response, Query&#10;from pydantic import UUID4&#10;from sqlalchemy.orm import Session&#10;from datetime import datetime, date, timedelta&#10;from app.db.session import get_db&#10;from app.schemas.auth import LoginRequest, TokenResponse&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import ResponseMessage&#10;from app.schemas.schemas import UserCreate,AvailabilityResponse&#10;from app.services.auth import hash_password, verify_password, create_token_pair&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import booking as crud_booking&#10;from app.models.enums import AvailabilityType&#10;from app.services.crud import user_availability as crud_availability&#10;&#10;&#10;router = APIRouter()&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=ResponseMessage, status_code=status.HTTP_201_CREATED)&#10;async def create_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    user_in: UserCreate&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Register a new user.&#10;    &quot;&quot;&quot;&#10;&#10;    try:&#10;        existing_customer = crud_user.get_by_email(&#10;            db=db,&#10;            email=user_in.email&#10;        )&#10;        if existing_customer:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return ResponseMessage(message=&quot;User with this email already exists for this business&quot;, status=&quot;error&quot;)&#10;&#10;        user_in.password = hash_password(user_in.password)&#10;        crud_user.create(db=db, obj_in=user_in)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return ResponseMessage(message=&quot;User created successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;# @router.get(&quot;/me&quot;, response_model=Professional)&#10;# async def get_current_professional_info(&#10;#     current_professional: Professional = Depends(get_current_active_professional)&#10;# ) -&gt; Professional:&#10;#     &quot;&quot;&quot;&#10;#     Get current professional's information from JWT token.&#10;#     &quot;&quot;&quot;&#10;#     return current_professional&#10;#&#10;#&#10;# @router.get(&quot;/{professional_id}&quot;, response_model=Professional)&#10;# async def get_professional(&#10;#     professional_id: int,&#10;#     db: Session = Depends(get_db),&#10;#     current_professional: Professional = Depends(get_current_active_professional)&#10;# ) -&gt; Professional:&#10;#     &quot;&quot;&quot;&#10;#     Get professional by ID. Requires authentication.&#10;#     &quot;&quot;&quot;&#10;#     # Check if the requesting professional is trying to access their own data or has permission&#10;#     if current_professional.id != professional_id:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_403_FORBIDDEN,&#10;#             detail=&quot;Not authorized to access this professional's information&quot;&#10;#         )&#10;#&#10;#     professional = crud_professional.get(db=db, id=professional_id)&#10;#     if not professional:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_404_NOT_FOUND,&#10;#             detail=&quot;Professional not found&quot;&#10;#         )&#10;#     return professional&#10;#&#10;#&#10;# @router.put(&quot;/{professional_id}&quot;, response_model=Professional)&#10;# async def update_professional(&#10;#     *,&#10;#     db: Session = Depends(get_db),&#10;#     professional_id: int,&#10;#     professional_in: ProfessionalUpdate,&#10;#     current_professional: Professional = Depends(get_current_active_professional)&#10;# ) -&gt; Professional:&#10;#     &quot;&quot;&quot;&#10;#     Update professional. Requires authentication.&#10;#     &quot;&quot;&quot;&#10;#     # Check if the requesting professional is trying to update their own data&#10;#     if current_professional.id != professional_id:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_403_FORBIDDEN,&#10;#             detail=&quot;Not authorized to update this professional's information&quot;&#10;#         )&#10;#&#10;#     professional = crud_professional.get(db=db, id=professional_id)&#10;#     if not professional:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_404_NOT_FOUND,&#10;#             detail=&quot;Professional not found&quot;&#10;#         )&#10;#&#10;#     professional = crud_professional.update(db=db, db_obj=professional, obj_in=professional_in)&#10;#     return professional&#10;#&#10;#&#10;# @router.get(&quot;/mobile/{mobile_number}&quot;, response_model=Professional)&#10;# async def get_professional_by_mobile(&#10;#     mobile_number: str,&#10;#     db: Session = Depends(get_db),&#10;#     current_professional: Professional = Depends(get_current_active_professional)&#10;# ) -&gt; Professional:&#10;#     &quot;&quot;&quot;&#10;#     Get professional by mobile number. Requires authentication.&#10;#     &quot;&quot;&quot;&#10;#     professional = crud_professional.get_by_mobile(db=db, mobile_number=mobile_number)&#10;#     if not professional:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_404_NOT_FOUND,&#10;#             detail=&quot;Professional not found&quot;&#10;#         )&#10;#&#10;#     # Check if the requesting professional is trying to access their own data&#10;#     if current_professional.id != professional.id:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_403_FORBIDDEN,&#10;#             detail=&quot;Not authorized to access this professional's information&quot;&#10;#         )&#10;#&#10;#     return professional&#10;#&#10;#&#10;@router.post(&quot;/auth/login&quot;, response_model=TokenResponse)&#10;async def user_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; TokenResponse:&#10;    &quot;&quot;&quot;&#10;    Login professional using mobile number or email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    # Try to get professional by mobile number first&#10;    user = crud_user.get_by_email(db, email=login_data.email)&#10;&#10;    if not user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Verify password&#10;    if not verify_password(login_data.password, user.password):&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Create token pair&#10;    tokens = create_token_pair(user.id, user.email, actor=&quot;user&quot;, ver=&quot;1&quot;)&#10;    response.set_cookie(&#10;        key=&quot;refresh_token&quot;,&#10;        value=tokens[&quot;refresh_token&quot;],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;strict&quot;&#10;    )&#10;    return TokenResponse(**tokens)&#10;&#10;#&#10;# @router.post(&quot;/refresh-token&quot;, response_model=TokenResponse)&#10;# async def refresh_token(&#10;#     refresh_data: RefreshTokenRequest&#10;# ) -&gt; TokenResponse:&#10;#     &quot;&quot;&quot;&#10;#     Refresh access token using refresh token.&#10;#     &quot;&quot;&quot;&#10;#     tokens = refresh_access_token(refresh_data.refresh_token)&#10;#     if not tokens:&#10;#         raise HTTPException(&#10;#             status_code=status.HTTP_401_UNAUTHORIZED,&#10;#             detail=&quot;Invalid refresh token&quot;&#10;#         )&#10;#&#10;#     return TokenResponse(**tokens)&#10;#&#10;#&#10;@router.put(&quot;/auth/logout&quot;)&#10;async def logout_user(response: Response):&#10;    &quot;&quot;&quot;&#10;    Logout professional by clearing the refresh token cookie&#10;    &quot;&quot;&quot;&#10;    try:&#10;        response.delete_cookie(key=&quot;refresh_token&quot;)&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.get(&quot;/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db)&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get user's regular availability&#10;        availabilities = crud_availability.get_user_availabilities(db, user_id=user_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = crud_availability.get_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, and existing bookings&#10;            availability = crud_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/availabilities&quot;, response_model=DataResponse[list[AvailabilityResponse]])&#10;async def get_all_users_availabilities(&#10;    *,&#10;    availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;    date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse[list[AvailabilityResponse]]:&#10;    &quot;&quot;&quot;&#10;    Get availabilities for all users for a specific time range. Optimized to fetch all data in bulk and group bookings by user via BookingServices.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        users = crud_user.get_all(db)&#10;        if not users:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No users found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        # Bulk fetch all related data&#10;        availabilities = crud_availability.get_all_availabilities(db)&#10;        time_offs = crud_availability.get_all_time_offs(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        booking_tuples = crud_booking.get_all_bookings_in_range(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        # Group data by user&#10;        avail_map = {}&#10;        for a in availabilities:&#10;            avail_map.setdefault(str(a.user_id), []).append(a)&#10;        timeoff_map = {}&#10;        for t in time_offs:&#10;            timeoff_map.setdefault(str(t.user_id), []).append(t)&#10;        booking_map = {}&#10;        for booking, user_id in booking_tuples:&#10;            booking_map.setdefault(str(user_id), []).append(booking)&#10;        results = []&#10;        for user in users:&#10;            user_id = str(user.id)&#10;            user_avails = avail_map.get(user_id, [])&#10;            if not user_avails:&#10;                continue&#10;            user_timeoffs = timeoff_map.get(user_id, [])&#10;            user_bookings = booking_map.get(user_id, [])&#10;            availability = crud_availability.calculate_availability(&#10;                availabilities=user_avails,&#10;                time_offs=user_timeoffs,&#10;                bookings=user_bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;            results.append(availability)&#10;        if not results:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availabilities found for any user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        return DataResponse.success_response(&#10;            data=results,&#10;            message=&quot;Availabilities retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availabilities: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/schemas/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/schemas/schemas.py" />
              <option name="originalContent" value="from datetime import datetime, date&#10;from typing import Optional, List&#10;from pydantic import BaseModel, EmailStr, ConfigDict, UUID4&#10;&#10;from app.models import CustomerStatusType&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    mobile_number: Optional[str] = None&#10;    country: Optional[str] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: str&#10;    status: CustomerStatusType&#10;&#10;&#10;# class CompanyUser(BaseModel):&#10;#     id: str&#10;#     user_id: str&#10;#     company_id: str&#10;&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.inactive&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: str&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    company_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: UUID4&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    service_id: Optional[int] = None&#10;    client_id: Optional[int] = None&#10;    start_time: Optional[datetime] = None&#10;    end_time: Optional[datetime] = None&#10;    status: Optional[str] = None&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;&#10;#&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;" />
              <option name="updatedContent" value="from datetime import datetime, date, time&#10;from typing import Optional, List&#10;from pydantic import BaseModel, EmailStr, ConfigDict, UUID4&#10;&#10;from app.models import CustomerStatusType&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    mobile_number: Optional[str] = None&#10;    country: Optional[str] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: str&#10;    status: CustomerStatusType&#10;&#10;&#10;# class CompanyUser(BaseModel):&#10;#     id: str&#10;#     user_id: str&#10;#     company_id: str&#10;&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.inactive&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: str&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    company_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: UUID4&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    service_id: Optional[int] = None&#10;    client_id: Optional[int] = None&#10;    start_time: Optional[datetime] = None&#10;    end_time: Optional[datetime] = None&#10;    status: Optional[str] = None&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;&#10;#&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: str&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/booking.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/booking.py" />
              <option name="originalContent" value="from datetime import timedelta&#10;from typing import List, Optional, Any&#10;from datetime import date&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import BookingServices&#10;from app.models.models import Bookings&#10;from app.schemas import BookingServiceRequest&#10;from app.schemas.schemas import BookingCreate&#10;from app.services.crud import service&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Bookings]:&#10;    return db.query(Bookings).filter(Bookings.id == id).first()&#10;&#10;&#10;def get_all(db: Session, skip: int = 0, limit: int = 100) -&gt; list[type[Bookings]]:&#10;    return list(db.query(Bookings).offset(skip).limit(limit).all())&#10;&#10;def get_user_bookings_in_range(db: Session, user_id: str, start_date: Any, end_date: Any) -&gt; list[&quot;Bookings&quot;]:&#10;    return list(db.query(Bookings).join(BookingServices).filter(&#10;        BookingServices.user_id == user_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all())&#10;&#10;def get_all_bookings_in_range(db: Session, start_date: date, end_date: date):&#10;    # Join Bookings and BookingServices, return tuples of (booking, user_id)&#10;    return db.query(Bookings, BookingServices.user_id).join(BookingServices, Bookings.id == BookingServices.booking_id).filter(&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all()&#10;#&#10;#     def get_multi_by_business(self, db: Session, business_id: int, skip: int = 0, limit: int = 100) -&gt; List[Appointment]:&#10;#         return db.query(Appointment).filter(Appointment.business_id == business_id).offset(skip).limit(limit).all()&#10;#&#10;#     def get_multi_by_client(self, db: Session, client_id: int, skip: int = 0, limit: int = 100) -&gt; List[Appointment]:&#10;#         return db.query(Appointment).filter(Appointment.client_id == client_id).offset(skip).limit(limit).all()&#10;#&#10;&#10;&#10;def calc_service_params(db, services: List[BookingServiceRequest]):&#10;    total_duration = 0&#10;    total_price = 0&#10;&#10;    for srv in services:&#10;        selected_srv = service.get_company_service(db, srv.company_service_id)&#10;        total_duration += selected_srv.custom_duration&#10;        total_price += int(selected_srv.custom_price)&#10;&#10;    return total_duration, total_price&#10;&#10;&#10;&#10;def create(self, db: Session, *, obj_in: BookingCreate, customer_id: UUID4) -&gt; Bookings:&#10;    total_duration, total_price = self.calc_service_params(db, obj_in.services)&#10;    db_obj = Bookings(&#10;        customer_id=customer_id,&#10;        company_id=obj_in.company_id,&#10;        start_at=obj_in.start_time,&#10;        end_at= obj_in.start_time + timedelta(minutes=total_duration),&#10;        total_price=total_price,&#10;        notes=obj_in.notes&#10;    )&#10;    db.add(db_obj)&#10;    db.commit()&#10;&#10;    start_time = obj_in.start_time&#10;    for srv in obj_in.services:&#10;        duration, _ = self.calc_service_params(db, obj_in.services)&#10;        db_service_obj = BookingServices(&#10;            booking_id=db_obj.id,&#10;            company_service_id=srv.company_service_id,&#10;            user_id=srv.user_id,&#10;            notes=srv.notes,&#10;            start_at=start_time,&#10;            end_at=start_time + timedelta(minutes=duration)&#10;        )&#10;        start_time = db_service_obj.end_at&#10;        db.add(db_service_obj)&#10;&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj" />
              <option name="updatedContent" value="from datetime import timedelta&#10;from typing import List, Optional, Any&#10;from datetime import date&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import BookingServices&#10;from app.models.models import Bookings&#10;from app.schemas import BookingServiceRequest&#10;from app.schemas.schemas import BookingCreate&#10;from app.services.crud import service&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Bookings]:&#10;    return db.query(Bookings).filter(Bookings.id == id).first()&#10;&#10;&#10;def get_all(db: Session, skip: int = 0, limit: int = 100) -&gt; list[type[Bookings]]:&#10;    return list(db.query(Bookings).offset(skip).limit(limit).all())&#10;&#10;def get_user_bookings_in_range(db: Session, user_id: str, start_date: Any, end_date: Any) -&gt; list[&quot;Bookings&quot;]:&#10;    return list(db.query(Bookings).join(BookingServices).filter(&#10;        BookingServices.user_id == user_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all())&#10;&#10;def get_all_bookings_in_range(db: Session, start_date: date, end_date: date):&#10;    # Join Bookings and BookingServices, return tuples of (booking, user_id)&#10;    return db.query(Bookings, BookingServices.user_id).join(BookingServices, Bookings.id == BookingServices.booking_id).filter(&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all()&#10;#&#10;#     def get_multi_by_business(self, db: Session, business_id: int, skip: int = 0, limit: int = 100) -&gt; List[Appointment]:&#10;#         return db.query(Appointment).filter(Appointment.business_id == business_id).offset(skip).limit(limit).all()&#10;#&#10;#     def get_multi_by_client(self, db: Session, client_id: int, skip: int = 0, limit: int = 100) -&gt; List[Appointment]:&#10;#         return db.query(Appointment).filter(Appointment.client_id == client_id).offset(skip).limit(limit).all()&#10;#&#10;&#10;&#10;def calc_service_params(db, services: List[BookingServiceRequest]):&#10;    total_duration = 0&#10;    total_price = 0&#10;&#10;    for srv in services:&#10;        selected_srv = service.get_company_service(db, srv.company_service_id)&#10;        total_duration += selected_srv.custom_duration&#10;        total_price += int(selected_srv.custom_price)&#10;&#10;    return total_duration, total_price&#10;&#10;&#10;&#10;def create(self, db: Session, *, obj_in: BookingCreate, customer_id: UUID4) -&gt; Bookings:&#10;    total_duration, total_price = self.calc_service_params(db, obj_in.services)&#10;    db_obj = Bookings(&#10;        customer_id=customer_id,&#10;        company_id=obj_in.company_id,&#10;        start_at=obj_in.start_time,&#10;        end_at= obj_in.start_time + timedelta(minutes=total_duration),&#10;        total_price=total_price,&#10;        notes=obj_in.notes&#10;    )&#10;    db.add(db_obj)&#10;    db.commit()&#10;&#10;    start_time = obj_in.start_time&#10;    for srv in obj_in.services:&#10;        duration, _ = self.calc_service_params(db, obj_in.services)&#10;        db_service_obj = BookingServices(&#10;            booking_id=db_obj.id,&#10;            company_service_id=srv.company_service_id,&#10;            user_id=srv.user_id,&#10;            notes=srv.notes,&#10;            start_at=start_time,&#10;            end_at=start_time + timedelta(minutes=duration)&#10;        )&#10;        start_time = db_service_obj.end_at&#10;        db.add(db_service_obj)&#10;&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/user_availability.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/user_availability.py" />
              <option name="originalContent" value="from typing import List, Optional, Any&#10;from datetime import datetime, date, time, timedelta&#10;from sqlalchemy.orm import Session&#10;from app.models.models import UserAvailabilities, UserTimeOffs&#10;from app.models.enums import AvailabilityType&#10;from app.schemas.schemas import (&#10;    TimeSlot,&#10;    DailyAvailability,&#10;    WeeklyAvailability,&#10;    MonthlyAvailability,&#10;    AvailabilityResponse&#10;)&#10;&#10;def get_user_availabilities(db: Session, user_id: str) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Get all availability entries for a user&quot;&quot;&quot;&#10;    return list(db.query(UserAvailabilities).filter(UserAvailabilities.user_id == user_id,&#10;                                                    UserAvailabilities.is_available == True).all())&#10;&#10;def get_user_time_offs(&#10;    db: Session,&#10;    user_id: str,&#10;    start_date: date,&#10;    end_date: date&#10;) -&gt; List[UserTimeOffs]:&#10;    &quot;&quot;&quot;Get all time-offs for a user within a date range&quot;&quot;&quot;&#10;    return list(db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;def get_all_availabilities(db: Session):&#10;    &quot;&quot;&quot;Get all available user availabilities&quot;&quot;&quot;&#10;    return db.query(UserAvailabilities).filter(UserAvailabilities.is_available == True).all()&#10;&#10;def get_all_time_offs(db: Session, start_date: date, end_date: date):&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all()&#10;&#10;def subtract_intervals(base_start: time, base_end: time, intervals: List[tuple]) -&gt; List[tuple]:&#10;    &quot;&quot;&quot;Subtract intervals (bookings/time-offs) from a base interval. Returns list of available intervals.&quot;&quot;&quot;&#10;    result = [(base_start, base_end)]&#10;    for interval_start, interval_end in intervals:&#10;        new_result = []&#10;        for avail_start, avail_end in result:&#10;            # If no overlap, keep as is&#10;            if interval_end &lt;= avail_start or interval_start &gt;= avail_end:&#10;                new_result.append((avail_start, avail_end))&#10;            else:&#10;                # Overlap: split interval&#10;                if interval_start &gt; avail_start:&#10;                    new_result.append((avail_start, interval_start))&#10;                if interval_end &lt; avail_end:&#10;                    new_result.append((interval_end, avail_end))&#10;        result = new_result&#10;    return result&#10;&#10;def get_daily_slots(target_date: date, availabilities: List[UserAvailabilities], time_offs: List[UserTimeOffs], bookings: List[Any]) -&gt; DailyAvailability:&#10;    day_of_week = target_date.weekday()&#10;    day_availabilities = [a for a in availabilities if a.day_of_week == day_of_week]&#10;    # Collect intervals to subtract (bookings and time-offs)&#10;    subtract_intervals_list = []&#10;    for time_off in time_offs:&#10;        if time_off.start_date &lt;= target_date &lt;= time_off.end_date:&#10;            subtract_intervals_list.append((time(0,0), time(23,59)))&#10;    for booking in bookings:&#10;        if booking.start_at.date() == target_date:&#10;            subtract_intervals_list.append((booking.start_at.time(), booking.end_at.time()))&#10;    time_slots = []&#10;    for avail in day_availabilities:&#10;        available_intervals = subtract_intervals(avail.start_time, avail.end_time, subtract_intervals_list)&#10;        for start, end in available_intervals:&#10;            if start &lt; end:&#10;                time_slots.append(TimeSlot(&#10;                    start_time=start,&#10;                    end_time=end,&#10;                    is_available=True&#10;                ))&#10;    return DailyAvailability(&#10;        date=target_date,&#10;        time_slots=time_slots&#10;    )&#10;&#10;def calculate_availability(&#10;    availabilities: List[UserAvailabilities],&#10;    time_offs: List[UserTimeOffs],&#10;    bookings: List[Any],&#10;    availability_type: AvailabilityType,&#10;    date_from: date&#10;) -&gt; AvailabilityResponse:&#10;    &quot;&quot;&quot;Calculate availability based on working hours, time-offs, and bookings&quot;&quot;&quot;&#10;    try:&#10;        if not availabilities:&#10;            return AvailabilityResponse(&#10;                user_id=None,&#10;                availability_type=availability_type,&#10;                daily=None,&#10;                weekly=None,&#10;                monthly=None&#10;            )&#10;        if availability_type == AvailabilityType.DAILY:&#10;            daily = get_daily_slots(date_from, availabilities, time_offs, bookings)&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                daily=daily&#10;            )&#10;        elif availability_type == AvailabilityType.WEEKLY:&#10;            week_start = date_from - timedelta(days=date_from.weekday())&#10;            week_end = week_start + timedelta(days=6)&#10;            daily_slots = []&#10;            current_date = week_start&#10;            while current_date &lt;= week_end:&#10;                daily_slots.append(get_daily_slots(current_date, availabilities, time_offs, bookings))&#10;                current_date += timedelta(days=1)&#10;            weekly = WeeklyAvailability(&#10;                week_start_date=week_start,&#10;                week_end_date=week_end,&#10;                daily_slots=daily_slots&#10;            )&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                weekly=weekly&#10;            )&#10;        else:  # MONTHLY&#10;            month_start = date_from.replace(day=1)&#10;            if month_start.month == 12:&#10;                month_end = month_start.replace(year=month_start.year + 1, month=1, day=1) - timedelta(days=1)&#10;            else:&#10;                month_end = month_start.replace(month=month_start.month + 1, day=1) - timedelta(days=1)&#10;            weekly_slots = []&#10;            current_date = month_start&#10;            while current_date &lt;= month_end:&#10;                week_start = current_date - timedelta(days=current_date.weekday())&#10;                week_end = min(week_start + timedelta(days=6), month_end)&#10;                daily_slots = []&#10;                week_date = week_start&#10;                while week_date &lt;= week_end:&#10;                    if month_start &lt;= week_date &lt;= month_end:&#10;                        daily_slots.append(get_daily_slots(week_date, availabilities, time_offs, bookings))&#10;                    week_date += timedelta(days=1)&#10;                weekly_slots.append(WeeklyAvailability(&#10;                    week_start_date=week_start,&#10;                    week_end_date=week_end,&#10;                    daily_slots=daily_slots&#10;                ))&#10;                current_date = week_end + timedelta(days=1)&#10;            monthly = MonthlyAvailability(&#10;                month=date_from.month,&#10;                year=date_from.year,&#10;                weekly_slots=weekly_slots&#10;            )&#10;&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                monthly=monthly&#10;            )&#10;    except Exception as ex:&#10;        print(f&quot;Error calculating availability: {ex}&quot;)&#10;        raise" />
              <option name="updatedContent" value="from typing import List, Optional, Any&#10;from datetime import datetime, date, time, timedelta&#10;from sqlalchemy.orm import Session&#10;from app.models.models import UserAvailabilities, UserTimeOffs&#10;from app.models.enums import AvailabilityType&#10;from app.schemas.schemas import (&#10;    TimeSlot,&#10;    DailyAvailability,&#10;    WeeklyAvailability,&#10;    MonthlyAvailability,&#10;    AvailabilityResponse&#10;)&#10;&#10;def get_user_availabilities(db: Session, user_id: str) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Get all availability entries for a user&quot;&quot;&quot;&#10;    return list(db.query(UserAvailabilities).filter(UserAvailabilities.user_id == user_id,&#10;                                                    UserAvailabilities.is_available == True).all())&#10;&#10;def get_user_time_offs(&#10;    db: Session,&#10;    user_id: str,&#10;    start_date: date,&#10;    end_date: date&#10;) -&gt; List[UserTimeOffs]:&#10;    &quot;&quot;&quot;Get all time-offs for a user within a date range&quot;&quot;&quot;&#10;    return list(db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;def get_all_availabilities(db: Session):&#10;    &quot;&quot;&quot;Get all available user availabilities&quot;&quot;&quot;&#10;    return db.query(UserAvailabilities).filter(UserAvailabilities.is_available == True).all()&#10;&#10;def get_all_time_offs(db: Session, start_date: date, end_date: date):&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all()&#10;&#10;def subtract_intervals(base_start: time, base_end: time, intervals: List[tuple]) -&gt; List[tuple]:&#10;    &quot;&quot;&quot;Subtract intervals (bookings/time-offs) from a base interval. Returns list of available intervals.&quot;&quot;&quot;&#10;    result = [(base_start, base_end)]&#10;    for interval_start, interval_end in intervals:&#10;        new_result = []&#10;        for avail_start, avail_end in result:&#10;            # If no overlap, keep as is&#10;            if interval_end &lt;= avail_start or interval_start &gt;= avail_end:&#10;                new_result.append((avail_start, avail_end))&#10;            else:&#10;                # Overlap: split interval&#10;                if interval_start &gt; avail_start:&#10;                    new_result.append((avail_start, interval_start))&#10;                if interval_end &lt; avail_end:&#10;                    new_result.append((interval_end, avail_end))&#10;        result = new_result&#10;    return result&#10;&#10;def get_daily_slots(target_date: date, availabilities: List[UserAvailabilities], time_offs: List[UserTimeOffs], bookings: List[Any]) -&gt; DailyAvailability:&#10;    day_of_week = target_date.weekday()&#10;    day_availabilities = [a for a in availabilities if a.day_of_week == day_of_week]&#10;    # Collect intervals to subtract (bookings and time-offs)&#10;    subtract_intervals_list = []&#10;    for time_off in time_offs:&#10;        if time_off.start_date &lt;= target_date &lt;= time_off.end_date:&#10;            subtract_intervals_list.append((time(0,0), time(23,59)))&#10;    for booking in bookings:&#10;        if booking.start_at.date() == target_date:&#10;            subtract_intervals_list.append((booking.start_at.time(), booking.end_at.time()))&#10;    time_slots = []&#10;    for avail in day_availabilities:&#10;        available_intervals = subtract_intervals(avail.start_time, avail.end_time, subtract_intervals_list)&#10;        for start, end in available_intervals:&#10;            if start &lt; end:&#10;                time_slots.append(TimeSlot(&#10;                    start_time=start,&#10;                    end_time=end,&#10;                    is_available=True&#10;                ))&#10;    return DailyAvailability(&#10;        date=target_date,&#10;        time_slots=time_slots&#10;    )&#10;&#10;def calculate_availability(&#10;    availabilities: List[UserAvailabilities],&#10;    time_offs: List[UserTimeOffs],&#10;    bookings: List[Any],&#10;    availability_type: AvailabilityType,&#10;    date_from: date&#10;) -&gt; AvailabilityResponse:&#10;    &quot;&quot;&quot;Calculate availability based on working hours, time-offs, and bookings&quot;&quot;&quot;&#10;    try:&#10;        if not availabilities:&#10;            return AvailabilityResponse(&#10;                user_id=None,&#10;                availability_type=availability_type,&#10;                daily=None,&#10;                weekly=None,&#10;                monthly=None&#10;            )&#10;        if availability_type == AvailabilityType.DAILY:&#10;            daily = get_daily_slots(date_from, availabilities, time_offs, bookings)&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                daily=daily&#10;            )&#10;        elif availability_type == AvailabilityType.WEEKLY:&#10;            week_start = date_from - timedelta(days=date_from.weekday())&#10;            week_end = week_start + timedelta(days=6)&#10;            daily_slots = []&#10;            current_date = week_start&#10;            while current_date &lt;= week_end:&#10;                daily_slots.append(get_daily_slots(current_date, availabilities, time_offs, bookings))&#10;                current_date += timedelta(days=1)&#10;            weekly = WeeklyAvailability(&#10;                week_start_date=week_start,&#10;                week_end_date=week_end,&#10;                daily_slots=daily_slots&#10;            )&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                weekly=weekly&#10;            )&#10;        else:  # MONTHLY&#10;            month_start = date_from.replace(day=1)&#10;            if month_start.month == 12:&#10;                month_end = month_start.replace(year=month_start.year + 1, month=1, day=1) - timedelta(days=1)&#10;            else:&#10;                month_end = month_start.replace(month=month_start.month + 1, day=1) - timedelta(days=1)&#10;            weekly_slots = []&#10;            current_date = month_start&#10;            while current_date &lt;= month_end:&#10;                week_start = current_date - timedelta(days=current_date.weekday())&#10;                week_end = min(week_start + timedelta(days=6), month_end)&#10;                daily_slots = []&#10;                week_date = week_start&#10;                while week_date &lt;= week_end:&#10;                    if month_start &lt;= week_date &lt;= month_end:&#10;                        daily_slots.append(get_daily_slots(week_date, availabilities, time_offs, bookings))&#10;                    week_date += timedelta(days=1)&#10;                weekly_slots.append(WeeklyAvailability(&#10;                    week_start_date=week_start,&#10;                    week_end_date=week_end,&#10;                    daily_slots=daily_slots&#10;                ))&#10;                current_date = week_end + timedelta(days=1)&#10;            monthly = MonthlyAvailability(&#10;                month=date_from.month,&#10;                year=date_from.year,&#10;                weekly_slots=weekly_slots&#10;            )&#10;&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                monthly=monthly&#10;            )&#10;    except Exception as ex:&#10;        print(f&quot;Error calculating availability: {ex}&quot;)&#10;        raise" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>