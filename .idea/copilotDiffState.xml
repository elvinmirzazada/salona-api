<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/core/redis_client.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/core/redis_client.py" />
              <option name="originalContent" value="import redis&#10;import os&#10;&#10;REDIS_URL = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://localhost:6379/0&quot;)&#10;&#10;redis_client = redis.Redis.from_url(REDIS_URL, decode_responses=True)&#10;&#10;def publish_event(channel: str, message: str):&#10;    &quot;&quot;&quot;Publish a message to a Redis channel.&quot;&quot;&quot;&#10;    redis_client.publish(channel, message)&#10;" />
              <option name="updatedContent" value="import redis&#10;import os&#10;&#10;REDIS_URL = os.getenv(&quot;REDIS_URL&quot;, &quot;redis://localhost:6379/0&quot;)&#10;&#10;redis_client = redis.Redis.from_url(REDIS_URL, decode_responses=True)&#10;&#10;def publish_event(channel: str, message: str):&#10;    &quot;&quot;&quot;Publish a message to a Redis channel.&quot;&quot;&quot;&#10;    redis_client.publish(channel, message)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/models/enums.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/models/enums.py" />
              <option name="originalContent" value="from enum import Enum&#10;&#10;&#10;class GenderType(str, Enum):&#10;    MALE = &quot;male&quot;&#10;    FEMALE = &quot;female&quot;&#10;    OTHER = &quot;other&quot;&#10;    PREFER_NOT_TO_SAY = &quot;prefer_not_to_say&quot;&#10;&#10;&#10;class StatusType(str, Enum):&#10;    active = &quot;active&quot;&#10;    inactive = &quot;inactive&quot;&#10;    suspended = &quot;suspended&quot;&#10;&#10;&#10;class EmailStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class CustomerEmailStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class PhoneStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class CompanyRoleType(str, Enum):&#10;    owner = &quot;owner&quot;&#10;    admin = &quot;admin&quot;&#10;    staff = &quot;staff&quot;&#10;    viewer = &quot;viewer&quot;&#10;&#10;class CustomerStatusType(str, Enum):&#10;    active = &quot;active&quot;&#10;    pending_verification = &quot;pending_verification&quot;&#10;    disabled = &quot;disabled&quot;&#10;&#10;class PriceType(str, Enum):&#10;    FIXED = &quot;fixed&quot;&#10;    FROM = &quot;from&quot;&#10;    FREE = &quot;free&quot;&#10;&#10;&#10;class SourceType(str, Enum):&#10;    WALK_IN = &quot;walk_in&quot;&#10;    WEBSITE = &quot;website&quot;&#10;    REFERRAL = &quot;referral&quot;&#10;    SOCIAL_MEDIA = &quot;social_media&quot;&#10;    OTHER = &quot;other&quot;&#10;&#10;&#10;class BookingStatus(str, Enum):&#10;    SCHEDULED = &quot;scheduled&quot;&#10;    CONFIRMED = &quot;confirmed&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    COMPLETED = &quot;completed&quot;&#10;    NO_SHOW = &quot;no_show&quot;&#10;&#10;class VerificationType(str, Enum):&#10;    EMAIL = &quot;email&quot;&#10;    SMS = &quot;sms&quot;&#10;    TWO_FACTOR = &quot;two_factor&quot;&#10;&#10;class VerificationStatus(str, Enum):&#10;    PENDING = &quot;pending&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;    VERIFIED = &quot;verified&quot;&#10;&#10;class AvailabilityType(str, Enum):&#10;    DAILY = &quot;daily&quot;&#10;    WEEKLY = &quot;weekly&quot;&#10;    MONTHLY = &quot;monthly&quot;&#10;&#10;&#10;class NotificationType(str, Enum):&#10;    BOOKING_CREATED = &quot;booking_created&quot;&#10;    BOOKING_CONFIRMED = &quot;booking_confirmed&quot;&#10;    BOOKING_CANCELLED = &quot;booking_cancelled&quot;&#10;    BOOKING_REMINDER = &quot;booking_reminder&quot;&#10;    PAYMENT_SUCCESS = &quot;payment_success&quot;&#10;    PAYMENT_FAILED = &quot;payment_failed&quot;&#10;    GENERAL = &quot;general&quot;&#10;&#10;&#10;class NotificationStatus(str, Enum):&#10;    UNREAD = &quot;unread&quot;&#10;    READ = &quot;read&quot;&#10;    ARCHIVED = &quot;archived&quot;" />
              <option name="updatedContent" value="from enum import Enum&#10;&#10;&#10;class GenderType(str, Enum):&#10;    MALE = &quot;male&quot;&#10;    FEMALE = &quot;female&quot;&#10;    OTHER = &quot;other&quot;&#10;    PREFER_NOT_TO_SAY = &quot;prefer_not_to_say&quot;&#10;&#10;&#10;class StatusType(str, Enum):&#10;    active = &quot;active&quot;&#10;    inactive = &quot;inactive&quot;&#10;    suspended = &quot;suspended&quot;&#10;&#10;&#10;class EmailStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class CustomerEmailStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class PhoneStatusType(str, Enum):&#10;    primary = &quot;primary&quot;&#10;    secondary = &quot;secondary&quot;&#10;    unverified = &quot;unverified&quot;&#10;&#10;class CompanyRoleType(str, Enum):&#10;    owner = &quot;owner&quot;&#10;    admin = &quot;admin&quot;&#10;    staff = &quot;staff&quot;&#10;    viewer = &quot;viewer&quot;&#10;&#10;class CustomerStatusType(str, Enum):&#10;    active = &quot;active&quot;&#10;    pending_verification = &quot;pending_verification&quot;&#10;    disabled = &quot;disabled&quot;&#10;&#10;class PriceType(str, Enum):&#10;    FIXED = &quot;fixed&quot;&#10;    FROM = &quot;from&quot;&#10;    FREE = &quot;free&quot;&#10;&#10;&#10;class SourceType(str, Enum):&#10;    WALK_IN = &quot;walk_in&quot;&#10;    WEBSITE = &quot;website&quot;&#10;    REFERRAL = &quot;referral&quot;&#10;    SOCIAL_MEDIA = &quot;social_media&quot;&#10;    OTHER = &quot;other&quot;&#10;&#10;&#10;class BookingStatus(str, Enum):&#10;    SCHEDULED = &quot;scheduled&quot;&#10;    CONFIRMED = &quot;confirmed&quot;&#10;    CANCELLED = &quot;cancelled&quot;&#10;    COMPLETED = &quot;completed&quot;&#10;    NO_SHOW = &quot;no_show&quot;&#10;&#10;class VerificationType(str, Enum):&#10;    EMAIL = &quot;email&quot;&#10;    SMS = &quot;sms&quot;&#10;    TWO_FACTOR = &quot;two_factor&quot;&#10;&#10;class VerificationStatus(str, Enum):&#10;    PENDING = &quot;pending&quot;&#10;    EXPIRED = &quot;expired&quot;&#10;    VERIFIED = &quot;verified&quot;&#10;&#10;class AvailabilityType(str, Enum):&#10;    DAILY = &quot;daily&quot;&#10;    WEEKLY = &quot;weekly&quot;&#10;    MONTHLY = &quot;monthly&quot;&#10;&#10;&#10;class NotificationType(str, Enum):&#10;    BOOKING_CREATED = &quot;booking_created&quot;&#10;    BOOKING_CONFIRMED = &quot;booking_confirmed&quot;&#10;    BOOKING_CANCELLED = &quot;booking_cancelled&quot;&#10;    BOOKING_REMINDER = &quot;booking_reminder&quot;&#10;    PAYMENT_SUCCESS = &quot;payment_success&quot;&#10;    PAYMENT_FAILED = &quot;payment_failed&quot;&#10;    GENERAL = &quot;general&quot;&#10;&#10;&#10;class NotificationStatus(str, Enum):&#10;    UNREAD = &quot;unread&quot;&#10;    READ = &quot;read&quot;&#10;    ARCHIVED = &quot;archived&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/booking.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/booking.py" />
              <option name="originalContent" value="from datetime import timedelta&#10;from typing import List, Optional, Any&#10;from datetime import date&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import BookingServices, Customers&#10;from app.models.models import Bookings&#10;from app.models.enums import BookingStatus&#10;from app.schemas import BookingServiceRequest&#10;from app.schemas.schemas import BookingCreate, BookingUpdate&#10;from app.services.crud import service&#10;from app.core.redis_client import publish_event&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Bookings]:&#10;    return db.query(Bookings).filter(Bookings.id == id).first()&#10;&#10;&#10;def get_all(db: Session, skip: int = 0, limit: int = 100) -&gt; list[type[Bookings]]:&#10;    return list(db.query(Bookings).offset(skip).limit(limit).all())&#10;&#10;def get_user_bookings_in_range(db: Session, user_id: str, start_date: Any, end_date: Any) -&gt; list[&quot;Bookings&quot;]:&#10;    return list(db.query(Bookings).join(BookingServices).filter(&#10;        BookingServices.user_id == user_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all())&#10;&#10;def get_all_bookings_in_range(db: Session, start_date: date, end_date: date):&#10;    # Join Bookings and BookingServices, return tuples of (booking, user_id)&#10;    return db.query(Bookings, BookingServices.user_id).join(BookingServices, Bookings.id == BookingServices.booking_id).filter(&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all()&#10;&#10;&#10;def get_all_bookings_in_range_by_company(db: Session, company_id: str, start_date: date, end_date: date):&#10;    return (db.query(Bookings).join(BookingServices, Bookings.id == BookingServices.booking_id)&#10;          .filter(&#10;        Bookings.company_id == company_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date,&#10;        Bookings.status.in_(['scheduled', 'confirmed', 'completed'])&#10;    ).all())&#10;&#10;def calc_service_params(db, services: List[BookingServiceRequest], company_id: str = None) -&gt; tuple[int, int]:&#10;    total_duration = 0&#10;    total_price = 0&#10;&#10;    for srv in services:&#10;        selected_srv = service.get_service(db, srv.category_service_id, company_id)&#10;        total_duration += selected_srv.duration&#10;        total_price += int(selected_srv.price)&#10;&#10;    return total_duration, total_price&#10;&#10;&#10;def create(db: Session, *, obj_in: BookingCreate, customer_id: UUID4) -&gt; Bookings:&#10;    total_duration, total_price = calc_service_params(db, obj_in.services, obj_in.company_id)&#10;    db_obj = Bookings(&#10;        customer_id=customer_id,&#10;        company_id=obj_in.company_id,&#10;        start_at=obj_in.start_time,&#10;        end_at= obj_in.start_time + timedelta(minutes=total_duration),&#10;        total_price=total_price,&#10;        notes=obj_in.notes&#10;    )&#10;    db.add(db_obj)&#10;    db.commit()&#10;&#10;    start_time = obj_in.start_time&#10;    for srv in obj_in.services:&#10;        duration, _ = calc_service_params(db, [srv], obj_in.company_id)&#10;        db_service_obj = BookingServices(&#10;            booking_id=db_obj.id,&#10;            category_service_id=srv.category_service_id,&#10;            user_id=srv.user_id,&#10;            notes=srv.notes,&#10;            start_at=start_time,&#10;            end_at=start_time + timedelta(minutes=duration)&#10;        )&#10;        start_time = db_service_obj.end_at&#10;        db.add(db_service_obj)&#10;&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    # Publish booking created event&#10;    publish_event(&quot;booking_created&quot;, str(db_obj.id))&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Bookings, obj_in: BookingUpdate) -&gt; Bookings:&#10;    &quot;&quot;&quot;&#10;    Update a booking and its associated services.&#10;    &quot;&quot;&quot;&#10;    # Update basic booking fields&#10;    if obj_in.start_time is not None:&#10;        db_obj.start_at = obj_in.start_time&#10;    if obj_in.notes is not None:&#10;        db_obj.notes = obj_in.notes&#10;    if obj_in.status is not None:&#10;        db_obj.status = obj_in.status&#10;&#10;    # If services are being updated, we need to recalculate everything&#10;    if obj_in.services is not None:&#10;        # Remove existing booking services&#10;        db.query(BookingServices).filter(BookingServices.booking_id == db_obj.id).delete()&#10;&#10;        # Recalculate total duration and price&#10;        total_duration, total_price = calc_service_params(db, obj_in.services, str(db_obj.company_id))&#10;        db_obj.total_price = total_price&#10;&#10;        # Update end time based on new start time and duration&#10;        start_time = obj_in.start_time if obj_in.start_time is not None else db_obj.start_at&#10;        db_obj.end_at = start_time + timedelta(minutes=total_duration)&#10;&#10;        # Create new booking services&#10;        current_start_time = start_time&#10;        for srv in obj_in.services:&#10;            duration, _ = calc_service_params(db, [srv], str(db_obj.company_id))&#10;            db_service_obj = BookingServices(&#10;                booking_id=db_obj.id,&#10;                category_service_id=srv.category_service_id,&#10;                user_id=srv.user_id,&#10;                notes=srv.notes,&#10;                start_at=current_start_time,&#10;                end_at=current_start_time + timedelta(minutes=duration)&#10;            )&#10;            current_start_time = db_service_obj.end_at&#10;            db.add(db_service_obj)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def cancel(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by setting its status to CANCELLED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CANCELLED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None&#10;&#10;&#10;def confirm(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CONFIRMED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None&#10;" />
              <option name="updatedContent" value="from datetime import timedelta&#10;from typing import List, Optional, Any&#10;from datetime import date&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import BookingServices, Customers&#10;from app.models.models import Bookings&#10;from app.models.enums import BookingStatus&#10;from app.schemas import BookingServiceRequest&#10;from app.schemas.schemas import BookingCreate, BookingUpdate&#10;from app.services.crud import service&#10;from app.core.redis_client import publish_event&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Bookings]:&#10;    return db.query(Bookings).filter(Bookings.id == id).first()&#10;&#10;&#10;def get_all(db: Session, skip: int = 0, limit: int = 100) -&gt; list[type[Bookings]]:&#10;    return list(db.query(Bookings).offset(skip).limit(limit).all())&#10;&#10;def get_user_bookings_in_range(db: Session, user_id: str, start_date: Any, end_date: Any) -&gt; list[&quot;Bookings&quot;]:&#10;    return list(db.query(Bookings).join(BookingServices).filter(&#10;        BookingServices.user_id == user_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all())&#10;&#10;def get_all_bookings_in_range(db: Session, start_date: date, end_date: date):&#10;    # Join Bookings and BookingServices, return tuples of (booking, user_id)&#10;    return db.query(Bookings, BookingServices.user_id).join(BookingServices, Bookings.id == BookingServices.booking_id).filter(&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all()&#10;&#10;&#10;def get_all_bookings_in_range_by_company(db: Session, company_id: str, start_date: date, end_date: date):&#10;    return (db.query(Bookings).join(BookingServices, Bookings.id == BookingServices.booking_id)&#10;          .filter(&#10;        Bookings.company_id == company_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date,&#10;        Bookings.status.in_(['scheduled', 'confirmed', 'completed'])&#10;    ).all())&#10;&#10;def calc_service_params(db, services: List[BookingServiceRequest], company_id: str = None) -&gt; tuple[int, int]:&#10;    total_duration = 0&#10;    total_price = 0&#10;&#10;    for srv in services:&#10;        selected_srv = service.get_service(db, srv.category_service_id, company_id)&#10;        total_duration += selected_srv.duration&#10;        total_price += int(selected_srv.price)&#10;&#10;    return total_duration, total_price&#10;&#10;&#10;def create(db: Session, *, obj_in: BookingCreate, customer_id: UUID4) -&gt; Bookings:&#10;    total_duration, total_price = calc_service_params(db, obj_in.services, obj_in.company_id)&#10;    db_obj = Bookings(&#10;        customer_id=customer_id,&#10;        company_id=obj_in.company_id,&#10;        start_at=obj_in.start_time,&#10;        end_at= obj_in.start_time + timedelta(minutes=total_duration),&#10;        total_price=total_price,&#10;        notes=obj_in.notes&#10;    )&#10;    db.add(db_obj)&#10;    db.commit()&#10;&#10;    start_time = obj_in.start_time&#10;    for srv in obj_in.services:&#10;        duration, _ = calc_service_params(db, [srv], obj_in.company_id)&#10;        db_service_obj = BookingServices(&#10;            booking_id=db_obj.id,&#10;            category_service_id=srv.category_service_id,&#10;            user_id=srv.user_id,&#10;            notes=srv.notes,&#10;            start_at=start_time,&#10;            end_at=start_time + timedelta(minutes=duration)&#10;        )&#10;        start_time = db_service_obj.end_at&#10;        db.add(db_service_obj)&#10;&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    # Publish booking created event&#10;    publish_event(&quot;booking_created&quot;, str(db_obj.id))&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Bookings, obj_in: BookingUpdate) -&gt; Bookings:&#10;    &quot;&quot;&quot;&#10;    Update a booking and its associated services.&#10;    &quot;&quot;&quot;&#10;    # Update basic booking fields&#10;    if obj_in.start_time is not None:&#10;        db_obj.start_at = obj_in.start_time&#10;    if obj_in.notes is not None:&#10;        db_obj.notes = obj_in.notes&#10;    if obj_in.status is not None:&#10;        db_obj.status = obj_in.status&#10;&#10;    # If services are being updated, we need to recalculate everything&#10;    if obj_in.services is not None:&#10;        # Remove existing booking services&#10;        db.query(BookingServices).filter(BookingServices.booking_id == db_obj.id).delete()&#10;&#10;        # Recalculate total duration and price&#10;        total_duration, total_price = calc_service_params(db, obj_in.services, str(db_obj.company_id))&#10;        db_obj.total_price = total_price&#10;&#10;        # Update end time based on new start time and duration&#10;        start_time = obj_in.start_time if obj_in.start_time is not None else db_obj.start_at&#10;        db_obj.end_at = start_time + timedelta(minutes=total_duration)&#10;&#10;        # Create new booking services&#10;        current_start_time = start_time&#10;        for srv in obj_in.services:&#10;            duration, _ = calc_service_params(db, [srv], str(db_obj.company_id))&#10;            db_service_obj = BookingServices(&#10;                booking_id=db_obj.id,&#10;                category_service_id=srv.category_service_id,&#10;                user_id=srv.user_id,&#10;                notes=srv.notes,&#10;                start_at=current_start_time,&#10;                end_at=current_start_time + timedelta(minutes=duration)&#10;            )&#10;            current_start_time = db_service_obj.end_at&#10;            db.add(db_service_obj)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def cancel(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by setting its status to CANCELLED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CANCELLED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None&#10;&#10;&#10;def confirm(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CONFIRMED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>