<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/customers.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/customers.py" />
              <option name="originalContent" value="from typing import List&#10;from sqlalchemy import func&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response&#10;from sqlalchemy.orm import Session&#10;from app.db.session import get_db&#10;from app.schemas.schemas import Customer, CustomerCreate&#10;from app.schemas.auth import LoginRequest, TokenResponse, RefreshTokenRequest, VerificationRequest&#10;from app.services.crud import customer as crud_customer&#10;from app.schemas.schemas import ResponseMessage&#10;from app.services.auth import hash_password, verify_password, create_token_pair, refresh_access_token&#10;&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=Customer, status_code=status.HTTP_201_CREATED)&#10;def create_customer(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    customer_in: CustomerCreate&#10;) -&gt; Customer:&#10;    &quot;&quot;&quot;&#10;    Create a new customer.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        existing_customer = crud_customer.get_by_email(&#10;            db=db,&#10;            email=customer_in.email,&#10;            business_id=customer_in.business_id&#10;        )&#10;        if existing_customer:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                detail=&quot;Customer with this email already exists for this business&quot;&#10;            )&#10;        customer_in.password = hash_password(customer_in.password)&#10;        customer = crud_customer.create(db=db, obj_in=customer_in)&#10;        return customer&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=ResponseMessage)&#10;def get_customer(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Verify email.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_customer.get_verification_token(db=db, token=verification_in.token, type=&quot;email&quot;)&#10;        if not token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                detail=&quot;Token not found&quot;&#10;            )&#10;        if token.status != &quot;pending&quot; or token.expires_at &lt; func.now():&#10;            raise HTTPException(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                detail=&quot;Invalid or expired token&quot;&#10;            )&#10;        result = crud_customer.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return ResponseMessage(message=&quot;Email verified successfully&quot;)&#10;        return ResponseMessage(message=&quot;Email verification failed&quot;)&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=TokenResponse)&#10;async def customer_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; TokenResponse:&#10;    &quot;&quot;&quot;&#10;    Login customer using email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        customer = crud_customer.get_by_email(db, email=login_data.email)&#10;        if not customer:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid credentials&quot;&#10;            )&#10;        if customer.status != &quot;active&quot;:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                detail=&quot;Customer account is not active&quot;&#10;            )&#10;        if not verify_password(login_data.password, customer.password):&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid credentials&quot;&#10;            )&#10;        tokens = create_token_pair(customer.id, customer.email, actor=&quot;customer&quot;, ver=&quot;1&quot;)&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        return TokenResponse(**tokens)&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=TokenResponse)&#10;async def refresh_token(&#10;    refresh_data: RefreshTokenRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; TokenResponse:&#10;    &quot;&quot;&quot;&#10;    Refresh access token using refresh token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        tokens = refresh_access_token(refresh_data.refresh_token)&#10;        if not tokens:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid refresh token&quot;&#10;            )&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        return TokenResponse(**tokens)&#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;@router.put(&quot;/auth/logout&quot;, response_model=ResponseMessage)&#10;def logout_customer(&#10;    response: Response&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Logout customer by clearing the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        response.delete_cookie(key=&quot;refresh_token&quot;)&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;)&#10;    except Exception as e:&#10;        raise HTTPException(status_code=500, detail=f&quot;Internal server error: {str(e)}&quot;)&#10;&#10;# TODO: Add endpoints for password reset, forgot password, etc.&#10;" />
              <option name="updatedContent" value="from typing import List&#10;from sqlalchemy import func&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response&#10;from sqlalchemy.orm import Session&#10;from app.db.session import get_db&#10;from app.schemas.schemas import Customer, CustomerCreate&#10;from app.schemas.auth import LoginRequest, TokenResponse, RefreshTokenRequest, VerificationRequest&#10;from app.services.crud import customer as crud_customer&#10;from app.schemas.schemas import ResponseMessage&#10;from app.services.auth import hash_password, verify_password, create_token_pair, refresh_access_token&#10;&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=ResponseMessage, status_code=status.HTTP_201_CREATED)&#10;def create_customer(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    customer_in: CustomerCreate,&#10;    response: Response&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Create a new customer.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        existing_customer = crud_customer.get_by_email(&#10;            db=db,&#10;            email=customer_in.email,&#10;            business_id=customer_in.business_id&#10;        )&#10;        if existing_customer:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return ResponseMessage(message=&quot;Customer with this email already exists for this business&quot;, status=&quot;error&quot;)&#10;        customer_in.password = hash_password(customer_in.password)&#10;        crud_customer.create(db=db, obj_in=customer_in)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return ResponseMessage(message=&quot;Customer created successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=ResponseMessage)&#10;def get_customer(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest,&#10;    response: Response&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Verify email.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_customer.get_verification_token(db=db, token=verification_in.token, type=&quot;email&quot;)&#10;        if not token:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return ResponseMessage(message=&quot;Token not found&quot;, status=&quot;error&quot;)&#10;        if token.status != &quot;pending&quot; or token.expires_at &lt; func.now():&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return ResponseMessage(message=&quot;Invalid or expired token&quot;, status=&quot;error&quot;)&#10;        result = crud_customer.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return ResponseMessage(message=&quot;Email verified successfully&quot;, status=&quot;success&quot;)&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return ResponseMessage(message=&quot;Email verification failed&quot;, status=&quot;error&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=ResponseMessage)&#10;async def customer_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Login customer using email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        customer = crud_customer.get_by_email(db, email=login_data.email)&#10;        if not customer:&#10;            response.status_code = status.HTTP_401_UNAUTHORIZED&#10;            return ResponseMessage(message=&quot;Invalid credentials&quot;, status=&quot;error&quot;)&#10;        if customer.status != &quot;active&quot;:&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return ResponseMessage(message=&quot;Customer account is not active&quot;, status=&quot;error&quot;)&#10;        if not verify_password(login_data.password, customer.password):&#10;            response.status_code = status.HTTP_401_UNAUTHORIZED&#10;            return ResponseMessage(message=&quot;Invalid credentials&quot;, status=&quot;error&quot;)&#10;        tokens = create_token_pair(customer.id, customer.email, actor=&quot;customer&quot;, ver=&quot;1&quot;)&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        return ResponseMessage(message=&quot;Login successful&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=ResponseMessage)&#10;async def refresh_token(&#10;    refresh_data: RefreshTokenRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Refresh access token using refresh token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        tokens = refresh_access_token(refresh_data.refresh_token)&#10;        if not tokens:&#10;            response.status_code = status.HTTP_401_UNAUTHORIZED&#10;            return ResponseMessage(message=&quot;Invalid refresh token&quot;, status=&quot;error&quot;)&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        return ResponseMessage(message=&quot;Token refreshed successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;@router.put(&quot;/auth/logout&quot;, response_model=ResponseMessage)&#10;def logout_customer(&#10;    response: Response&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Logout customer by clearing the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        response.delete_cookie(key=&quot;refresh_token&quot;)&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;# TODO: Add endpoints for password reset, forgot password, etc." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>