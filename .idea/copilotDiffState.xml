<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/schemas/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/schemas/schemas.py" />
              <option name="originalContent" value="from datetime import datetime, date, time&#10;from typing import Optional, List&#10;from pydantic import BaseModel, EmailStr, ConfigDict, UUID4&#10;&#10;from app.models import CustomerStatusType, CompanyCategories&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    mobile_number: Optional[str] = None&#10;    country: Optional[str] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(TimestampedModel):&#10;    id: UUID4&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;&#10;    user: Optional[User] = None&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.inactive&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    id: Optional[UUID4] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: Optional[UUID4] = None&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    start_time: Optional[datetime] = None&#10;    notes: Optional[str] = None&#10;    status: Optional[BookingStatus] = None&#10;    services: Optional[List[BookingServiceRequest]] = None&#10;&#10;&#10;&#10;&#10;class BookingService(TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    booking_id: UUID4&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;    start_date: Optional[datetime] = None&#10;    end_date: Optional[datetime] = None&#10;&#10;    # service: Optional[CompanyCategories] = None&#10;    # assigned_user: Optional[CompanyUser] = None&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;    customer: Optional[Customer] = None&#10;    booking_services: Optional[List[BookingService]] = []&#10;&#10;&#10;#&#10;class CompanyCustomers(Company):&#10;&#10;    model_config = ConfigDict(from_attributes=True)&#10;    customers: List[Customer] = []&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: Optional[str]&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []&#10;&#10;# Time Off schemas&#10;class TimeOffBase(BaseModel):&#10;    start_date: date&#10;    end_date: date&#10;    user_id: UUID4&#10;    reason: Optional[str] = None&#10;&#10;class TimeOffCreate(TimeOffBase):&#10;    pass&#10;&#10;class TimeOffUpdate(BaseModel):&#10;    start_date: Optional[date] = None&#10;    end_date: Optional[date] = None&#10;    reason: Optional[str] = None&#10;&#10;class TimeOff(TimeOffBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user_id: UUID4&#10;&#10;" />
              <option name="updatedContent" value="from datetime import datetime, date, time&#10;from typing import Optional, List&#10;from pydantic import BaseModel, EmailStr, ConfigDict, UUID4&#10;&#10;from app.models import CustomerStatusType, CompanyCategories&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    mobile_number: Optional[str] = None&#10;    country: Optional[str] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(TimestampedModel):&#10;    id: UUID4&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;&#10;    user: Optional[User] = None&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.inactive&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    id: Optional[UUID4] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: Optional[UUID4] = None&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    start_time: Optional[datetime] = None&#10;    notes: Optional[str] = None&#10;    status: Optional[BookingStatus] = None&#10;    services: Optional[List[BookingServiceRequest]] = None&#10;&#10;&#10;&#10;&#10;class BookingService(TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    booking_id: UUID4&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;    start_date: Optional[datetime] = None&#10;    end_date: Optional[datetime] = None&#10;&#10;    # service: Optional[CompanyCategories] = None&#10;    # assigned_user: Optional[CompanyUser] = None&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;    customer: Optional[Customer] = None&#10;    booking_services: Optional[List[BookingService]] = []&#10;&#10;&#10;#&#10;class CompanyCustomers(Company):&#10;&#10;    model_config = ConfigDict(from_attributes=True)&#10;    customers: List[Customer] = []&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: Optional[str]&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []&#10;&#10;# Time Off schemas&#10;class TimeOffBase(BaseModel):&#10;    start_date: date&#10;    end_date: date&#10;    user_id: UUID4&#10;    reason: Optional[str] = None&#10;&#10;class TimeOffCreate(TimeOffBase):&#10;    pass&#10;&#10;class TimeOffUpdate(BaseModel):&#10;    start_date: Optional[date] = None&#10;    end_date: Optional[date] = None&#10;    reason: Optional[str] = None&#10;&#10;class TimeOff(TimeOffBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user_id: UUID4" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/user_time_off.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/user_time_off.py" />
              <option name="originalContent" value="from typing import List, Optional, Any&#10;from datetime import date&#10;import uuid&#10;&#10;from sqlalchemy.orm import Session&#10;from pydantic.v1 import UUID4&#10;&#10;from app.models import CompanyUsers&#10;from app.models.models import UserTimeOffs&#10;from app.schemas.schemas import TimeOffCreate, TimeOffUpdate&#10;&#10;&#10;def get_user_time_offs(&#10;    db: Session,&#10;    user_id: str,&#10;    start_date: date = None,&#10;    end_date: date = None&#10;) -&gt; List[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get all time-offs for a user with optional date filtering&#10;    &quot;&quot;&quot;&#10;    query = db.query(UserTimeOffs).filter(UserTimeOffs.user_id == user_id)&#10;    &#10;    if start_date and end_date:&#10;        # Get time offs that overlap with the given date range&#10;        query = query.filter(&#10;            UserTimeOffs.start_date &lt;= end_date,&#10;            UserTimeOffs.end_date &gt;= start_date&#10;        )&#10;    &#10;    return list(query.all())&#10;&#10;&#10;def get(db: Session, time_off_id: UUID4) -&gt; Optional[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get a specific time off by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(UserTimeOffs).filter(UserTimeOffs.id == time_off_id).first()&#10;&#10;&#10;def create(db: Session, *, obj_in: TimeOffCreate) -&gt; UserTimeOffs:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for a user&#10;    &#10;    If company_id is provided, validates that the user belongs to that company&#10;    &quot;&quot;&quot;&#10;    # Validate that end_date is not before start_date&#10;    if obj_in.end_date &lt; obj_in.start_date:&#10;        raise ValueError(&quot;End date cannot be before start date&quot;)&#10;    &#10;    # Check if company_id is provided, validate user belongs to this company&#10;    if obj_in.company_id:&#10;        company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == obj_in.user_id,&#10;            CompanyUsers.company_id == obj_in.company_id&#10;        ).first()&#10;        &#10;        if not company_user:&#10;            raise ValueError(f&quot;User {obj_in.user_id} does not belong to company {obj_in.company_id}&quot;)&#10;    &#10;    db_obj = UserTimeOffs(&#10;        # id=uuid.uuid4(),&#10;        user_id=obj_in.user_id,&#10;        start_date=obj_in.start_date,&#10;        end_date=obj_in.end_date,&#10;        reason=obj_in.reason&#10;    )&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: UserTimeOffs, obj_in: TimeOffUpdate) -&gt; UserTimeOffs:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period&#10;    &quot;&quot;&quot;&#10;    # Update fields if provided&#10;    if obj_in.start_date is not None:&#10;        db_obj.start_date = obj_in.start_date&#10;    &#10;    if obj_in.end_date is not None:&#10;        db_obj.end_date = obj_in.end_date&#10;    &#10;    if obj_in.reason is not None:&#10;        db_obj.reason = obj_in.reason&#10;    &#10;    # Validate that end_date is not before start_date after updates&#10;    if db_obj.end_date &lt; db_obj.start_date:&#10;        raise ValueError(&quot;End date cannot be before start date&quot;)&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def delete(db: Session, *, time_off_id: UUID4) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(UserTimeOffs).filter(UserTimeOffs.id == time_off_id).first()&#10;    if not db_obj:&#10;        return False&#10;    &#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def check_overlapping_time_offs(&#10;    db: Session, &#10;    user_id: UUID4, &#10;    start_date: date, &#10;    end_date: date,&#10;    exclude_id: UUID4 = None&#10;) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if a new time off period overlaps with existing ones&#10;    Returns True if there are overlaps, False otherwise&#10;    &quot;&quot;&quot;&#10;    query = db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    )&#10;&#10;    # Exclude the current time off if updating&#10;    if exclude_id:&#10;        query = query.filter(UserTimeOffs.id != exclude_id)&#10;&#10;    return query.count() &gt; 0&#10;&#10;&#10;# def get_company_user_time_offs(&#10;#         db: Session,&#10;#         company_id: str,&#10;#         start_date: date = None,&#10;#         end_date: date = None&#10;# ) -&gt; List[UserTimeOffs]:&#10;#     &quot;&quot;&quot;&#10;#     Get all time-offs for a user with optional date filtering&#10;#     &quot;&quot;&quot;&#10;    # query = (db.query(UserTimeOffs).join(CompanyUsers, CompanyUsers.user_id == UserTimeOffs.user_id)&#10;    #          .filter(UserTimeOffs.user_id == user_id,&#10;    #                  CompanyUsers.company_id == company_id))&#10;    #&#10;    # if start_date and end_date:&#10;    #     # Get time offs that overlap with the given date range&#10;    #     query = query.filter(&#10;    #         UserTimeOffs.start_date &lt;= end_date,&#10;    #         UserTimeOffs.end_date &gt;= start_date&#10;    #     )&#10;    #&#10;    # return list(query.all())&#10;" />
              <option name="updatedContent" value="from typing import List, Optional, Any&#10;from datetime import date&#10;import uuid&#10;&#10;from sqlalchemy.orm import Session&#10;from pydantic.v1 import UUID4&#10;&#10;from app.models import CompanyUsers&#10;from app.models.models import UserTimeOffs&#10;from app.schemas.schemas import TimeOffCreate, TimeOffUpdate&#10;&#10;&#10;def get_user_time_offs(&#10;    db: Session,&#10;    user_id: str,&#10;    start_date: date = None,&#10;    end_date: date = None&#10;) -&gt; List[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get all time-offs for a user with optional date filtering&#10;    &quot;&quot;&quot;&#10;    query = db.query(UserTimeOffs).filter(UserTimeOffs.user_id == user_id)&#10;    &#10;    if start_date and end_date:&#10;        # Get time offs that overlap with the given date range&#10;        query = query.filter(&#10;            UserTimeOffs.start_date &lt;= end_date,&#10;            UserTimeOffs.end_date &gt;= start_date&#10;        )&#10;    &#10;    return list(query.all())&#10;&#10;&#10;def get(db: Session, time_off_id: UUID4) -&gt; Optional[UserTimeOffs]:&#10;    &quot;&quot;&quot;&#10;    Get a specific time off by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(UserTimeOffs).filter(UserTimeOffs.id == time_off_id).first()&#10;&#10;&#10;def create(db: Session, *, obj_in: TimeOffCreate) -&gt; UserTimeOffs:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for a user&#10;    &#10;    If company_id is provided, validates that the user belongs to that company&#10;    &quot;&quot;&quot;&#10;    # Validate that end_date is not before start_date&#10;    if obj_in.end_date &lt; obj_in.start_date:&#10;        raise ValueError(&quot;End date cannot be before start date&quot;)&#10;    &#10;    # Check if company_id is provided, validate user belongs to this company&#10;    if obj_in.company_id:&#10;        company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == obj_in.user_id,&#10;            CompanyUsers.company_id == obj_in.company_id&#10;        ).first()&#10;        &#10;        if not company_user:&#10;            raise ValueError(f&quot;User {obj_in.user_id} does not belong to company {obj_in.company_id}&quot;)&#10;    &#10;    db_obj = UserTimeOffs(&#10;        # id=uuid.uuid4(),&#10;        user_id=obj_in.user_id,&#10;        start_date=obj_in.start_date,&#10;        end_date=obj_in.end_date,&#10;        reason=obj_in.reason&#10;    )&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: UserTimeOffs, obj_in: TimeOffUpdate) -&gt; UserTimeOffs:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period&#10;    &quot;&quot;&quot;&#10;    # Update fields if provided&#10;    if obj_in.start_date is not None:&#10;        db_obj.start_date = obj_in.start_date&#10;    &#10;    if obj_in.end_date is not None:&#10;        db_obj.end_date = obj_in.end_date&#10;    &#10;    if obj_in.reason is not None:&#10;        db_obj.reason = obj_in.reason&#10;    &#10;    # Validate that end_date is not before start_date after updates&#10;    if db_obj.end_date &lt; db_obj.start_date:&#10;        raise ValueError(&quot;End date cannot be before start date&quot;)&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def delete(db: Session, *, time_off_id: UUID4) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(UserTimeOffs).filter(UserTimeOffs.id == time_off_id).first()&#10;    if not db_obj:&#10;        return False&#10;    &#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def check_overlapping_time_offs(&#10;    db: Session, &#10;    user_id: UUID4, &#10;    start_date: date, &#10;    end_date: date,&#10;    exclude_id: UUID4 = None&#10;) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if a new time off period overlaps with existing ones&#10;    Returns True if there are overlaps, False otherwise&#10;    &quot;&quot;&quot;&#10;    query = db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    )&#10;&#10;    # Exclude the current time off if updating&#10;    if exclude_id:&#10;        query = query.filter(UserTimeOffs.id != exclude_id)&#10;&#10;    return query.count() &gt; 0&#10;&#10;&#10;# def get_company_user_time_offs(&#10;#         db: Session,&#10;#         company_id: str,&#10;#         start_date: date = None,&#10;#         end_date: date = None&#10;# ) -&gt; List[UserTimeOffs]:&#10;#     &quot;&quot;&quot;&#10;#     Get all time-offs for a user with optional date filtering&#10;#     &quot;&quot;&quot;&#10;    # query = (db.query(UserTimeOffs).join(CompanyUsers, CompanyUsers.user_id == UserTimeOffs.user_id)&#10;    #          .filter(UserTimeOffs.user_id == user_id,&#10;    #                  CompanyUsers.company_id == company_id))&#10;    #&#10;    # if start_date and end_date:&#10;    #     # Get time offs that overlap with the given date range&#10;    #     query = query.filter(&#10;    #         UserTimeOffs.start_date &lt;= end_date,&#10;    #         UserTimeOffs.end_date &gt;= start_date&#10;    #     )&#10;    #&#10;    # return list(query.all())" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>