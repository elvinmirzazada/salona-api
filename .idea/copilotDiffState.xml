<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/alembic/versions/add_membership_tables.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic/versions/add_membership_tables.py" />
              <option name="originalContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/api.py" />
              <option name="originalContent" value="from fastapi import APIRouter&#10;from app.api.api_v1.endpoints import customers, users, companies, services, bookings, notifications, memberships, integrations&#10;&#10;api_router = APIRouter()&#10;api_router.include_router(users.router, prefix=&quot;/users&quot;, tags=[&quot;users&quot;])&#10;api_router.include_router(companies.router, prefix=&quot;/companies&quot;, tags=[&quot;companies&quot;])&#10;api_router.include_router(services.router, prefix=&quot;/services&quot;, tags=[&quot;services&quot;])&#10;api_router.include_router(customers.router, prefix=&quot;/customers&quot;, tags=[&quot;customers&quot;])&#10;api_router.include_router(bookings.router, prefix=&quot;/bookings&quot;, tags=[&quot;bookings&quot;])&#10;api_router.include_router(notifications.router, prefix=&quot;/notifications&quot;, tags=[&quot;notifications&quot;])&#10;api_router.include_router(memberships.router, prefix=&quot;/memberships&quot;, tags=[&quot;memberships&quot;])&#10;api_router.include_router(integrations.router, prefix=&quot;/integrations&quot;, tags=[&quot;integrations&quot;])" />
              <option name="updatedContent" value="from fastapi import APIRouter&#10;from app.api.api_v1.endpoints import customers, users, companies, services, bookings, notifications, memberships, integrations&#10;&#10;api_router = APIRouter()&#10;api_router.include_router(users.router, prefix=&quot;/users&quot;, tags=[&quot;users&quot;])&#10;api_router.include_router(companies.router, prefix=&quot;/companies&quot;, tags=[&quot;companies&quot;])&#10;api_router.include_router(services.router, prefix=&quot;/services&quot;, tags=[&quot;services&quot;])&#10;api_router.include_router(customers.router, prefix=&quot;/customers&quot;, tags=[&quot;customers&quot;])&#10;api_router.include_router(bookings.router, prefix=&quot;/bookings&quot;, tags=[&quot;bookings&quot;])&#10;api_router.include_router(notifications.router, prefix=&quot;/notifications&quot;, tags=[&quot;notifications&quot;])&#10;api_router.include_router(memberships.router, prefix=&quot;/memberships&quot;, tags=[&quot;memberships&quot;])&#10;api_router.include_router(integrations.router, prefix=&quot;/integrations&quot;, tags=[&quot;integrations&quot;])" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/companies.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/companies.py" />
              <option name="originalContent" value="from typing import List&#10;from datetime import date, timedelta&#10;from fastapi import APIRouter, Depends, HTTPException, status, Query, Response&#10;from sqlalchemy.orm import Session&#10;from app.api.dependencies import (&#10;    get_current_active_user,&#10;    get_current_active_customer,&#10;    get_current_company_id,&#10;    require_admin_or_owner,&#10;    require_owner,&#10;    require_staff_or_higher,&#10;    get_current_user_role&#10;)&#10;from app.db.session import get_db&#10;from app.models.models import Users&#10;from app.models.enums import CompanyRoleType&#10;from app.schemas import CompanyCreate, User, Company, AvailabilityResponse, AvailabilityType, CompanyUser, \&#10;    CategoryServiceResponse, CompanyCategoryWithServicesResponse, Customer, TimeOff, CompanyUpdate, \&#10;    CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, CompanyPhone, UserCreate, \&#10;    Invitation, InvitationCreate, InvitationAccept&#10;from app.schemas.responses import DataResponse&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import customer as crud_customer&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import user_availability as crud_user_availability&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_user_time_off&#10;from app.services.crud import invitation as crud_invitation&#10;from app.services.email_service import email_service&#10;from app.services.auth import hash_password&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Company], status_code=status.HTTP_201_CREATED)&#10;async def create_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_in: CompanyCreate,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new company.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.create(db=db, obj_in=company_in, current_user=current_user)&#10;    return DataResponse.success_response(&#10;        data=company,&#10;        message=&quot;Company created successfully&quot;,&#10;        status_code=status.HTTP_201_CREATED&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}/users/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get user's regular availability&#10;        availabilities = crud_company.get_company_user_availabilities(db, user_id=user_id, company_id=company_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = crud_company.get_company_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, and existing bookings&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/{company_id}/availabilities&quot;, response_model=DataResponse[list[AvailabilityResponse]])&#10;async def get_company_all_users_availabilities(&#10;        *,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[list[AvailabilityResponse]]:&#10;    &quot;&quot;&quot;&#10;    Get availabilities for all users for a specific time range. Optimized to fetch all data in bulk and group bookings by user via BookingServices.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_users = crud_company.get_company_users(db, company_id)&#10;        if not company_users:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No users found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        # Bulk fetch all related data&#10;        availabilities = crud_company.get_company_all_users_availabilities(db, company_id)&#10;        time_offs = crud_company.get_company_all_users_time_offs(&#10;            db,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        booking_tuples = crud_booking.get_all_bookings_in_range(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        # Group data by user&#10;        avail_map = {}&#10;        for a in availabilities:&#10;            avail_map.setdefault(str(a.user_id), []).append(a)&#10;        timeoff_map = {}&#10;        for t in time_offs:&#10;            timeoff_map.setdefault(str(t.user_id), []).append(t)&#10;        booking_map = {}&#10;        for booking, user_id in booking_tuples:&#10;            booking_map.setdefault(str(user_id), []).append(booking)&#10;        results = []&#10;        for user in company_users:&#10;            user_id = str(user.user_id)&#10;            user_avails = avail_map.get(user_id, [])&#10;            if not user_avails:&#10;                continue&#10;            user_timeoffs = timeoff_map.get(user_id, [])&#10;            user_bookings = booking_map.get(user_id, [])&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=user_avails,&#10;                time_offs=user_timeoffs,&#10;                bookings=user_bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;            results.append(availability)&#10;        if not results:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availabilities found for any user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        return DataResponse.success_response(&#10;            data=results,&#10;            message=&quot;Availabilities retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availabilities: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/users&quot;, response_model=DataResponse[List[CompanyUser]])&#10;async def get_company_users(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can list staff&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all staff/users in the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        return DataResponse.error_response(&#10;            message=&quot;No company associated with the current user&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;    users = crud_company.get_company_users(&#10;        db=db, company_id=company_id&#10;    )&#10;    return DataResponse.success_response(&#10;        data=users,&#10;        message=&quot;Company users retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;/services&quot;, response_model=DataResponse[List[CompanyCategoryWithServicesResponse]])&#10;async def get_company_services(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all businesses owned by the authenticated professional.&#10;    &quot;&quot;&quot;&#10;    services = crud_service.get_company_services(&#10;        db=db, company_id=company_id&#10;    )&#10;    from app.core.redis_client import publish_event&#10;    await publish_event('booking_created',&#10;                        str({'info': f&quot;A new booking has been created&quot;}))&#10;&#10;    return DataResponse.success_response(&#10;        data=services,&#10;        message=&quot;Company services retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/customers', response_model=DataResponse[List[Customer]])&#10;async def get_company_customers(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)  # Staff and above can view customers&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all customers who have bookings with the company.&#10;    Requires staff, admin, or owner role.&#10;    &quot;&quot;&quot;&#10;    customers = crud_customer.get_company_customers(&#10;        db=db, company_id=company_id&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=customers,&#10;        message=&quot;Company customers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/user-time-offs', response_model=DataResponse[List[TimeOff]])&#10;async def get_company_user_time_offs(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all user time offs for the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    start_date = date_from&#10;    end_date = date_from + timedelta(&#10;        days=1 if availability_type == AvailabilityType.DAILY else&#10;        7 if availability_type == AvailabilityType.WEEKLY else 31&#10;    )&#10;    time_offs = crud_user_time_off.get_company_user_time_offs(&#10;        db=db, company_id=company_id, start_date=start_date, end_date=end_date&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=time_offs,&#10;        message=&quot;Company user time offs retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[Company])&#10;async def get_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}&quot;, response_model=DataResponse[Company])&#10;async def get_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;@router.put(&quot;&quot;, response_model=DataResponse[Company])&#10;async def update_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_in: CompanyUpdate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can update company&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update company information.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;&#10;    try:&#10;        updated_company = crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=company_in.model_dump(exclude_unset=True)&#10;        )&#10;        return DataResponse.success_response(&#10;            data=updated_company,&#10;            message=&quot;Company information updated successfully&quot;&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company information: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/emails&quot;, response_model=DataResponse, status_code=status.HTTP_201_CREATED)&#10;async def add_company_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    email_in: CompanyEmailCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add a new email address to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        email_in.company_id = company_id&#10;        crud_company.create_company_email(db=db, obj_in=email_in)&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Emails added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add emails: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/emails&quot;, response_model=DataResponse[List[CompanyEmail]])&#10;async def get_company_emails(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all email addresses associated with the company.&#10;    &quot;&quot;&quot;&#10;    emails = crud_company.get_company_emails(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=emails,&#10;        message=&quot;Company emails retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/emails/{email_id}&quot;, response_model=DataResponse)&#10;async def delete_company_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    email_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete an email address from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = crud_company.delete_company_email(db=db, email_id=email_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Email not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Email deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/phones&quot;, response_model=DataResponse[List[CompanyPhone]], status_code=status.HTTP_201_CREATED)&#10;async def add_company_phone(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    phone_in: CompanyPhoneCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add new phone numbers to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Set the company ID from the authenticated user's context&#10;        phone_in.company_id = company_id&#10;        phones = crud_company.create_company_phone(db=db, obj_in=phone_in)&#10;&#10;        return DataResponse.success_response(&#10;            data=phones,&#10;            message=&quot;Phone numbers added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add phone numbers: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/phones&quot;, response_model=DataResponse[List[CompanyPhone]])&#10;async def get_company_phones(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers associated with the company.&#10;    &quot;&quot;&quot;&#10;    phones = crud_company.get_company_phones(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=phones,&#10;        message=&quot;Company phone numbers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/phones/{phone_id}&quot;, response_model=DataResponse)&#10;async def delete_company_phone(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    phone_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a phone number from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = crud_company.delete_company_phone(db=db, phone_id=phone_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Phone number not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Phone number deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;@router.post(&quot;/members&quot;, response_model=DataResponse[CompanyUser], status_code=status.HTTP_201_CREATED)&#10;async def add_company_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_in: UserCreate,&#10;    role: CompanyRoleType = Query(..., description=&quot;Role to assign to the user in the company&quot;),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can add members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to the company with a specified role.&#10;    If a user with the email already exists, they will be added to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_user = crud_company.create_company_member(&#10;            db=db,&#10;            user_in=user_in,&#10;            company_id=company_id,&#10;            role=role&#10;        )&#10;        return DataResponse.success_response(&#10;            data=company_user,&#10;            message=&quot;Member added to company successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add member to company: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;# ============== STAFF INVITATION ENDPOINTS ==============&#10;&#10;@router.post(&quot;/{company_id}/invitations&quot;, response_model=DataResponse[Invitation], status_code=status.HTTP_201_CREATED)&#10;async def invite_staff_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str,&#10;    invitation_in: InvitationCreate,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Invite a staff member to the company.&#10;    &#10;    If the invited email is not registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with sign-up link&#10;    &#10;    If the invited email is already registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with acceptance link&#10;    &#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if email is already registered&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation_in.email.lower())&#10;        is_existing_user = existing_user is not None&#10;        &#10;        # Set default role to staff if not provided&#10;        role = invitation_in.role or CompanyRoleType.staff&#10;        &#10;        # Create invitation&#10;        invitation = crud_invitation.create_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation_in.email.lower(),&#10;            role=role&#10;        )&#10;        &#10;        # Get company details for email&#10;        company = crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                detail=&quot;Company not found&quot;&#10;            )&#10;        &#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=invitation.email,&#10;            invitation_token=invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;        &#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation created but failed to send email. Please try again.&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;        &#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(invitation),&#10;            message=&quot;Staff member invited successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    &#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to invite staff member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/accept&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def accept_invitation(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    invitation_in: InvitationAccept,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Accept a staff invitation.&#10;    &#10;    If the user doesn't exist (new user):&#10;    - Create user account with provided details&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role&#10;    - Activate company_users record&#10;    &#10;    If the user already exists (existing user):&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role (or update if already exists)&#10;    - Activate company_users record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation&#10;        invitation = crud_invitation.get_invitation_by_token(db=db, token=invitation_in.token)&#10;        &#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        &#10;        # Check if user exists&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation.email)&#10;        &#10;        if not existing_user:&#10;            # Create new user&#10;            if not invitation_in.password:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;Password is required for new user registration&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST&#10;                )&#10;            &#10;            # Hash password&#10;            hashed_password = hash_password(invitation_in.password)&#10;            &#10;            # Create user&#10;            user_create_data = {&#10;                &quot;first_name&quot;: invitation_in.first_name,&#10;                &quot;last_name&quot;: invitation_in.last_name,&#10;                &quot;email&quot;: invitation.email,&#10;                &quot;password&quot;: hashed_password,&#10;                &quot;phone&quot;: invitation_in.phone&#10;            }&#10;            &#10;            from app.schemas.schemas import UserCreate as UserCreateSchema&#10;            user_in = UserCreateSchema(**user_create_data)&#10;            new_user = crud_user.create(db=db, obj_in=user_in)&#10;            user_id = new_user.id&#10;        else:&#10;            # Use existing user&#10;            user_id = existing_user.id&#10;        &#10;        # Accept invitation (mark as USED and add to company)&#10;        crud_invitation.accept_invitation(&#10;            db=db,&#10;            invitation=invitation,&#10;            user_id=user_id&#10;        )&#10;        &#10;        return DataResponse.success_response(&#10;            message=&quot;Invitation accepted successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    &#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to accept invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/{company_id}/invitations/{token}/resend&quot;, response_model=DataResponse[Invitation])&#10;async def resend_invitation(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str,&#10;    token: str,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation to a staff member.&#10;    &#10;    This generates a new token and resets the invitation to PENDING status.&#10;    Only works for expired or pending invitations.&#10;    &#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.models import Invitations&#10;        &#10;        # Get the invitation by current token&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.company_id == company_id&#10;        ).first()&#10;        &#10;        if not invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        &#10;        # Resend invitation&#10;        resent_invitation = crud_invitation.resend_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation.email&#10;        )&#10;        &#10;        if not resent_invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or cannot be resent&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        &#10;        # Get company details for email&#10;        company = crud_company.get(db=db, id=company_id)&#10;        &#10;        # Check if user exists for email&#10;        existing_user = crud_user.get_by_email(db=db, email=resent_invitation.email)&#10;        is_existing_user = existing_user is not None&#10;        &#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=resent_invitation.email,&#10;            invitation_token=resent_invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;        &#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation updated but failed to send email&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;        &#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(resent_invitation),&#10;            message=&quot;Invitation resent successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    &#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to resend invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/{company_id}/invitations&quot;, response_model=DataResponse[List[Invitation]])&#10;async def get_company_invitations(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str,&#10;    status_filter: str = Query(None, description=&quot;Filter by status: pending, used, expired, declined&quot;),&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company.&#10;    &#10;    Optional status filter: pending, used, expired, declined&#10;    &#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.enums import InvitationStatus&#10;        &#10;        # Parse status filter&#10;        status_enum = None&#10;        if status_filter:&#10;            status_enum = InvitationStatus(status_filter.upper())&#10;        &#10;        invitations = crud_invitation.get_company_invitations(&#10;            db=db,&#10;            company_id=company_id,&#10;            status=status_enum&#10;        )&#10;        &#10;        return DataResponse.success_response(&#10;            data=[Invitation.model_validate(inv) for inv in invitations],&#10;            message=&quot;Company invitations retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    &#10;    except ValueError:&#10;        return DataResponse.error_response(&#10;            message=&quot;Invalid status filter&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve invitations: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;" />
              <option name="updatedContent" value="from typing import List&#10;from datetime import date, timedelta&#10;from fastapi import APIRouter, Depends, HTTPException, status, Query, Response&#10;from sqlalchemy.orm import Session&#10;from app.api.dependencies import (&#10;    get_current_active_user,&#10;    get_current_active_customer,&#10;    get_current_company_id,&#10;    require_admin_or_owner,&#10;    require_owner,&#10;    require_staff_or_higher,&#10;    get_current_user_role&#10;)&#10;from app.db.session import get_db&#10;from app.models.models import Users&#10;from app.models.enums import CompanyRoleType&#10;from app.schemas import CompanyCreate, User, Company, AvailabilityResponse, AvailabilityType, CompanyUser, \&#10;    CategoryServiceResponse, CompanyCategoryWithServicesResponse, Customer, TimeOff, CompanyUpdate, \&#10;    CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, CompanyPhone, UserCreate, \&#10;    Invitation, InvitationCreate, InvitationAccept&#10;from app.schemas.responses import DataResponse&#10;from app.services.crud import company as crud_company&#10;from app.services.crud import customer as crud_customer&#10;from app.services.crud import service as crud_service&#10;from app.services.crud import user_availability as crud_user_availability&#10;from app.services.crud import booking as crud_booking&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_user_time_off&#10;from app.services.crud import invitation as crud_invitation&#10;from app.services.email_service import email_service&#10;from app.services.auth import hash_password&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;&quot;, response_model=DataResponse[Company], status_code=status.HTTP_201_CREATED)&#10;async def create_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_in: CompanyCreate,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new company.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.create(db=db, obj_in=company_in, current_user=current_user)&#10;    return DataResponse.success_response(&#10;        data=company,&#10;        message=&quot;Company created successfully&quot;,&#10;        status_code=status.HTTP_201_CREATED&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}/users/{user_id}/availability&quot;, response_model=DataResponse[AvailabilityResponse])&#10;async def get_user_availability(&#10;        *,&#10;        user_id: str,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[AvailabilityResponse]:&#10;    &quot;&quot;&quot;&#10;    Get user availability for a specific time range.&#10;    - daily: Shows available time slots for a specific date&#10;    - weekly: Shows available time slots for a week starting from date_from&#10;    - monthly: Shows available time slots for the month containing date_from&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get user's regular availability&#10;        availabilities = crud_company.get_company_user_availabilities(db, user_id=user_id, company_id=company_id)&#10;        if not availabilities:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Get user's time-offs&#10;        time_offs = crud_company.get_company_user_time_offs(&#10;            db,&#10;            user_id=user_id,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        # Get existing bookings&#10;        bookings = crud_booking.get_user_bookings_in_range(&#10;            db,&#10;            user_id=user_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;&#10;        if availabilities:&#10;            # Calculate availability based on working hours, time-offs, and existing bookings&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=availabilities,&#10;                time_offs=time_offs,&#10;                bookings=bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;&#10;            return DataResponse.success_response(&#10;                data=availability,&#10;                message=&quot;Availability retrieved successfully&quot;,&#10;                status_code=status.HTTP_200_OK&#10;            )&#10;        else:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availability schedule found for this user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availability: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/{company_id}/availabilities&quot;, response_model=DataResponse[list[AvailabilityResponse]])&#10;async def get_company_all_users_availabilities(&#10;        *,&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        response: Response,&#10;        db: Session = Depends(get_db),&#10;        company_id: str&#10;) -&gt; DataResponse[list[AvailabilityResponse]]:&#10;    &quot;&quot;&quot;&#10;    Get availabilities for all users for a specific time range. Optimized to fetch all data in bulk and group bookings by user via BookingServices.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_users = crud_company.get_company_users(db, company_id)&#10;        if not company_users:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No users found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        # Bulk fetch all related data&#10;        availabilities = crud_company.get_company_all_users_availabilities(db, company_id)&#10;        time_offs = crud_company.get_company_all_users_time_offs(&#10;            db,&#10;            company_id=company_id,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        booking_tuples = crud_booking.get_all_bookings_in_range(&#10;            db,&#10;            start_date=date_from,&#10;            end_date=date_from + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        )&#10;        # Group data by user&#10;        avail_map = {}&#10;        for a in availabilities:&#10;            avail_map.setdefault(str(a.user_id), []).append(a)&#10;        timeoff_map = {}&#10;        for t in time_offs:&#10;            timeoff_map.setdefault(str(t.user_id), []).append(t)&#10;        booking_map = {}&#10;        for booking, user_id in booking_tuples:&#10;            booking_map.setdefault(str(user_id), []).append(booking)&#10;        results = []&#10;        for user in company_users:&#10;            user_id = str(user.user_id)&#10;            user_avails = avail_map.get(user_id, [])&#10;            if not user_avails:&#10;                continue&#10;            user_timeoffs = timeoff_map.get(user_id, [])&#10;            user_bookings = booking_map.get(user_id, [])&#10;            availability = crud_user_availability.calculate_availability(&#10;                availabilities=user_avails,&#10;                time_offs=user_timeoffs,&#10;                bookings=user_bookings,&#10;                availability_type=availability_type,&#10;                date_from=date_from&#10;            )&#10;            results.append(availability)&#10;        if not results:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;No availabilities found for any user&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        return DataResponse.success_response(&#10;            data=results,&#10;            message=&quot;Availabilities retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve availabilities: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/users&quot;, response_model=DataResponse[List[CompanyUser]])&#10;async def get_company_users(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can list staff&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all staff/users in the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    if not company_id:&#10;        return DataResponse.error_response(&#10;            message=&quot;No company associated with the current user&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;    users = crud_company.get_company_users(&#10;        db=db, company_id=company_id&#10;    )&#10;    return DataResponse.success_response(&#10;        data=users,&#10;        message=&quot;Company users retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;/services&quot;, response_model=DataResponse[List[CompanyCategoryWithServicesResponse]])&#10;async def get_company_services(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all businesses owned by the authenticated professional.&#10;    &quot;&quot;&quot;&#10;    services = crud_service.get_company_services(&#10;        db=db, company_id=company_id&#10;    )&#10;    from app.core.redis_client import publish_event&#10;    await publish_event('booking_created',&#10;                        str({'info': f&quot;A new booking has been created&quot;}))&#10;&#10;    return DataResponse.success_response(&#10;        data=services,&#10;        message=&quot;Company services retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/customers', response_model=DataResponse[List[Customer]])&#10;async def get_company_customers(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)  # Staff and above can view customers&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all customers who have bookings with the company.&#10;    Requires staff, admin, or owner role.&#10;    &quot;&quot;&quot;&#10;    customers = crud_customer.get_company_customers(&#10;        db=db, company_id=company_id&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=customers,&#10;        message=&quot;Company customers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get('/user-time-offs', response_model=DataResponse[List[TimeOff]])&#10;async def get_company_user_time_offs(&#10;        db: Session = Depends(get_db),&#10;        company_id: str = Depends(get_current_company_id),&#10;        availability_type: AvailabilityType = Query(..., description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;        date_from: date = Query(..., description=&quot;Start date for availability check&quot;),&#10;        user_role: CompanyRoleType = Depends(require_staff_or_higher)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all user time offs for the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    start_date = date_from&#10;    end_date = date_from + timedelta(&#10;        days=1 if availability_type == AvailabilityType.DAILY else&#10;        7 if availability_type == AvailabilityType.WEEKLY else 31&#10;    )&#10;    time_offs = crud_user_time_off.get_company_user_time_offs(&#10;        db=db, company_id=company_id, start_date=start_date, end_date=end_date&#10;    )&#10;&#10;    return DataResponse.success_response(&#10;        data=time_offs,&#10;        message=&quot;Company user time offs retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.get(&quot;&quot;, response_model=DataResponse[Company])&#10;async def get_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;&#10;@router.get(&quot;/{company_id}&quot;, response_model=DataResponse[Company])&#10;async def get_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get a specific business by ID.&#10;    Only the owner can access their business details.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;    return DataResponse.success_response(&#10;        data=company&#10;    )&#10;&#10;@router.put(&quot;&quot;, response_model=DataResponse[Company])&#10;async def update_company(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_in: CompanyUpdate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can update company&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update company information.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    company = crud_company.get(db=db, id=company_id)&#10;    if not company:&#10;        return DataResponse.error_response(&#10;            status_code=status.HTTP_404_NOT_FOUND,&#10;            message=&quot;Company not found&quot;&#10;        )&#10;&#10;    try:&#10;        updated_company = crud_company.update(&#10;            db=db,&#10;            db_obj=company,&#10;            obj_in=company_in.model_dump(exclude_unset=True)&#10;        )&#10;        return DataResponse.success_response(&#10;            data=updated_company,&#10;            message=&quot;Company information updated successfully&quot;&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update company information: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/emails&quot;, response_model=DataResponse, status_code=status.HTTP_201_CREATED)&#10;async def add_company_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    email_in: CompanyEmailCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add a new email address to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        email_in.company_id = company_id&#10;        crud_company.create_company_email(db=db, obj_in=email_in)&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Emails added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add emails: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/emails&quot;, response_model=DataResponse[List[CompanyEmail]])&#10;async def get_company_emails(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all email addresses associated with the company.&#10;    &quot;&quot;&quot;&#10;    emails = crud_company.get_company_emails(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=emails,&#10;        message=&quot;Company emails retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/emails/{email_id}&quot;, response_model=DataResponse)&#10;async def delete_company_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    email_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete an email address from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = crud_company.delete_company_email(db=db, email_id=email_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Email not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Email deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/phones&quot;, response_model=DataResponse[List[CompanyPhone]], status_code=status.HTTP_201_CREATED)&#10;async def add_company_phone(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    phone_in: CompanyPhoneCreate,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Add new phone numbers to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Set the company ID from the authenticated user's context&#10;        phone_in.company_id = company_id&#10;        phones = crud_company.create_company_phone(db=db, obj_in=phone_in)&#10;&#10;        return DataResponse.success_response(&#10;            data=phones,&#10;            message=&quot;Phone numbers added successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add phone numbers: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/phones&quot;, response_model=DataResponse[List[CompanyPhone]])&#10;async def get_company_phones(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers associated with the company.&#10;    &quot;&quot;&quot;&#10;    phones = crud_company.get_company_phones(db=db, company_id=company_id)&#10;&#10;    return DataResponse.success_response(&#10;        data=phones,&#10;        message=&quot;Company phone numbers retrieved successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.delete(&quot;/phones/{phone_id}&quot;, response_model=DataResponse)&#10;async def delete_company_phone(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    phone_id: str,&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a phone number from the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    success = crud_company.delete_company_phone(db=db, phone_id=phone_id, company_id=company_id)&#10;&#10;    if not success:&#10;        return DataResponse.error_response(&#10;            message=&quot;Phone number not found or does not belong to this company&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Phone number deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;@router.post(&quot;/members&quot;, response_model=DataResponse[CompanyUser], status_code=status.HTTP_201_CREATED)&#10;async def add_company_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    user_in: UserCreate,&#10;    role: CompanyRoleType = Query(..., description=&quot;Role to assign to the user in the company&quot;),&#10;    company_id: str = Depends(get_current_company_id),&#10;    user_role: CompanyRoleType = Depends(require_admin_or_owner)  # Only admin or owner can add members&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to the company with a specified role.&#10;    If a user with the email already exists, they will be added to the company.&#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        company_user = crud_company.create_company_member(&#10;            db=db,&#10;            user_in=user_in,&#10;            company_id=company_id,&#10;            role=role&#10;        )&#10;        return DataResponse.success_response(&#10;            data=company_user,&#10;            message=&quot;Member added to company successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to add member to company: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;# ============== STAFF INVITATION ENDPOINTS ==============&#10;&#10;@router.post(&quot;/{company_id}/invitations&quot;, response_model=DataResponse[Invitation], status_code=status.HTTP_201_CREATED)&#10;async def invite_staff_member(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str,&#10;    invitation_in: InvitationCreate,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Invite a staff member to the company.&#10;    &#10;    If the invited email is not registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with sign-up link&#10;    &#10;    If the invited email is already registered:&#10;    - Create invitation with PENDING status&#10;    - Send invitation email with acceptance link&#10;    &#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check if email is already registered&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation_in.email.lower())&#10;        is_existing_user = existing_user is not None&#10;        &#10;        # Set default role to staff if not provided&#10;        role = invitation_in.role or CompanyRoleType.staff&#10;        &#10;        # Create invitation&#10;        invitation = crud_invitation.create_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation_in.email.lower(),&#10;            role=role&#10;        )&#10;        &#10;        # Get company details for email&#10;        company = crud_company.get(db=db, id=company_id)&#10;        if not company:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                detail=&quot;Company not found&quot;&#10;            )&#10;        &#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=invitation.email,&#10;            invitation_token=invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;        &#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation created but failed to send email. Please try again.&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;        &#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(invitation),&#10;            message=&quot;Staff member invited successfully&quot;,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    &#10;    except HTTPException:&#10;        raise&#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to invite staff member: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/invitations/accept&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def accept_invitation(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    invitation_in: InvitationAccept,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Accept a staff invitation.&#10;    &#10;    If the user doesn't exist (new user):&#10;    - Create user account with provided details&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role&#10;    - Activate company_users record&#10;    &#10;    If the user already exists (existing user):&#10;    - Mark invitation as USED&#10;    - Add user to company with invited role (or update if already exists)&#10;    - Activate company_users record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get invitation&#10;        invitation = crud_invitation.get_invitation_by_token(db=db, token=invitation_in.token)&#10;        &#10;        if not invitation:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or has expired&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        &#10;        # Check if user exists&#10;        existing_user = crud_user.get_by_email(db=db, email=invitation.email)&#10;        &#10;        if not existing_user:&#10;            # Create new user&#10;            if not invitation_in.password:&#10;                response.status_code = status.HTTP_400_BAD_REQUEST&#10;                return DataResponse.error_response(&#10;                    message=&quot;Password is required for new user registration&quot;,&#10;                    status_code=status.HTTP_400_BAD_REQUEST&#10;                )&#10;            &#10;            # Hash password&#10;            hashed_password = hash_password(invitation_in.password)&#10;            &#10;            # Create user&#10;            user_create_data = {&#10;                &quot;first_name&quot;: invitation_in.first_name,&#10;                &quot;last_name&quot;: invitation_in.last_name,&#10;                &quot;email&quot;: invitation.email,&#10;                &quot;password&quot;: hashed_password,&#10;                &quot;phone&quot;: invitation_in.phone&#10;            }&#10;            &#10;            from app.schemas.schemas import UserCreate as UserCreateSchema&#10;            user_in = UserCreateSchema(**user_create_data)&#10;            new_user = crud_user.create(db=db, obj_in=user_in)&#10;            user_id = new_user.id&#10;        else:&#10;            # Use existing user&#10;            user_id = existing_user.id&#10;        &#10;        # Accept invitation (mark as USED and add to company)&#10;        crud_invitation.accept_invitation(&#10;            db=db,&#10;            invitation=invitation,&#10;            user_id=user_id&#10;        )&#10;        &#10;        return DataResponse.success_response(&#10;            message=&quot;Invitation accepted successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    &#10;    except Exception as e:&#10;        db.rollback()&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to accept invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/{company_id}/invitations/{token}/resend&quot;, response_model=DataResponse[Invitation])&#10;async def resend_invitation(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str,&#10;    token: str,&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation to a staff member.&#10;    &#10;    This generates a new token and resets the invitation to PENDING status.&#10;    Only works for expired or pending invitations.&#10;    &#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.models import Invitations&#10;        &#10;        # Get the invitation by current token&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.company_id == company_id&#10;        ).first()&#10;        &#10;        if not invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        &#10;        # Resend invitation&#10;        resent_invitation = crud_invitation.resend_invitation(&#10;            db=db,&#10;            company_id=company_id,&#10;            email=invitation.email&#10;        )&#10;        &#10;        if not resent_invitation:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation not found or cannot be resent&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;        &#10;        # Get company details for email&#10;        company = crud_company.get(db=db, id=company_id)&#10;        &#10;        # Check if user exists for email&#10;        existing_user = crud_user.get_by_email(db=db, email=resent_invitation.email)&#10;        is_existing_user = existing_user is not None&#10;        &#10;        # Send invitation email&#10;        invited_by = f&quot;{current_user.first_name} {current_user.last_name}&quot;&#10;        email_sent = email_service.send_staff_invitation_email(&#10;            to_email=resent_invitation.email,&#10;            invitation_token=resent_invitation.token,&#10;            invited_by=invited_by,&#10;            company_name=company.name,&#10;            is_existing_user=is_existing_user&#10;        )&#10;        &#10;        if not email_sent:&#10;            return DataResponse.error_response(&#10;                message=&quot;Invitation updated but failed to send email&quot;,&#10;                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;            )&#10;        &#10;        return DataResponse.success_response(&#10;            data=Invitation.model_validate(resent_invitation),&#10;            message=&quot;Invitation resent successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    &#10;    except Exception as e:&#10;        db.rollback()&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to resend invitation: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/{company_id}/invitations&quot;, response_model=DataResponse[List[Invitation]])&#10;async def get_company_invitations(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    company_id: str,&#10;    status_filter: str = Query(None, description=&quot;Filter by status: pending, used, expired, declined&quot;),&#10;    current_user: User = Depends(get_current_active_user),&#10;    _: None = Depends(require_admin_or_owner)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company.&#10;    &#10;    Optional status filter: pending, used, expired, declined&#10;    &#10;    Requires admin or owner role.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        from app.models.enums import InvitationStatus&#10;        &#10;        # Parse status filter&#10;        status_enum = None&#10;        if status_filter:&#10;            status_enum = InvitationStatus(status_filter.upper())&#10;        &#10;        invitations = crud_invitation.get_company_invitations(&#10;            db=db,&#10;            company_id=company_id,&#10;            status=status_enum&#10;        )&#10;        &#10;        return DataResponse.success_response(&#10;            data=[Invitation.model_validate(inv) for inv in invitations],&#10;            message=&quot;Company invitations retrieved successfully&quot;,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    &#10;    except ValueError:&#10;        return DataResponse.error_response(&#10;            message=&quot;Invalid status filter&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve invitations: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/models/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/models/models.py" />
              <option name="originalContent" value="import uuid&#10;&#10;from pydantic.v1 import create_model_from_typeddict&#10;from sqlalchemy import (Column, Integer, String, Boolean, DateTime, Text, Date, ForeignKey, UniqueConstraint, UUID,&#10;                        Time,&#10;                        CheckConstraint, false, BLOB, LargeBinary, Index)&#10;from sqlalchemy.dialects.postgresql import ENUM as SQLAlchemyEnum&#10;from sqlalchemy.orm import relationship&#10;from sqlalchemy.sql import func&#10;from sqlalchemy.sql import expression&#10;&#10;from app.db.base_class import BaseModel&#10;from app.models.enums import (StatusType, BookingStatus, CustomerStatusType, EmailStatusType,&#10;                              PhoneStatusType, VerificationType, VerificationStatus,&#10;                              CompanyRoleType, NotificationType, NotificationStatus, MembershipPlanType, InvitationStatus)&#10;&#10;&#10;#&#10;class Users(BaseModel):&#10;    __tablename__ = &quot;users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company_user = relationship(&quot;CompanyUsers&quot;, back_populates=&quot;user&quot;)&#10;    user_time_offs = relationship(&quot;UserTimeOffs&quot;, back_populates=&quot;user&quot;)&#10;&#10;&#10;class UserVerifications(BaseModel):&#10;    __tablename__ = &quot;user_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;&#10;class UserAvailabilities(BaseModel):&#10;    __tablename__ = &quot;user_availabilities&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    day_of_week = Column(Integer, nullable=False)  # 0=Monday, 6=Sunday&#10;    start_time = Column(Time, nullable=False)  # Store only time (HH:MM)&#10;    end_time = Column(Time, nullable=False)    # Store only time (HH:MM)&#10;    is_available = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    __table_args__ = (&#10;        # Add constraint to ensure start_time is before end_time&#10;        CheckConstraint('start_time &lt; end_time', name='check_time_order'),&#10;        # Add unique constraint to prevent overlapping time slots for the same user and day&#10;        UniqueConstraint('user_id', 'day_of_week', 'start_time', 'end_time', name='unique_user_availability')&#10;    )&#10;&#10;&#10;class UserTimeOffs(BaseModel):&#10;    __tablename__ = &quot;user_time_offs&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    start_date = Column(DateTime, nullable=False)&#10;    end_date = Column(DateTime, nullable=False)&#10;    reason = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;user_time_offs&quot;)&#10;&#10;&#10;class Companies(BaseModel):&#10;    __tablename__ = &quot;companies&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(255), nullable=False)&#10;    type = Column(String(255), nullable=False)&#10;    logo_url = Column(String(255))&#10;    website = Column(String(255))&#10;    description = Column(Text)&#10;    team_size = Column(Integer, default=1)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    invitations = relationship(&quot;Invitations&quot;, back_populates=&quot;company&quot;)&#10;&#10;&#10;class CompanyEmails(BaseModel):&#10;    __tablename__ = &quot;company_emails&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CompanyPhones(BaseModel):&#10;    __tablename__ = &quot;company_phones&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CompanyAddresses(BaseModel):&#10;    __tablename__ = &quot;company_addresses&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address = Column(String(255), nullable=False)&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;&#10;class CompanyUsers(BaseModel):&#10;    __tablename__ = &quot;company_users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)  # e.g., admin, member&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.inactive)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;company_user&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('user_id', 'company_id', name='_user_company_uc'),)&#10;&#10;&#10;class Customers(BaseModel):&#10;    __tablename__ = &quot;customers&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;customer&quot;)&#10;&#10;class CustomerEmails(BaseModel):&#10;    __tablename__ = &quot;customer_emails&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerPhones(BaseModel):&#10;    __tablename__ = &quot;customer_phones&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerAddresses(BaseModel):&#10;    __tablename__ = &quot;customer_addresses&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address_line1 = Column(String(255), nullable=False)&#10;    address_line2 = Column(String(255))&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerVerifications(BaseModel):&#10;    __tablename__ = &quot;customer_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;class Bookings(BaseModel):&#10;    __tablename__ = &quot;bookings&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    status = Column(SQLAlchemyEnum(BookingStatus), default=BookingStatus.SCHEDULED)&#10;    start_at = Column(DateTime, nullable=False)&#10;    end_at = Column(DateTime, nullable=False)&#10;    total_price = Column(Integer, nullable=False)&#10;    notes = Column(Text)&#10;&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    customer = relationship(&quot;Customers&quot;, back_populates=&quot;booking&quot;)&#10;    booking_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;booking&quot;)&#10;&#10;&#10;class CompanyCategories(BaseModel):&#10;    __tablename__ = &quot;company_categories&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(100), nullable=False)&#10;    description = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;company_category&quot;)&#10;&#10;&#10;class CategoryServices(BaseModel):&#10;    __tablename__ = &quot;category_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    category_id = Column(UUID, ForeignKey(&quot;company_categories.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(255))&#10;    duration = Column(Integer)&#10;    price = Column(Integer)&#10;    discount_price = Column(Integer)&#10;    additional_info = Column(Text)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    buffer_before = Column(Integer, default=0)  # in minutes&#10;    buffer_after = Column(Integer, default=0)   # in minutes&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company_category = relationship(&quot;CompanyCategories&quot;, back_populates=&quot;category_service&quot;)&#10;    booking_category_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;category_service&quot;)&#10;&#10;&#10;class BookingServices(BaseModel):&#10;    __tablename__ = &quot;booking_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    booking_id = Column(UUID, ForeignKey(&quot;bookings.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    category_service_id = Column(UUID, ForeignKey(&quot;category_services.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;SET NULL&quot;))&#10;    notes = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;    start_at = Column(DateTime, nullable=True)&#10;    end_at = Column(DateTime, nullable=True)&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;booking_services&quot;)&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;booking_category_services&quot;)&#10;&#10;&#10;&#10;class CompanyNotifications(BaseModel):&#10;    __tablename__ = &quot;company_notifications&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    type = Column(SQLAlchemyEnum(NotificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(NotificationStatus), default=NotificationStatus.UNREAD)&#10;    message = Column(Text, nullable=False)&#10;    data = Column(LargeBinary, nullable=True)  # JSON or additional data&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;&#10;class MembershipPlans(BaseModel):&#10;    __tablename__ = &quot;membership_plans&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(100), nullable=False, unique=True)&#10;    plan_type = Column(SQLAlchemyEnum(MembershipPlanType), nullable=False, unique=True)&#10;    description = Column(Text)&#10;    url = Column(Text)&#10;    price = Column(Integer, nullable=False)  # Price in cents&#10;    duration_days = Column(Integer, nullable=False, default=30)  # Subscription duration&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    subscriptions = relationship(&quot;CompanyMemberships&quot;, back_populates=&quot;membership_plan&quot;)&#10;&#10;&#10;class CompanyMemberships(BaseModel):&#10;    __tablename__ = &quot;company_memberships&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    membership_plan_id = Column(UUID, ForeignKey(&quot;membership_plans.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    start_date = Column(DateTime, nullable=False, default=func.now())&#10;    end_date = Column(DateTime, nullable=False)&#10;    auto_renew = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    membership_plan = relationship(&quot;MembershipPlans&quot;, back_populates=&quot;subscriptions&quot;)&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active membership at a time&#10;        Index(&#10;            'unique_active_company_membership',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class TelegramIntegrations(BaseModel):&#10;    __tablename__ = &quot;telegram_integrations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    bot_token_encrypted = Column(String(255), nullable=False)&#10;    chat_id = Column(String(255), nullable=True)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active telegram integration&#10;        Index(&#10;            'unique_active_telegram_integration',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class Invitations(BaseModel):&#10;    __tablename__ = &quot;invitations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    email = Column(String(255), nullable=False)&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)&#10;    status = Column(SQLAlchemyEnum(InvitationStatus), default=InvitationStatus.PENDING)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company = relationship(&quot;Companies&quot;, back_populates=&quot;invitations&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('email', 'company_id', name='_email_company_uc'),)" />
              <option name="updatedContent" value="import uuid&#10;&#10;from pydantic.v1 import create_model_from_typeddict&#10;from sqlalchemy import (Column, Integer, String, Boolean, DateTime, Text, Date, ForeignKey, UniqueConstraint, UUID,&#10;                        Time,&#10;                        CheckConstraint, false, BLOB, LargeBinary, Index)&#10;from sqlalchemy.dialects.postgresql import ENUM as SQLAlchemyEnum&#10;from sqlalchemy.orm import relationship&#10;from sqlalchemy.sql import func&#10;from sqlalchemy.sql import expression&#10;&#10;from app.db.base_class import BaseModel&#10;from app.models.enums import (StatusType, BookingStatus, CustomerStatusType, EmailStatusType,&#10;                              PhoneStatusType, VerificationType, VerificationStatus,&#10;                              CompanyRoleType, NotificationType, NotificationStatus, MembershipPlanType, InvitationStatus)&#10;&#10;&#10;#&#10;class Users(BaseModel):&#10;    __tablename__ = &quot;users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company_user = relationship(&quot;CompanyUsers&quot;, back_populates=&quot;user&quot;)&#10;    user_time_offs = relationship(&quot;UserTimeOffs&quot;, back_populates=&quot;user&quot;)&#10;&#10;&#10;class UserVerifications(BaseModel):&#10;    __tablename__ = &quot;user_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;&#10;class UserAvailabilities(BaseModel):&#10;    __tablename__ = &quot;user_availabilities&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    day_of_week = Column(Integer, nullable=False)  # 0=Monday, 6=Sunday&#10;    start_time = Column(Time, nullable=False)  # Store only time (HH:MM)&#10;    end_time = Column(Time, nullable=False)    # Store only time (HH:MM)&#10;    is_available = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    __table_args__ = (&#10;        # Add constraint to ensure start_time is before end_time&#10;        CheckConstraint('start_time &lt; end_time', name='check_time_order'),&#10;        # Add unique constraint to prevent overlapping time slots for the same user and day&#10;        UniqueConstraint('user_id', 'day_of_week', 'start_time', 'end_time', name='unique_user_availability')&#10;    )&#10;&#10;&#10;class UserTimeOffs(BaseModel):&#10;    __tablename__ = &quot;user_time_offs&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    start_date = Column(DateTime, nullable=False)&#10;    end_date = Column(DateTime, nullable=False)&#10;    reason = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;user_time_offs&quot;)&#10;&#10;&#10;class Companies(BaseModel):&#10;    __tablename__ = &quot;companies&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(255), nullable=False)&#10;    type = Column(String(255), nullable=False)&#10;    logo_url = Column(String(255))&#10;    website = Column(String(255))&#10;    description = Column(Text)&#10;    team_size = Column(Integer, default=1)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    invitations = relationship(&quot;Invitations&quot;, back_populates=&quot;company&quot;)&#10;&#10;&#10;class CompanyEmails(BaseModel):&#10;    __tablename__ = &quot;company_emails&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CompanyPhones(BaseModel):&#10;    __tablename__ = &quot;company_phones&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CompanyAddresses(BaseModel):&#10;    __tablename__ = &quot;company_addresses&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address = Column(String(255), nullable=False)&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;&#10;class CompanyUsers(BaseModel):&#10;    __tablename__ = &quot;company_users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)  # e.g., admin, member&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.inactive)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;company_user&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('user_id', 'company_id', name='_user_company_uc'),)&#10;&#10;&#10;class Customers(BaseModel):&#10;    __tablename__ = &quot;customers&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;customer&quot;)&#10;&#10;class CustomerEmails(BaseModel):&#10;    __tablename__ = &quot;customer_emails&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerPhones(BaseModel):&#10;    __tablename__ = &quot;customer_phones&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerAddresses(BaseModel):&#10;    __tablename__ = &quot;customer_addresses&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address_line1 = Column(String(255), nullable=False)&#10;    address_line2 = Column(String(255))&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;class CustomerVerifications(BaseModel):&#10;    __tablename__ = &quot;customer_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=func.now())&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;class Bookings(BaseModel):&#10;    __tablename__ = &quot;bookings&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    status = Column(SQLAlchemyEnum(BookingStatus), default=BookingStatus.SCHEDULED)&#10;    start_at = Column(DateTime, nullable=False)&#10;    end_at = Column(DateTime, nullable=False)&#10;    total_price = Column(Integer, nullable=False)&#10;    notes = Column(Text)&#10;&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    customer = relationship(&quot;Customers&quot;, back_populates=&quot;booking&quot;)&#10;    booking_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;booking&quot;)&#10;&#10;&#10;class CompanyCategories(BaseModel):&#10;    __tablename__ = &quot;company_categories&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(100), nullable=False)&#10;    description = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;company_category&quot;)&#10;&#10;&#10;class CategoryServices(BaseModel):&#10;    __tablename__ = &quot;category_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    category_id = Column(UUID, ForeignKey(&quot;company_categories.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(255))&#10;    duration = Column(Integer)&#10;    price = Column(Integer)&#10;    discount_price = Column(Integer)&#10;    additional_info = Column(Text)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    buffer_before = Column(Integer, default=0)  # in minutes&#10;    buffer_after = Column(Integer, default=0)   # in minutes&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company_category = relationship(&quot;CompanyCategories&quot;, back_populates=&quot;category_service&quot;)&#10;    booking_category_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;category_service&quot;)&#10;&#10;&#10;class BookingServices(BaseModel):&#10;    __tablename__ = &quot;booking_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    booking_id = Column(UUID, ForeignKey(&quot;bookings.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    category_service_id = Column(UUID, ForeignKey(&quot;category_services.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;SET NULL&quot;))&#10;    notes = Column(Text)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;    start_at = Column(DateTime, nullable=True)&#10;    end_at = Column(DateTime, nullable=True)&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;booking_services&quot;)&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;booking_category_services&quot;)&#10;&#10;&#10;&#10;class CompanyNotifications(BaseModel):&#10;    __tablename__ = &quot;company_notifications&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    type = Column(SQLAlchemyEnum(NotificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(NotificationStatus), default=NotificationStatus.UNREAD)&#10;    message = Column(Text, nullable=False)&#10;    data = Column(LargeBinary, nullable=True)  # JSON or additional data&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;&#10;class MembershipPlans(BaseModel):&#10;    __tablename__ = &quot;membership_plans&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(100), nullable=False, unique=True)&#10;    plan_type = Column(SQLAlchemyEnum(MembershipPlanType), nullable=False, unique=True)&#10;    description = Column(Text)&#10;    url = Column(Text)&#10;    price = Column(Integer, nullable=False)  # Price in cents&#10;    duration_days = Column(Integer, nullable=False, default=30)  # Subscription duration&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    subscriptions = relationship(&quot;CompanyMemberships&quot;, back_populates=&quot;membership_plan&quot;)&#10;&#10;&#10;class CompanyMemberships(BaseModel):&#10;    __tablename__ = &quot;company_memberships&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    membership_plan_id = Column(UUID, ForeignKey(&quot;membership_plans.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    start_date = Column(DateTime, nullable=False, default=func.now())&#10;    end_date = Column(DateTime, nullable=False)&#10;    auto_renew = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    membership_plan = relationship(&quot;MembershipPlans&quot;, back_populates=&quot;subscriptions&quot;)&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active membership at a time&#10;        Index(&#10;            'unique_active_company_membership',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class TelegramIntegrations(BaseModel):&#10;    __tablename__ = &quot;telegram_integrations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    bot_token_encrypted = Column(String(255), nullable=False)&#10;    chat_id = Column(String(255), nullable=True)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active telegram integration&#10;        Index(&#10;            'unique_active_telegram_integration',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class Invitations(BaseModel):&#10;    __tablename__ = &quot;invitations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    email = Column(String(255), nullable=False)&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)&#10;    status = Column(SQLAlchemyEnum(InvitationStatus), default=InvitationStatus.PENDING)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    created_at = Column(DateTime, default=func.now())&#10;    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())&#10;&#10;    company = relationship(&quot;Companies&quot;, back_populates=&quot;invitations&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('email', 'company_id', name='_email_company_uc'),)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/booking.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/booking.py" />
              <option name="originalContent" value="from datetime import timedelta&#10;from typing import List, Optional, Any&#10;from datetime import date&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import BookingServices, Customers&#10;from app.models.models import Bookings&#10;from app.models.enums import BookingStatus&#10;from app.schemas import BookingServiceRequest&#10;from app.schemas.schemas import BookingCreate, BookingUpdate&#10;from app.services.crud import service&#10;from app.core.redis_client import publish_event&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Bookings]:&#10;    return db.query(Bookings).filter(Bookings.id == id).first()&#10;&#10;&#10;def get_all(db: Session, skip: int = 0, limit: int = 100) -&gt; list[type[Bookings]]:&#10;    return list(db.query(Bookings).offset(skip).limit(limit).all())&#10;&#10;def get_user_bookings_in_range(db: Session, user_id: str, start_date: Any, end_date: Any) -&gt; list[&quot;Bookings&quot;]:&#10;    return list(db.query(Bookings).join(BookingServices).filter(&#10;        BookingServices.user_id == user_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all())&#10;&#10;def get_all_bookings_in_range(db: Session, start_date: date, end_date: date):&#10;    # Join Bookings and BookingServices, return tuples of (booking, user_id)&#10;    return db.query(Bookings, BookingServices.user_id).join(BookingServices, Bookings.id == BookingServices.booking_id).filter(&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all()&#10;&#10;&#10;def get_all_bookings_in_range_by_company(db: Session, company_id: str, start_date: date, end_date: date):&#10;    return (db.query(Bookings).join(BookingServices, Bookings.id == BookingServices.booking_id)&#10;          .filter(&#10;        Bookings.company_id == company_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date,&#10;        Bookings.status.in_(['scheduled', 'confirmed', 'completed'])&#10;    ).all())&#10;&#10;def calc_service_params(db, services: List[BookingServiceRequest], company_id: str = None) -&gt; tuple[int, int]:&#10;    total_duration = 0&#10;    total_price = 0&#10;&#10;    for srv in services:&#10;        selected_srv = service.get_service(db, srv.category_service_id, company_id)&#10;        total_duration += selected_srv.duration&#10;        total_price += int(selected_srv.price)&#10;&#10;    return total_duration, total_price&#10;&#10;&#10;def create(db: Session, *, obj_in: BookingCreate, customer_id: UUID4) -&gt; Bookings:&#10;    total_duration, total_price = calc_service_params(db, obj_in.services, obj_in.company_id)&#10;    db_obj = Bookings(&#10;        customer_id=customer_id,&#10;        company_id=obj_in.company_id,&#10;        start_at=obj_in.start_time,&#10;        end_at= obj_in.start_time + timedelta(minutes=total_duration),&#10;        total_price=total_price,&#10;        notes=obj_in.notes&#10;    )&#10;    db.add(db_obj)&#10;    db.commit()&#10;&#10;    start_time = obj_in.start_time&#10;    for srv in obj_in.services:&#10;        duration, _ = calc_service_params(db, [srv], obj_in.company_id)&#10;        db_service_obj = BookingServices(&#10;            booking_id=db_obj.id,&#10;            category_service_id=srv.category_service_id,&#10;            user_id=srv.user_id,&#10;            notes=srv.notes,&#10;            start_at=start_time,&#10;            end_at=start_time + timedelta(minutes=duration)&#10;        )&#10;        start_time = db_service_obj.end_at&#10;        db.add(db_service_obj)&#10;&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    # Publish booking created event&#10;    publish_event(&quot;booking_created&quot;, str(db_obj.id))&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Bookings, obj_in: BookingUpdate) -&gt; Bookings:&#10;    &quot;&quot;&quot;&#10;    Update a booking and its associated services.&#10;    &quot;&quot;&quot;&#10;    # Update basic booking fields&#10;    if obj_in.start_time is not None:&#10;        db_obj.start_at = obj_in.start_time&#10;    if obj_in.notes is not None:&#10;        db_obj.notes = obj_in.notes&#10;    if obj_in.status is not None:&#10;        db_obj.status = obj_in.status&#10;&#10;    # If services are being updated, we need to recalculate everything&#10;    if obj_in.services is not None:&#10;        # Remove existing booking services&#10;        db.query(BookingServices).filter(BookingServices.booking_id == db_obj.id).delete()&#10;&#10;        # Recalculate total duration and price&#10;        total_duration, total_price = calc_service_params(db, obj_in.services, str(db_obj.company_id))&#10;        db_obj.total_price = total_price&#10;&#10;        # Update end time based on new start time and duration&#10;        start_time = obj_in.start_time if obj_in.start_time is not None else db_obj.start_at&#10;        db_obj.end_at = start_time + timedelta(minutes=total_duration)&#10;&#10;        # Create new booking services&#10;        current_start_time = start_time&#10;        for srv in obj_in.services:&#10;            duration, _ = calc_service_params(db, [srv], str(db_obj.company_id))&#10;            db_service_obj = BookingServices(&#10;                booking_id=db_obj.id,&#10;                category_service_id=srv.category_service_id,&#10;                user_id=srv.user_id,&#10;                notes=srv.notes,&#10;                start_at=current_start_time,&#10;                end_at=current_start_time + timedelta(minutes=duration)&#10;            )&#10;            current_start_time = db_service_obj.end_at&#10;            db.add(db_service_obj)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def cancel(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by setting its status to CANCELLED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CANCELLED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None&#10;&#10;&#10;def confirm(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CONFIRMED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None&#10;" />
              <option name="updatedContent" value="from datetime import timedelta&#10;from typing import List, Optional, Any&#10;from datetime import date&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import BookingServices, Customers&#10;from app.models.models import Bookings&#10;from app.models.enums import BookingStatus&#10;from app.schemas import BookingServiceRequest&#10;from app.schemas.schemas import BookingCreate, BookingUpdate&#10;from app.services.crud import service&#10;from app.core.redis_client import publish_event&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Bookings]:&#10;    return db.query(Bookings).filter(Bookings.id == id).first()&#10;&#10;&#10;def get_all(db: Session, skip: int = 0, limit: int = 100) -&gt; list[type[Bookings]]:&#10;    return list(db.query(Bookings).offset(skip).limit(limit).all())&#10;&#10;def get_user_bookings_in_range(db: Session, user_id: str, start_date: Any, end_date: Any) -&gt; list[&quot;Bookings&quot;]:&#10;    return list(db.query(Bookings).join(BookingServices).filter(&#10;        BookingServices.user_id == user_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all())&#10;&#10;def get_all_bookings_in_range(db: Session, start_date: date, end_date: date):&#10;    # Join Bookings and BookingServices, return tuples of (booking, user_id)&#10;    return db.query(Bookings, BookingServices.user_id).join(BookingServices, Bookings.id == BookingServices.booking_id).filter(&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all()&#10;&#10;&#10;def get_all_bookings_in_range_by_company(db: Session, company_id: str, start_date: date, end_date: date):&#10;    return (db.query(Bookings).join(BookingServices, Bookings.id == BookingServices.booking_id)&#10;          .filter(&#10;        Bookings.company_id == company_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date,&#10;        Bookings.status.in_(['scheduled', 'confirmed', 'completed'])&#10;    ).all())&#10;&#10;def calc_service_params(db, services: List[BookingServiceRequest], company_id: str = None) -&gt; tuple[int, int]:&#10;    total_duration = 0&#10;    total_price = 0&#10;&#10;    for srv in services:&#10;        selected_srv = service.get_service(db, srv.category_service_id, company_id)&#10;        total_duration += selected_srv.duration&#10;        total_price += int(selected_srv.price)&#10;&#10;    return total_duration, total_price&#10;&#10;&#10;def create(db: Session, *, obj_in: BookingCreate, customer_id: UUID4) -&gt; Bookings:&#10;    total_duration, total_price = calc_service_params(db, obj_in.services, obj_in.company_id)&#10;    db_obj = Bookings(&#10;        customer_id=customer_id,&#10;        company_id=obj_in.company_id,&#10;        start_at=obj_in.start_time,&#10;        end_at= obj_in.start_time + timedelta(minutes=total_duration),&#10;        total_price=total_price,&#10;        notes=obj_in.notes&#10;    )&#10;    db.add(db_obj)&#10;    db.commit()&#10;&#10;    start_time = obj_in.start_time&#10;    for srv in obj_in.services:&#10;        duration, _ = calc_service_params(db, [srv], obj_in.company_id)&#10;        db_service_obj = BookingServices(&#10;            booking_id=db_obj.id,&#10;            category_service_id=srv.category_service_id,&#10;            user_id=srv.user_id,&#10;            notes=srv.notes,&#10;            start_at=start_time,&#10;            end_at=start_time + timedelta(minutes=duration)&#10;        )&#10;        start_time = db_service_obj.end_at&#10;        db.add(db_service_obj)&#10;&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    # Publish booking created event&#10;    publish_event(&quot;booking_created&quot;, str(db_obj.id))&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Bookings, obj_in: BookingUpdate) -&gt; Bookings:&#10;    &quot;&quot;&quot;&#10;    Update a booking and its associated services.&#10;    &quot;&quot;&quot;&#10;    # Update basic booking fields&#10;    if obj_in.start_time is not None:&#10;        db_obj.start_at = obj_in.start_time&#10;    if obj_in.notes is not None:&#10;        db_obj.notes = obj_in.notes&#10;    if obj_in.status is not None:&#10;        db_obj.status = obj_in.status&#10;&#10;    # If services are being updated, we need to recalculate everything&#10;    if obj_in.services is not None:&#10;        # Remove existing booking services&#10;        db.query(BookingServices).filter(BookingServices.booking_id == db_obj.id).delete()&#10;&#10;        # Recalculate total duration and price&#10;        total_duration, total_price = calc_service_params(db, obj_in.services, str(db_obj.company_id))&#10;        db_obj.total_price = total_price&#10;&#10;        # Update end time based on new start time and duration&#10;        start_time = obj_in.start_time if obj_in.start_time is not None else db_obj.start_at&#10;        db_obj.end_at = start_time + timedelta(minutes=total_duration)&#10;&#10;        # Create new booking services&#10;        current_start_time = start_time&#10;        for srv in obj_in.services:&#10;            duration, _ = calc_service_params(db, [srv], str(db_obj.company_id))&#10;            db_service_obj = BookingServices(&#10;                booking_id=db_obj.id,&#10;                category_service_id=srv.category_service_id,&#10;                user_id=srv.user_id,&#10;                notes=srv.notes,&#10;                start_at=current_start_time,&#10;                end_at=current_start_time + timedelta(minutes=duration)&#10;            )&#10;            current_start_time = db_service_obj.end_at&#10;            db.add(db_service_obj)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def cancel(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by setting its status to CANCELLED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CANCELLED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None&#10;&#10;&#10;def confirm(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CONFIRMED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/company.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/company.py" />
              <option name="originalContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import date&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyRoleType, StatusType, UserAvailabilities, UserTimeOffs, CategoryServices, \&#10;    CompanyCategories, CompanyEmails, CompanyPhones, Users&#10;from app.models.models import CompanyUsers, Companies&#10;from app.schemas import CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, UserCreate, CompanyUser&#10;from app.schemas.schemas import (&#10;    CompanyCreate,&#10;    User&#10;)&#10;from app.services.auth import hash_password&#10;&#10;&#10;def get(db: Session, id: str) -&gt; Optional[Companies]:&#10;    return db.query(Companies).filter(Companies.id == id).first()&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUsers]:&#10;    &quot;&quot;&quot;Get all users belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyUsers).filter(CompanyUsers.company_id == company_id).all())&#10;&#10;&#10;def get_company_user(db: Session, company_id: str, user_id: str) -&gt; Optional[CompanyUser]:&#10;    &quot;&quot;&quot;Get company user with user details.&quot;&quot;&quot;&#10;    company_user = (db.query(CompanyUsers)&#10;                    .join(Users, Users.id == CompanyUsers.user_id)&#10;                    .filter(CompanyUsers.company_id == company_id, CompanyUsers.user_id == user_id)&#10;                    .first())&#10;    &#10;    if not company_user:&#10;        return None&#10;    &#10;    # Convert SQLAlchemy model to Pydantic schema&#10;    return CompanyUser.model_validate(company_user)&#10;&#10;&#10;def get_company_services(db: Session, company_id: str) -&gt; List[CompanyCategories]:&#10;    &quot;&quot;&quot;Get all services belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyCategories).join(CategoryServices, CategoryServices.category_id==CompanyCategories.id)&#10;                .filter(CompanyCategories.company_id == company_id).all())&#10;&#10;&#10;def get_company_all_users_availabilities(db: Session, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_user_availabilities(db: Session, user_id: str, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_all_users_time_offs(db: Session, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def get_company_user_time_offs(db: Session, user_id: str, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def create(db: Session, *, obj_in: CompanyCreate, current_user: User) -&gt; Companies:&#10;&#10;    db_obj = Companies(**obj_in.model_dump())&#10;    # db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    cmp_usr_obj = CompanyUsers(user_id=current_user.id,&#10;                               company_id=db_obj.id,&#10;                               role=CompanyRoleType.admin,&#10;                               status=StatusType.active)&#10;    db.add(cmp_usr_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Companies, obj_in: dict) -&gt; Companies:&#10;    &quot;&quot;&quot;&#10;    Update company information&#10;&#10;    Args:&#10;        db: Database session&#10;        db_obj: Existing company object to update&#10;        obj_in: Data to update the company with&#10;&#10;    Returns:&#10;        Updated company object&#10;    &quot;&quot;&quot;&#10;    for field, value in obj_in.items():&#10;        if value is not None:&#10;            setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def create_company_email(db: Session, *, obj_in: CompanyEmailCreate):&#10;    &quot;&quot;&quot;&#10;    Create new emails for a company, handling duplicate emails&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company emails to add&#10;&#10;    Returns:&#10;        List of created/updated email objects&#10;    &quot;&quot;&quot;&#10;    # Get existing emails for this company to check duplicates&#10;    existing_emails = db.query(CompanyEmails).filter(&#10;        CompanyEmails.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing email addresses for efficient lookup&#10;    existing_email_set = {str(email.email).lower() for email in existing_emails}&#10;&#10;    for email in obj_in.emails:&#10;        # Check if this email already exists for this company&#10;        if str(email.email).lower() in existing_email_set:&#10;            # Skip this email as it already exists&#10;            continue&#10;&#10;        # Create new email record&#10;        db_obj = CompanyEmails(&#10;            company_id=obj_in.company_id,&#10;            email=str(email.email).lower(),&#10;            status=email.status.lower()&#10;        )&#10;        db_obj.id = str(uuid.uuid4())&#10;        db.add(db_obj)&#10;&#10;    # Commit all new emails at once&#10;    db.commit()&#10;&#10;&#10;def get_company_emails(db: Session, company_id: str) -&gt; List[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get all emails for a specific company&#10;    &quot;&quot;&quot;&#10;    company_emails = db.query(CompanyEmails).filter(CompanyEmails.company_id == company_id).all()&#10;&#10;    return company_emails&#10;&#10;&#10;&#10;def get_company_email(db: Session, email_id: str) -&gt; Optional[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company email by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyEmails).filter(CompanyEmails.id == email_id).first()&#10;&#10;&#10;def delete_company_email(db: Session, email_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company email&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyEmails).filter(&#10;        CompanyEmails.id == email_id,&#10;        CompanyEmails.company_id == company_id&#10;    ).first()&#10;&#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_phone(db: Session, *, obj_in: CompanyPhoneCreate) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Create new phone numbers for a company, handling duplicate phone numbers&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company phone numbers to add&#10;&#10;    Returns:&#10;        List of created phone number objects&#10;    &quot;&quot;&quot;&#10;    # Get existing phone numbers for this company to check duplicates&#10;    existing_phones = db.query(CompanyPhones).filter(&#10;        CompanyPhones.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing phone numbers for efficient lookup&#10;    existing_phone_set = {phone.phone for phone in existing_phones}&#10;&#10;    created_phones = []&#10;    for phone_data in obj_in.company_phones:&#10;        # Check if this phone number already exists for this company&#10;        if phone_data.phone in existing_phone_set:&#10;            # Skip this phone number as it already exists&#10;            continue&#10;&#10;        # Create new phone number record&#10;        db_obj = CompanyPhones(&#10;            company_id=obj_in.company_id,&#10;            phone=phone_data.phone,&#10;            is_primary=phone_data.is_primary,&#10;            status=phone_data.status&#10;        )&#10;        # db_obj.id = str(uuid.uuid4())&#10;        &#10;        db.add(db_obj)&#10;        created_phones.append(db_obj)&#10;        &#10;    # Commit all new phone numbers at once&#10;    db.commit()&#10;&#10;    # Refresh all newly created objects&#10;    for phone in created_phones:&#10;        db.refresh(phone)&#10;&#10;    return created_phones&#10;&#10;&#10;def get_company_phones(db: Session, company_id: str) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers for a specific company&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.company_id == company_id).all()&#10;&#10;&#10;def get_company_phone(db: Session, phone_id: str) -&gt; Optional[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company phone by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.id == phone_id).first()&#10;&#10;&#10;def delete_company_phone(db: Session, phone_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company phone number&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyPhones).filter(&#10;        CompanyPhones.id == phone_id,&#10;        CompanyPhones.company_id == company_id&#10;    ).first()&#10;    &#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_member(db: Session, *, user_in: UserCreate, company_id: str, role: CompanyRoleType) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to a company with the specified role.&#10;&#10;    Args:&#10;        db: Database session&#10;        user_in: User creation data&#10;        company_id: Company ID to add the user to&#10;        role: Role to assign to the user in the company&#10;&#10;    Returns:&#10;        CompanyUsers object with the user relationship&#10;    &quot;&quot;&quot;&#10;    # Check if user with this email already exists&#10;    existing_user = db.query(Users).filter(Users.email == user_in.email).first()&#10;&#10;    if existing_user:&#10;        # Check if user is already part of this company&#10;        existing_company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == company_id&#10;        ).first()&#10;&#10;        if existing_company_user:&#10;            raise ValueError(&quot;User is already a member of this company&quot;)&#10;&#10;        # Add existing user to the company&#10;        company_user = CompanyUsers(&#10;            user_id=existing_user.id,&#10;            company_id=company_id,&#10;            role=role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;        db.commit()&#10;        db.refresh(company_user)&#10;        return company_user&#10;&#10;    # Create new user&#10;    user_data = user_in.model_dump()&#10;    user_data['password'] = hash_password(user_data['password'])&#10;&#10;    new_user = Users(**user_data)&#10;    new_user.id = str(uuid.uuid4())&#10;    new_user.status = StatusType.active&#10;&#10;    db.add(new_user)&#10;    db.commit()&#10;    db.refresh(new_user)&#10;&#10;    # Add user to company&#10;    company_user = CompanyUsers(&#10;        user_id=new_user.id,&#10;        company_id=company_id,&#10;        role=role,&#10;        status=StatusType.active&#10;    )&#10;    db.add(company_user)&#10;    db.commit()&#10;    db.refresh(company_user)&#10;&#10;    return company_user&#10;" />
              <option name="updatedContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import date&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyRoleType, StatusType, UserAvailabilities, UserTimeOffs, CategoryServices, \&#10;    CompanyCategories, CompanyEmails, CompanyPhones, Users&#10;from app.models.models import CompanyUsers, Companies&#10;from app.schemas import CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, UserCreate, CompanyUser&#10;from app.schemas.schemas import (&#10;    CompanyCreate,&#10;    User&#10;)&#10;from app.services.auth import hash_password&#10;&#10;&#10;def get(db: Session, id: str) -&gt; Optional[Companies]:&#10;    return db.query(Companies).filter(Companies.id == id).first()&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUsers]:&#10;    &quot;&quot;&quot;Get all users belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyUsers).filter(CompanyUsers.company_id == company_id).all())&#10;&#10;&#10;def get_company_user(db: Session, company_id: str, user_id: str) -&gt; Optional[CompanyUser]:&#10;    &quot;&quot;&quot;Get company user with user details.&quot;&quot;&quot;&#10;    company_user = (db.query(CompanyUsers)&#10;                    .join(Users, Users.id == CompanyUsers.user_id)&#10;                    .filter(CompanyUsers.company_id == company_id, CompanyUsers.user_id == user_id)&#10;                    .first())&#10;    &#10;    if not company_user:&#10;        return None&#10;    &#10;    # Convert SQLAlchemy model to Pydantic schema&#10;    return CompanyUser.model_validate(company_user)&#10;&#10;&#10;def get_company_services(db: Session, company_id: str) -&gt; List[CompanyCategories]:&#10;    &quot;&quot;&quot;Get all services belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyCategories).join(CategoryServices, CategoryServices.category_id==CompanyCategories.id)&#10;                .filter(CompanyCategories.company_id == company_id).all())&#10;&#10;&#10;def get_company_all_users_availabilities(db: Session, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_user_availabilities(db: Session, user_id: str, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_all_users_time_offs(db: Session, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def get_company_user_time_offs(db: Session, user_id: str, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def create(db: Session, *, obj_in: CompanyCreate, current_user: User) -&gt; Companies:&#10;&#10;    db_obj = Companies(**obj_in.model_dump())&#10;    # db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    cmp_usr_obj = CompanyUsers(user_id=current_user.id,&#10;                               company_id=db_obj.id,&#10;                               role=CompanyRoleType.admin,&#10;                               status=StatusType.active)&#10;    db.add(cmp_usr_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Companies, obj_in: dict) -&gt; Companies:&#10;    &quot;&quot;&quot;&#10;    Update company information&#10;&#10;    Args:&#10;        db: Database session&#10;        db_obj: Existing company object to update&#10;        obj_in: Data to update the company with&#10;&#10;    Returns:&#10;        Updated company object&#10;    &quot;&quot;&quot;&#10;    for field, value in obj_in.items():&#10;        if value is not None:&#10;            setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def create_company_email(db: Session, *, obj_in: CompanyEmailCreate):&#10;    &quot;&quot;&quot;&#10;    Create new emails for a company, handling duplicate emails&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company emails to add&#10;&#10;    Returns:&#10;        List of created/updated email objects&#10;    &quot;&quot;&quot;&#10;    # Get existing emails for this company to check duplicates&#10;    existing_emails = db.query(CompanyEmails).filter(&#10;        CompanyEmails.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing email addresses for efficient lookup&#10;    existing_email_set = {str(email.email).lower() for email in existing_emails}&#10;&#10;    for email in obj_in.emails:&#10;        # Check if this email already exists for this company&#10;        if str(email.email).lower() in existing_email_set:&#10;            # Skip this email as it already exists&#10;            continue&#10;&#10;        # Create new email record&#10;        db_obj = CompanyEmails(&#10;            company_id=obj_in.company_id,&#10;            email=str(email.email).lower(),&#10;            status=email.status.lower()&#10;        )&#10;        db_obj.id = str(uuid.uuid4())&#10;        db.add(db_obj)&#10;&#10;    # Commit all new emails at once&#10;    db.commit()&#10;&#10;&#10;def get_company_emails(db: Session, company_id: str) -&gt; List[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get all emails for a specific company&#10;    &quot;&quot;&quot;&#10;    company_emails = db.query(CompanyEmails).filter(CompanyEmails.company_id == company_id).all()&#10;&#10;    return company_emails&#10;&#10;&#10;&#10;def get_company_email(db: Session, email_id: str) -&gt; Optional[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company email by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyEmails).filter(CompanyEmails.id == email_id).first()&#10;&#10;&#10;def delete_company_email(db: Session, email_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company email&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyEmails).filter(&#10;        CompanyEmails.id == email_id,&#10;        CompanyEmails.company_id == company_id&#10;    ).first()&#10;&#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_phone(db: Session, *, obj_in: CompanyPhoneCreate) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Create new phone numbers for a company, handling duplicate phone numbers&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company phone numbers to add&#10;&#10;    Returns:&#10;        List of created phone number objects&#10;    &quot;&quot;&quot;&#10;    # Get existing phone numbers for this company to check duplicates&#10;    existing_phones = db.query(CompanyPhones).filter(&#10;        CompanyPhones.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing phone numbers for efficient lookup&#10;    existing_phone_set = {phone.phone for phone in existing_phones}&#10;&#10;    created_phones = []&#10;    for phone_data in obj_in.company_phones:&#10;        # Check if this phone number already exists for this company&#10;        if phone_data.phone in existing_phone_set:&#10;            # Skip this phone number as it already exists&#10;            continue&#10;&#10;        # Create new phone number record&#10;        db_obj = CompanyPhones(&#10;            company_id=obj_in.company_id,&#10;            phone=phone_data.phone,&#10;            is_primary=phone_data.is_primary,&#10;            status=phone_data.status&#10;        )&#10;        # db_obj.id = str(uuid.uuid4())&#10;        &#10;        db.add(db_obj)&#10;        created_phones.append(db_obj)&#10;        &#10;    # Commit all new phone numbers at once&#10;    db.commit()&#10;&#10;    # Refresh all newly created objects&#10;    for phone in created_phones:&#10;        db.refresh(phone)&#10;&#10;    return created_phones&#10;&#10;&#10;def get_company_phones(db: Session, company_id: str) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers for a specific company&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.company_id == company_id).all()&#10;&#10;&#10;def get_company_phone(db: Session, phone_id: str) -&gt; Optional[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company phone by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.id == phone_id).first()&#10;&#10;&#10;def delete_company_phone(db: Session, phone_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company phone number&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyPhones).filter(&#10;        CompanyPhones.id == phone_id,&#10;        CompanyPhones.company_id == company_id&#10;    ).first()&#10;    &#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_member(db: Session, *, user_in: UserCreate, company_id: str, role: CompanyRoleType) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to a company with the specified role.&#10;&#10;    Args:&#10;        db: Database session&#10;        user_in: User creation data&#10;        company_id: Company ID to add the user to&#10;        role: Role to assign to the user in the company&#10;&#10;    Returns:&#10;        CompanyUsers object with the user relationship&#10;    &quot;&quot;&quot;&#10;    # Check if user with this email already exists&#10;    existing_user = db.query(Users).filter(Users.email == user_in.email).first()&#10;&#10;    if existing_user:&#10;        # Check if user is already part of this company&#10;        existing_company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == company_id&#10;        ).first()&#10;&#10;        if existing_company_user:&#10;            raise ValueError(&quot;User is already a member of this company&quot;)&#10;&#10;        # Add existing user to the company&#10;        company_user = CompanyUsers(&#10;            user_id=existing_user.id,&#10;            company_id=company_id,&#10;            role=role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;        db.commit()&#10;        db.refresh(company_user)&#10;        return company_user&#10;&#10;    # Create new user&#10;    user_data = user_in.model_dump()&#10;    user_data['password'] = hash_password(user_data['password'])&#10;&#10;    new_user = Users(**user_data)&#10;    new_user.id = str(uuid.uuid4())&#10;    new_user.status = StatusType.active&#10;&#10;    db.add(new_user)&#10;    db.commit()&#10;    db.refresh(new_user)&#10;&#10;    # Add user to company&#10;    company_user = CompanyUsers(&#10;        user_id=new_user.id,&#10;        company_id=company_id,&#10;        role=role,&#10;        status=StatusType.active&#10;    )&#10;    db.add(company_user)&#10;    db.commit()&#10;    db.refresh(company_user)&#10;&#10;    return company_user" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>