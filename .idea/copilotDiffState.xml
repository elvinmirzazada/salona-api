<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/alembic/versions/add_membership_tables.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic/versions/add_membership_tables.py" />
              <option name="originalContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/api.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/api.py" />
              <option name="originalContent" value="from fastapi import APIRouter&#10;from app.api.api_v1.endpoints import customers, users, companies, services, bookings, notifications, memberships&#10;&#10;api_router = APIRouter()&#10;api_router.include_router(users.router, prefix=&quot;/users&quot;, tags=[&quot;users&quot;])&#10;api_router.include_router(companies.router, prefix=&quot;/companies&quot;, tags=[&quot;companies&quot;])&#10;api_router.include_router(services.router, prefix=&quot;/services&quot;, tags=[&quot;services&quot;])&#10;api_router.include_router(customers.router, prefix=&quot;/customers&quot;, tags=[&quot;customers&quot;])&#10;api_router.include_router(bookings.router, prefix=&quot;/bookings&quot;, tags=[&quot;bookings&quot;])&#10;api_router.include_router(notifications.router, prefix=&quot;/notifications&quot;, tags=[&quot;notifications&quot;])&#10;api_router.include_router(memberships.router, prefix=&quot;/memberships&quot;, tags=[&quot;memberships&quot;])" />
              <option name="updatedContent" value="from fastapi import APIRouter&#10;from app.api.api_v1.endpoints import customers, users, companies, services, bookings, notifications, memberships&#10;&#10;api_router = APIRouter()&#10;api_router.include_router(users.router, prefix=&quot;/users&quot;, tags=[&quot;users&quot;])&#10;api_router.include_router(companies.router, prefix=&quot;/companies&quot;, tags=[&quot;companies&quot;])&#10;api_router.include_router(services.router, prefix=&quot;/services&quot;, tags=[&quot;services&quot;])&#10;api_router.include_router(customers.router, prefix=&quot;/customers&quot;, tags=[&quot;customers&quot;])&#10;api_router.include_router(bookings.router, prefix=&quot;/bookings&quot;, tags=[&quot;bookings&quot;])&#10;api_router.include_router(notifications.router, prefix=&quot;/notifications&quot;, tags=[&quot;notifications&quot;])&#10;api_router.include_router(memberships.router, prefix=&quot;/memberships&quot;, tags=[&quot;memberships&quot;])" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/customers.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/customers.py" />
              <option name="originalContent" value="from typing import List&#10;from sqlalchemy import func&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response&#10;from sqlalchemy.orm import Session&#10;from app.db.session import get_db&#10;from app.schemas.schemas import Customer, CustomerCreate&#10;from app.schemas.auth import LoginRequest, TokenResponse, RefreshTokenRequest, VerificationRequest&#10;from app.services.crud import customer as crud_customer&#10;from app.schemas.responses import DataResponse, ErrorResponse&#10;from app.services.auth import hash_password, verify_password, create_token_pair, refresh_access_token&#10;&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=DataResponse[Customer], status_code=status.HTTP_201_CREATED)&#10;async def create_customer(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    customer_in: CustomerCreate,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new customer with proper response handling and status codes.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        existing_customer = crud_customer.get_by_email(db=db, email=str(customer_in.email).lower())&#10;        if existing_customer:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;Customer with this email already exists&quot;,&#10;                data=None&#10;            )&#10;&#10;        customer_in.password = hash_password(customer_in.password)&#10;        new_customer = crud_customer.create(db=db, obj_in=customer_in)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return DataResponse.success_response(&#10;            message=&quot;Customer created successfully&quot;,&#10;            data=new_customer,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        response.status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Failed to create customer&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=DataResponse)&#10;async def verify_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify customer email with improved error handling.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_customer.get_verification_token(&#10;            db=db,&#10;            token=verification_in.token,&#10;            type=VerificationType.EMAIL&#10;        )&#10;&#10;        if not token:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Verification token not found&quot;&#10;            )&#10;&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Token has expired or is invalid&quot;&#10;            )&#10;&#10;        result = crud_customer.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return DataResponse.success_response(&#10;                message=&quot;Email verified successfully&quot;&#10;            )&#10;&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=&quot;Email verification failed&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Verification process failed: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=DataResponse[TokenResponse])&#10;async def customer_login(&#10;        *,&#10;        login_data: LoginRequest,&#10;        db: Session = Depends(get_db),&#10;        response: Response&#10;) -&gt; DataResponse[TokenResponse]:&#10;    &quot;&quot;&quot;&#10;    Customer login with enhanced response handling.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        customer = crud_customer.get_by_email(db, email=login_data.email)&#10;&#10;        if not customer:&#10;            response.status_code = status.HTTP_401_UNAUTHORIZED&#10;            return DataResponse.error_response(&#10;                message=&quot;Invalid credentials&quot;,&#10;                data=None,&#10;                status_code=status.HTTP_401_UNAUTHORIZED&#10;            )&#10;&#10;        if customer.status != &quot;active&quot;:&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                message=&quot;Customer account is not active&quot;,&#10;                data=None,&#10;                status_code=status.HTTP_403_FORBIDDEN&#10;            )&#10;&#10;        if not verify_password(login_data.password, customer.password):&#10;            response.status_code=status.HTTP_401_UNAUTHORIZED&#10;            return DataResponse.error_response(&#10;                message=&quot;Invalid credentials&quot;,&#10;                data=None,&#10;                status_code=status.HTTP_401_UNAUTHORIZED&#10;            )&#10;&#10;        tokens = create_token_pair(customer.id, customer.email, actor=&quot;customer&quot;, ver=&quot;1&quot;,&#10;                                   company_id=login_data.company_id)&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        return DataResponse.success_response(&#10;            message=&quot;Login successful&quot;,&#10;            data=TokenResponse(**tokens),&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Login failed&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=DataResponse[TokenResponse])&#10;async def refresh_token(&#10;    refresh_data: RefreshTokenRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Refresh access token using refresh token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        tokens = refresh_access_token(refresh_data.refresh_token)&#10;        if not tokens:&#10;            response.status_code = status.HTTP_401_UNAUTHORIZED&#10;            return DataResponse.error_response(&#10;                message=&quot;Invalid credentials&quot;,&#10;                data=None,&#10;                status_code=status.HTTP_401_UNAUTHORIZED&#10;            )&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        return DataResponse.success_response(&#10;            message=&quot;Login successful&quot;,&#10;            data=TokenResponse(**tokens),&#10;        )&#10;    except ValueError as ve:&#10;        response.status_code = status.HTTP_401_UNAUTHORIZED&#10;        return DataResponse.error_response(&#10;            message=str(ve),&#10;            data=None,&#10;            status_code=status.HTTP_401_UNAUTHORIZED&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Login failed: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;@router.put(&quot;/auth/logout&quot;, response_model=DataResponse)&#10;def logout_customer(&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Logout customer by clearing the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        response.delete_cookie(key=&quot;refresh_token&quot;)&#10;        return DataResponse.success_response(&#10;            message=&quot;Logged out successfully&quot;,&#10;            data=None&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Logout failed&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;# TODO: Add endpoints for password reset, forgot password, etc.&#10;" />
              <option name="updatedContent" value="from typing import List&#10;from sqlalchemy import func&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response&#10;from sqlalchemy.orm import Session&#10;from app.db.session import get_db&#10;from app.schemas.schemas import Customer, CustomerCreate&#10;from app.schemas.auth import LoginRequest, TokenResponse, RefreshTokenRequest, VerificationRequest&#10;from app.services.crud import customer as crud_customer&#10;from app.schemas.responses import DataResponse, ErrorResponse&#10;from app.services.auth import hash_password, verify_password, create_token_pair, refresh_access_token&#10;&#10;&#10;router = APIRouter()&#10;&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=DataResponse[Customer], status_code=status.HTTP_201_CREATED)&#10;async def create_customer(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    customer_in: CustomerCreate,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new customer with proper response handling and status codes.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        existing_customer = crud_customer.get_by_email(db=db, email=str(customer_in.email).lower())&#10;        if existing_customer:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;Customer with this email already exists&quot;,&#10;                data=None&#10;            )&#10;&#10;        customer_in.password = hash_password(customer_in.password)&#10;        new_customer = crud_customer.create(db=db, obj_in=customer_in)&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return DataResponse.success_response(&#10;            message=&quot;Customer created successfully&quot;,&#10;            data=new_customer,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except Exception as e:&#10;        response.status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Failed to create customer&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=DataResponse)&#10;async def verify_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify customer email with improved error handling.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_customer.get_verification_token(&#10;            db=db,&#10;            token=verification_in.token,&#10;            type=VerificationType.EMAIL&#10;        )&#10;&#10;        if not token:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Verification token not found&quot;&#10;            )&#10;&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Token has expired or is invalid&quot;&#10;            )&#10;&#10;        result = crud_customer.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return DataResponse.success_response(&#10;                message=&quot;Email verified successfully&quot;&#10;            )&#10;&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=&quot;Email verification failed&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Verification process failed: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=DataResponse[TokenResponse])&#10;async def customer_login(&#10;        *,&#10;        login_data: LoginRequest,&#10;        db: Session = Depends(get_db),&#10;        response: Response&#10;) -&gt; DataResponse[TokenResponse]:&#10;    &quot;&quot;&quot;&#10;    Customer login with enhanced response handling.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        customer = crud_customer.get_by_email(db, email=login_data.email)&#10;&#10;        if not customer:&#10;            response.status_code = status.HTTP_401_UNAUTHORIZED&#10;            return DataResponse.error_response(&#10;                message=&quot;Invalid credentials&quot;,&#10;                data=None,&#10;                status_code=status.HTTP_401_UNAUTHORIZED&#10;            )&#10;&#10;        if customer.status != &quot;active&quot;:&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                message=&quot;Customer account is not active&quot;,&#10;                data=None,&#10;                status_code=status.HTTP_403_FORBIDDEN&#10;            )&#10;&#10;        if not verify_password(login_data.password, customer.password):&#10;            response.status_code=status.HTTP_401_UNAUTHORIZED&#10;            return DataResponse.error_response(&#10;                message=&quot;Invalid credentials&quot;,&#10;                data=None,&#10;                status_code=status.HTTP_401_UNAUTHORIZED&#10;            )&#10;&#10;        tokens = create_token_pair(customer.id, customer.email, actor=&quot;customer&quot;, ver=&quot;1&quot;,&#10;                                   company_id=login_data.company_id)&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        return DataResponse.success_response(&#10;            message=&quot;Login successful&quot;,&#10;            data=TokenResponse(**tokens),&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Login failed&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=DataResponse[TokenResponse])&#10;async def refresh_token(&#10;    refresh_data: RefreshTokenRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Refresh access token using refresh token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        tokens = refresh_access_token(refresh_data.refresh_token)&#10;        if not tokens:&#10;            response.status_code = status.HTTP_401_UNAUTHORIZED&#10;            return DataResponse.error_response(&#10;                message=&quot;Invalid credentials&quot;,&#10;                data=None,&#10;                status_code=status.HTTP_401_UNAUTHORIZED&#10;            )&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,  # only over HTTPS&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        return DataResponse.success_response(&#10;            message=&quot;Login successful&quot;,&#10;            data=TokenResponse(**tokens),&#10;        )&#10;    except ValueError as ve:&#10;        response.status_code = status.HTTP_401_UNAUTHORIZED&#10;        return DataResponse.error_response(&#10;            message=str(ve),&#10;            data=None,&#10;            status_code=status.HTTP_401_UNAUTHORIZED&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Login failed: {str(e)}&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;@router.put(&quot;/auth/logout&quot;, response_model=DataResponse)&#10;def logout_customer(&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Logout customer by clearing the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        response.delete_cookie(key=&quot;refresh_token&quot;)&#10;        return DataResponse.success_response(&#10;            message=&quot;Logged out successfully&quot;,&#10;            data=None&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Logout failed&quot;,&#10;            data=None,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;# TODO: Add endpoints for password reset, forgot password, etc." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/api_v1/endpoints/users.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/api_v1/endpoints/users.py" />
              <option name="originalContent" value="import time&#10;&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List, Optional, Union&#10;from datetime import datetime, timedelta&#10;&#10;from app.api.dependencies import get_current_active_user, get_current_company_id, get_current_company_user&#10;from app.db.session import get_db&#10;from app.models import AvailabilityType&#10;from app.schemas import User, CompanyUser&#10;from app.schemas.auth import LoginRequest, TokenResponse, VerificationRequest&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import ResponseMessage, TimeOffCreate, TimeOff, TimeOffUpdate&#10;from app.schemas.schemas import UserCreate&#10;from app.services.auth import hash_password, verify_password, create_token_pair, verify_token&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_time_off&#10;from app.services.crud import company as crud_company&#10;from app.services.email_service import email_service, create_verification_token&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;router = APIRouter()&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=ResponseMessage, status_code=status.HTTP_201_CREATED)&#10;async def create_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    user_in: UserCreate&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Register a new user and send email verification.&#10;    &quot;&quot;&quot;&#10;&#10;    try:&#10;        user_in.email = user_in.email.lower()&#10;        existing_user = crud_user.get_by_email(&#10;            db=db,&#10;            email=user_in.email&#10;        )&#10;        if existing_user:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return ResponseMessage(message=&quot;User with this email already exists&quot;, status=&quot;error&quot;)&#10;&#10;        user_in.password = hash_password(user_in.password)&#10;        new_user = crud_user.create(db=db, obj_in=user_in)&#10;&#10;        # Create verification token&#10;        verification_record = create_verification_token(&#10;            db=db,&#10;            entity_id=new_user.id,&#10;            verification_type=VerificationType.EMAIL,&#10;            entity_type=&quot;user&quot;,&#10;            expires_in_hours=24&#10;        )&#10;&#10;        # Send verification email&#10;        user_name = f&quot;{new_user.first_name} {new_user.last_name}&quot;&#10;        email_sent = email_service.send_verification_email(&#10;            to_email=new_user.email,&#10;            verification_token=verification_record.token,&#10;            user_name=user_name&#10;        )&#10;&#10;        if not email_sent:&#10;            print(f&quot;Warning: Failed to send verification email to {new_user.email}&quot;)&#10;&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return ResponseMessage(&#10;            message=&quot;User created successfully. Please check your email to verify your account.&quot;,&#10;            status=&quot;success&quot;&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=DataResponse)&#10;async def verify_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify user email with token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_user.get_verification_token(&#10;            db=db,&#10;            token=verification_in.token,&#10;            type=VerificationType.EMAIL&#10;        )&#10;&#10;        if not token:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Verification token not found&quot;&#10;            )&#10;&#10;        if token.status != VerificationStatus.PENDING or token.expires_at &lt; datetime.now():&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Token has expired or is invalid&quot;&#10;            )&#10;&#10;        result = crud_user.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return DataResponse.success_response(&#10;                message=&quot;Email verified successfully&quot;&#10;            )&#10;&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=&quot;Email verification failed&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Verification process failed: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=DataResponse[TokenResponse])&#10;async def user_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Login professional using mobile number or email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    # Try to get professional by mobile number first&#10;    user = crud_user.get_by_email(db, email=login_data.email)&#10;&#10;    if not user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Verify password&#10;    if not verify_password(login_data.password, user.password):&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;    company = crud_user.get_company_by_user(db, user.id)&#10;    # Create token pair&#10;    tokens = create_token_pair(user.id, user.email, actor=&quot;user&quot;, ver=&quot;1&quot;, company_id=str(company.company_id) if company else '')&#10;    response.set_cookie(&#10;        key=&quot;refresh_token&quot;,&#10;        value=tokens[&quot;refresh_token&quot;],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;none&quot;&#10;    )&#10;    response.set_cookie(&#10;        key=&quot;access_token&quot;,&#10;        value=tokens[&quot;access_token&quot;],&#10;        max_age=tokens['expires_in'],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;none&quot;&#10;    )&#10;&#10;    print(tokens)&#10;    return DataResponse.success_response(data = TokenResponse(**tokens))&#10;&#10;&#10;@router.put(&quot;/auth/logout&quot;)&#10;async def logout_user(response: Response):&#10;    &quot;&quot;&quot;&#10;    Logout professional by clearing the refresh token cookie&#10;    &quot;&quot;&quot;&#10;    try:&#10;        response.delete_cookie(key=&quot;refresh_token&quot;)&#10;        response.delete_cookie(key=&quot;access_token&quot;)&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.get(&quot;/me&quot;, response_model=DataResponse)&#10;async def get_current_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get current logged-in user. Returns CompanyUser if user belongs to a company, otherwise returns User.&#10;    &quot;&quot;&quot;&#10;    # Check if user belongs to a company&#10;    if current_user.company_id:&#10;        try:&#10;            # Get company user details&#10;            company_user = crud_company.get_company_user(&#10;                db=db, &#10;                user_id=str(current_user.id), &#10;                company_id=str(current_user.company_id)&#10;            )&#10;            if company_user:&#10;                return DataResponse.success_response(data=company_user)&#10;        except Exception as e:&#10;            print(f&quot;Error fetching company user: {str(e)}&quot;)&#10;            # Fall through to return basic user if company user fetch fails&#10;    &#10;    # Return basic user if no company association&#10;    return DataResponse.success_response(data=current_user)&#10;&#10;&#10;@router.post(&quot;/time-offs&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_201_CREATED)&#10;async def create_time_off(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffCreate,&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for the current user.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=time_off_in.user_id,&#10;            start_date=time_off_in.start_date,&#10;            end_date=time_off_in.end_date&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Create the time off&#10;        time_off = crud_time_off.create(&#10;            db=db,&#10;            obj_in=time_off_in,&#10;            company_id=company_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off created successfully&quot;,&#10;            data=time_off,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/time-offs&quot;, response_model=DataResponse[List[TimeOff]], status_code=status.HTTP_200_OK)&#10;async def get_all_user_time_offs(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    start_date: datetime = Query(datetime.today(), description=&quot;Filter time offs that end after this date&quot;),&#10;    availability_type: AvailabilityType = Query(AvailabilityType.WEEKLY, description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all time offs for the current user with optional date filtering.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        end_date = start_date + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        time_offs = crud_time_off.get_user_time_offs(&#10;            db=db,&#10;            company_id=company_id,&#10;            start_date=start_date,&#10;            end_date=end_date&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=time_offs,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve time offs: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_200_OK)&#10;async def update_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffUpdate,&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the time off by ID&#10;        time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;        if not time_off:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Time off not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if the time off belongs to the current user&#10;        if str(time_off.user_id) != str(current_user.id):&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                message=&quot;You don't have permission to update this time off&quot;,&#10;                status_code=status.HTTP_403_FORBIDDEN&#10;            )&#10;&#10;        # Determine the new start and end dates for overlap check&#10;        start_date = time_off_in.start_date if time_off_in.start_date is not None else time_off.start_date&#10;        end_date = time_off_in.end_date if time_off_in.end_date is not None else time_off.end_date&#10;&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=current_user.id,&#10;            start_date=start_date,&#10;            end_date=end_date,&#10;            exclude_id=time_off_id&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The updated time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the time off&#10;        updated_time_off = crud_time_off.update(&#10;            db=db,&#10;            db_obj=time_off,&#10;            obj_in=time_off_in&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off updated successfully&quot;,&#10;            data=updated_time_off,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def delete_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period.&#10;    &quot;&quot;&quot;&#10;    # Get the time off by ID&#10;    time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;    if not time_off:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            message=&quot;Time off not found&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    # Check if the time off belongs to the current user&#10;    if str(time_off.user_id) != str(current_user.id):&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            message=&quot;You don't have permission to delete this time off&quot;,&#10;            status_code=status.HTTP_403_FORBIDDEN&#10;        )&#10;&#10;    # Delete the time off&#10;    deleted = crud_time_off.delete(db=db, time_off_id=time_off_id)&#10;    if not deleted:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Failed to delete time off&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Time off deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=DataResponse[TokenResponse])&#10;async def refresh_token(&#10;    request: Request,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Refresh access and refresh tokens using the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the refresh token from the request cookies&#10;        refresh_token = request.cookies.get(&quot;refresh_token&quot;)&#10;        if not refresh_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Refresh token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the refresh token&#10;        payload = verify_token(refresh_token, &quot;refresh&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid refresh token&quot;&#10;            )&#10;&#10;        # Extract user data from payload&#10;        user_id = payload.get(&quot;sub&quot;)&#10;        email = payload.get(&quot;email&quot;)&#10;        company_id = payload.get(&quot;company_id&quot;)&#10;&#10;        if not user_id or not email:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid token payload&quot;&#10;            )&#10;&#10;        # Create new tokens&#10;        new_tokens = create_token_pair(&#10;            id=int(user_id),&#10;            email=email,&#10;            actor=&quot;user&quot;,&#10;            ver=&quot;1&quot;,&#10;            company_id=company_id&#10;        )&#10;&#10;        # Set new cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=new_tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=new_tokens[&quot;access_token&quot;],&#10;            max_age=new_tokens['expires_in'],&#10;            httponly=True,&#10;            secure=True,&#10;            samesite=&quot;strict&quot;&#10;        )&#10;&#10;        return DataResponse.success_response(data=TokenResponse(**new_tokens))&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to refresh token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/verify-token&quot;, response_model=DataResponse[dict])&#10;async def verify_access_token(&#10;    request: Request,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify the access token and return the token data.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the access token from the request cookies&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Access token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the access token&#10;        payload = verify_token(access_token, &quot;access&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid or expired access token&quot;&#10;            )&#10;&#10;        # Return token validity info&#10;        return DataResponse.success_response(data={&#10;            &quot;valid&quot;: True,&#10;            &quot;user_id&quot;: payload.get(&quot;sub&quot;),&#10;            &quot;email&quot;: payload.get(&quot;email&quot;),&#10;            &quot;company_id&quot;: payload.get(&quot;company_id&quot;),&#10;            &quot;expires_at&quot;: payload.get(&quot;exp&quot;)&#10;        })&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to verify token: {str(e)}&quot;&#10;        )&#10;" />
              <option name="updatedContent" value="import time&#10;&#10;from fastapi import APIRouter, Depends, HTTPException, status, Response, Query, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List, Optional, Union&#10;from datetime import datetime, timedelta&#10;&#10;from app.api.dependencies import get_current_active_user, get_current_company_id, get_current_company_user&#10;from app.db.session import get_db&#10;from app.models import AvailabilityType&#10;from app.schemas import User, CompanyUser&#10;from app.schemas.auth import LoginRequest, TokenResponse, VerificationRequest&#10;from app.schemas.responses import DataResponse&#10;from app.schemas.schemas import ResponseMessage, TimeOffCreate, TimeOff, TimeOffUpdate&#10;from app.schemas.schemas import UserCreate&#10;from app.services.auth import hash_password, verify_password, create_token_pair, verify_token&#10;from app.services.crud import user as crud_user&#10;from app.services.crud import user_time_off as crud_time_off&#10;from app.services.crud import company as crud_company&#10;from app.services.email_service import email_service, create_verification_token&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;router = APIRouter()&#10;&#10;@router.post(&quot;/auth/signup&quot;, response_model=ResponseMessage, status_code=status.HTTP_201_CREATED)&#10;async def create_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    user_in: UserCreate&#10;) -&gt; ResponseMessage:&#10;    &quot;&quot;&quot;&#10;    Register a new user and send email verification.&#10;    &quot;&quot;&quot;&#10;&#10;    try:&#10;        user_in.email = user_in.email.lower()&#10;        existing_user = crud_user.get_by_email(&#10;            db=db,&#10;            email=user_in.email&#10;        )&#10;        if existing_user:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return ResponseMessage(message=&quot;User with this email already exists&quot;, status=&quot;error&quot;)&#10;&#10;        user_in.password = hash_password(user_in.password)&#10;        new_user = crud_user.create(db=db, obj_in=user_in)&#10;&#10;        # Create verification token&#10;        verification_record = create_verification_token(&#10;            db=db,&#10;            entity_id=new_user.id,&#10;            verification_type=VerificationType.EMAIL,&#10;            entity_type=&quot;user&quot;,&#10;            expires_in_hours=24&#10;        )&#10;&#10;        # Send verification email&#10;        user_name = f&quot;{new_user.first_name} {new_user.last_name}&quot;&#10;        email_sent = email_service.send_verification_email(&#10;            to_email=new_user.email,&#10;            verification_token=verification_record.token,&#10;            user_name=user_name&#10;        )&#10;&#10;        if not email_sent:&#10;            print(f&quot;Warning: Failed to send verification email to {new_user.email}&quot;)&#10;&#10;        response.status_code = status.HTTP_201_CREATED&#10;        return ResponseMessage(&#10;            message=&quot;User created successfully. Please check your email to verify your account.&quot;,&#10;            status=&quot;success&quot;&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.post(&quot;/auth/verify_email&quot;, response_model=DataResponse)&#10;async def verify_email(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    verification_in: VerificationRequest,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify user email with token.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        token = crud_user.get_verification_token(&#10;            db=db,&#10;            token=verification_in.token,&#10;            type=VerificationType.EMAIL&#10;        )&#10;&#10;        if not token:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_404_NOT_FOUND,&#10;                message=&quot;Verification token not found&quot;&#10;            )&#10;&#10;        if token.status != VerificationStatus.PENDING or token.expires_at &lt; datetime.now():&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                status_code=status.HTTP_400_BAD_REQUEST,&#10;                message=&quot;Token has expired or is invalid&quot;&#10;            )&#10;&#10;        result = crud_user.verify_token(db=db, db_obj=token)&#10;        if result:&#10;            return DataResponse.success_response(&#10;                message=&quot;Email verified successfully&quot;&#10;            )&#10;&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=&quot;Email verification failed&quot;,&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Verification process failed: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/login&quot;, response_model=DataResponse[TokenResponse])&#10;async def user_login(&#10;    login_data: LoginRequest,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Login professional using mobile number or email and return JWT tokens.&#10;    &quot;&quot;&quot;&#10;    # Try to get professional by mobile number first&#10;    user = crud_user.get_by_email(db, email=login_data.email)&#10;&#10;    if not user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;&#10;    # Verify password&#10;    if not verify_password(login_data.password, user.password):&#10;        raise HTTPException(&#10;            status_code=status.HTTP_401_UNAUTHORIZED,&#10;            detail=&quot;Invalid credentials&quot;&#10;        )&#10;    company = crud_user.get_company_by_user(db, user.id)&#10;    # Create token pair&#10;    tokens = create_token_pair(user.id, user.email, actor=&quot;user&quot;, ver=&quot;1&quot;, company_id=str(company.company_id) if company else '')&#10;    response.set_cookie(&#10;        key=&quot;refresh_token&quot;,&#10;        value=tokens[&quot;refresh_token&quot;],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;none&quot;&#10;    )&#10;    response.set_cookie(&#10;        key=&quot;access_token&quot;,&#10;        value=tokens[&quot;access_token&quot;],&#10;        max_age=tokens['expires_in'],&#10;        httponly=True,&#10;        secure=True,  # only over HTTPS&#10;        samesite=&quot;none&quot;&#10;    )&#10;&#10;    print(tokens)&#10;    return DataResponse.success_response(data = TokenResponse(**tokens))&#10;&#10;&#10;@router.put(&quot;/auth/logout&quot;)&#10;async def logout_user(response: Response):&#10;    &quot;&quot;&quot;&#10;    Logout professional by clearing the refresh token cookie&#10;    &quot;&quot;&quot;&#10;    try:&#10;        response.delete_cookie(key=&quot;refresh_token&quot;)&#10;        response.delete_cookie(key=&quot;access_token&quot;)&#10;        return ResponseMessage(message=&quot;Logged out successfully&quot;, status=&quot;success&quot;)&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return ResponseMessage(message=f&quot;Internal server error: {str(e)}&quot;, status=&quot;error&quot;)&#10;&#10;&#10;@router.get(&quot;/me&quot;, response_model=DataResponse)&#10;async def get_current_user(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get current logged-in user. Returns CompanyUser if user belongs to a company, otherwise returns User.&#10;    &quot;&quot;&quot;&#10;    # Check if user belongs to a company&#10;    if current_user.company_id:&#10;        try:&#10;            # Get company user details&#10;            company_user = crud_company.get_company_user(&#10;                db=db, &#10;                user_id=str(current_user.id), &#10;                company_id=str(current_user.company_id)&#10;            )&#10;            if company_user:&#10;                return DataResponse.success_response(data=company_user)&#10;        except Exception as e:&#10;            print(f&quot;Error fetching company user: {str(e)}&quot;)&#10;            # Fall through to return basic user if company user fetch fails&#10;    &#10;    # Return basic user if no company association&#10;    return DataResponse.success_response(data=current_user)&#10;&#10;&#10;@router.post(&quot;/time-offs&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_201_CREATED)&#10;async def create_time_off(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffCreate,&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Create a new time off period for the current user.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=time_off_in.user_id,&#10;            start_date=time_off_in.start_date,&#10;            end_date=time_off_in.end_date&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Create the time off&#10;        time_off = crud_time_off.create(&#10;            db=db,&#10;            obj_in=time_off_in,&#10;            company_id=company_id&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off created successfully&quot;,&#10;            data=time_off,&#10;            status_code=status.HTTP_201_CREATED&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to create time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.get(&quot;/time-offs&quot;, response_model=DataResponse[List[TimeOff]], status_code=status.HTTP_200_OK)&#10;async def get_all_user_time_offs(&#10;    *,&#10;    db: Session = Depends(get_db),&#10;    start_date: datetime = Query(datetime.today(), description=&quot;Filter time offs that end after this date&quot;),&#10;    availability_type: AvailabilityType = Query(AvailabilityType.WEEKLY, description=&quot;Type of availability check: daily, weekly, or monthly&quot;),&#10;    response: Response,&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Get all time offs for the current user with optional date filtering.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        end_date = start_date + timedelta(&#10;                days=1 if availability_type == AvailabilityType.DAILY else&#10;                     7 if availability_type == AvailabilityType.WEEKLY else 31&#10;            )&#10;        time_offs = crud_time_off.get_user_time_offs(&#10;            db=db,&#10;            company_id=company_id,&#10;            start_date=start_date,&#10;            end_date=end_date&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            data=time_offs,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to retrieve time offs: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.put(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse[TimeOff], status_code=status.HTTP_200_OK)&#10;async def update_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    time_off_in: TimeOffUpdate,&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Update an existing time off period.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the time off by ID&#10;        time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;        if not time_off:&#10;            response.status_code = status.HTTP_404_NOT_FOUND&#10;            return DataResponse.error_response(&#10;                message=&quot;Time off not found&quot;,&#10;                status_code=status.HTTP_404_NOT_FOUND&#10;            )&#10;&#10;        # Check if the time off belongs to the current user&#10;        if str(time_off.user_id) != str(current_user.id):&#10;            response.status_code = status.HTTP_403_FORBIDDEN&#10;            return DataResponse.error_response(&#10;                message=&quot;You don't have permission to update this time off&quot;,&#10;                status_code=status.HTTP_403_FORBIDDEN&#10;            )&#10;&#10;        # Determine the new start and end dates for overlap check&#10;        start_date = time_off_in.start_date if time_off_in.start_date is not None else time_off.start_date&#10;        end_date = time_off_in.end_date if time_off_in.end_date is not None else time_off.end_date&#10;&#10;        # Check for overlapping time offs&#10;        has_overlap = crud_time_off.check_overlapping_time_offs(&#10;            db=db,&#10;            user_id=current_user.id,&#10;            start_date=start_date,&#10;            end_date=end_date,&#10;            exclude_id=time_off_id&#10;        )&#10;&#10;        if has_overlap:&#10;            response.status_code = status.HTTP_400_BAD_REQUEST&#10;            return DataResponse.error_response(&#10;                message=&quot;The updated time off period overlaps with existing ones&quot;,&#10;                status_code=status.HTTP_400_BAD_REQUEST&#10;            )&#10;&#10;        # Update the time off&#10;        updated_time_off = crud_time_off.update(&#10;            db=db,&#10;            db_obj=time_off,&#10;            obj_in=time_off_in&#10;        )&#10;&#10;        return DataResponse.success_response(&#10;            message=&quot;Time off updated successfully&quot;,&#10;            data=updated_time_off,&#10;            status_code=status.HTTP_200_OK&#10;        )&#10;    except ValueError as e:&#10;        response.status_code = status.HTTP_400_BAD_REQUEST&#10;        return DataResponse.error_response(&#10;            message=str(e),&#10;            status_code=status.HTTP_400_BAD_REQUEST&#10;        )&#10;    except Exception as e:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=f&quot;Failed to update time off: {str(e)}&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;&#10;@router.delete(&quot;/time-offs/{time_off_id}&quot;, response_model=DataResponse, status_code=status.HTTP_200_OK)&#10;async def delete_time_off(&#10;    *,&#10;    time_off_id: str,&#10;    db: Session = Depends(get_db),&#10;    response: Response,&#10;    current_user: User = Depends(get_current_active_user)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Delete a time off period.&#10;    &quot;&quot;&quot;&#10;    # Get the time off by ID&#10;    time_off = crud_time_off.get(db=db, time_off_id=time_off_id)&#10;    if not time_off:&#10;        response.status_code = status.HTTP_404_NOT_FOUND&#10;        return DataResponse.error_response(&#10;            message=&quot;Time off not found&quot;,&#10;            status_code=status.HTTP_404_NOT_FOUND&#10;        )&#10;&#10;    # Check if the time off belongs to the current user&#10;    if str(time_off.user_id) != str(current_user.id):&#10;        response.status_code = status.HTTP_403_FORBIDDEN&#10;        return DataResponse.error_response(&#10;            message=&quot;You don't have permission to delete this time off&quot;,&#10;            status_code=status.HTTP_403_FORBIDDEN&#10;        )&#10;&#10;    # Delete the time off&#10;    deleted = crud_time_off.delete(db=db, time_off_id=time_off_id)&#10;    if not deleted:&#10;        response.status_code = status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        return DataResponse.error_response(&#10;            message=&quot;Failed to delete time off&quot;,&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR&#10;        )&#10;&#10;    return DataResponse.success_response(&#10;        message=&quot;Time off deleted successfully&quot;,&#10;        status_code=status.HTTP_200_OK&#10;    )&#10;&#10;&#10;@router.post(&quot;/auth/refresh-token&quot;, response_model=DataResponse[TokenResponse])&#10;async def refresh_token(&#10;    request: Request,&#10;    response: Response,&#10;    db: Session = Depends(get_db)&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Refresh access and refresh tokens using the refresh token cookie.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the refresh token from the request cookies&#10;        refresh_token = request.cookies.get(&quot;refresh_token&quot;)&#10;        if not refresh_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Refresh token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the refresh token&#10;        payload = verify_token(refresh_token, &quot;refresh&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid refresh token&quot;&#10;            )&#10;&#10;        # Extract user data from payload&#10;        user_id = payload.get(&quot;sub&quot;)&#10;        email = payload.get(&quot;email&quot;)&#10;        company_id = payload.get(&quot;company_id&quot;)&#10;&#10;        if not user_id or not email:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid token payload&quot;&#10;            )&#10;&#10;        # Create new tokens&#10;        new_tokens = create_token_pair(&#10;            id=int(user_id),&#10;            email=email,&#10;            actor=&quot;user&quot;,&#10;            ver=&quot;1&quot;,&#10;            company_id=company_id&#10;        )&#10;&#10;        # Set new cookies&#10;        response.set_cookie(&#10;            key=&quot;refresh_token&quot;,&#10;            value=new_tokens[&quot;refresh_token&quot;],&#10;            httponly=True,&#10;            secure=True,&#10;            samesite=&quot;strict&quot;&#10;        )&#10;        response.set_cookie(&#10;            key=&quot;access_token&quot;,&#10;            value=new_tokens[&quot;access_token&quot;],&#10;            max_age=new_tokens['expires_in'],&#10;            httponly=True,&#10;            secure=True,&#10;            samesite=&quot;strict&quot;&#10;        )&#10;&#10;        return DataResponse.success_response(data=TokenResponse(**new_tokens))&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to refresh token: {str(e)}&quot;&#10;        )&#10;&#10;&#10;@router.post(&quot;/auth/verify-token&quot;, response_model=DataResponse[dict])&#10;async def verify_access_token(&#10;    request: Request,&#10;    response: Response&#10;) -&gt; DataResponse:&#10;    &quot;&quot;&quot;&#10;    Verify the access token and return the token data.&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Get the access token from the request cookies&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Access token not found&quot;&#10;            )&#10;&#10;        # Verify and decode the access token&#10;        payload = verify_token(access_token, &quot;access&quot;)&#10;        if payload is None:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_401_UNAUTHORIZED,&#10;                detail=&quot;Invalid or expired access token&quot;&#10;            )&#10;&#10;        # Return token validity info&#10;        return DataResponse.success_response(data={&#10;            &quot;valid&quot;: True,&#10;            &quot;user_id&quot;: payload.get(&quot;sub&quot;),&#10;            &quot;email&quot;: payload.get(&quot;email&quot;),&#10;            &quot;company_id&quot;: payload.get(&quot;company_id&quot;),&#10;            &quot;expires_at&quot;: payload.get(&quot;exp&quot;)&#10;        })&#10;&#10;    except HTTPException as e:&#10;        raise e&#10;    except Exception as e:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,&#10;            detail=f&quot;Failed to verify token: {str(e)}&quot;&#10;        )" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/booking.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/booking.py" />
              <option name="originalContent" value="from datetime import timedelta&#10;from typing import List, Optional, Any&#10;from datetime import date&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import BookingServices, Customers&#10;from app.models.models import Bookings&#10;from app.models.enums import BookingStatus&#10;from app.schemas import BookingServiceRequest&#10;from app.schemas.schemas import BookingCreate, BookingUpdate&#10;from app.services.crud import service&#10;from app.core.redis_client import publish_event&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Bookings]:&#10;    return db.query(Bookings).filter(Bookings.id == id).first()&#10;&#10;&#10;def get_all(db: Session, skip: int = 0, limit: int = 100) -&gt; list[type[Bookings]]:&#10;    return list(db.query(Bookings).offset(skip).limit(limit).all())&#10;&#10;def get_user_bookings_in_range(db: Session, user_id: str, start_date: Any, end_date: Any) -&gt; list[&quot;Bookings&quot;]:&#10;    return list(db.query(Bookings).join(BookingServices).filter(&#10;        BookingServices.user_id == user_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all())&#10;&#10;def get_all_bookings_in_range(db: Session, start_date: date, end_date: date):&#10;    # Join Bookings and BookingServices, return tuples of (booking, user_id)&#10;    return db.query(Bookings, BookingServices.user_id).join(BookingServices, Bookings.id == BookingServices.booking_id).filter(&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all()&#10;&#10;&#10;def get_all_bookings_in_range_by_company(db: Session, company_id: str, start_date: date, end_date: date):&#10;    return (db.query(Bookings).join(BookingServices, Bookings.id == BookingServices.booking_id)&#10;          .filter(&#10;        Bookings.company_id == company_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date,&#10;        Bookings.status.in_(['scheduled', 'confirmed', 'completed'])&#10;    ).all())&#10;&#10;def calc_service_params(db, services: List[BookingServiceRequest], company_id: str = None) -&gt; tuple[int, int]:&#10;    total_duration = 0&#10;    total_price = 0&#10;&#10;    for srv in services:&#10;        selected_srv = service.get_service(db, srv.category_service_id, company_id)&#10;        total_duration += selected_srv.duration&#10;        total_price += int(selected_srv.price)&#10;&#10;    return total_duration, total_price&#10;&#10;&#10;def create(db: Session, *, obj_in: BookingCreate, customer_id: UUID4) -&gt; Bookings:&#10;    total_duration, total_price = calc_service_params(db, obj_in.services, obj_in.company_id)&#10;    db_obj = Bookings(&#10;        customer_id=customer_id,&#10;        company_id=obj_in.company_id,&#10;        start_at=obj_in.start_time,&#10;        end_at= obj_in.start_time + timedelta(minutes=total_duration),&#10;        total_price=total_price,&#10;        notes=obj_in.notes&#10;    )&#10;    db.add(db_obj)&#10;    db.commit()&#10;&#10;    start_time = obj_in.start_time&#10;    for srv in obj_in.services:&#10;        duration, _ = calc_service_params(db, [srv], obj_in.company_id)&#10;        db_service_obj = BookingServices(&#10;            booking_id=db_obj.id,&#10;            category_service_id=srv.category_service_id,&#10;            user_id=srv.user_id,&#10;            notes=srv.notes,&#10;            start_at=start_time,&#10;            end_at=start_time + timedelta(minutes=duration)&#10;        )&#10;        start_time = db_service_obj.end_at&#10;        db.add(db_service_obj)&#10;&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    # Publish booking created event&#10;    publish_event(&quot;booking_created&quot;, str(db_obj.id))&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Bookings, obj_in: BookingUpdate) -&gt; Bookings:&#10;    &quot;&quot;&quot;&#10;    Update a booking and its associated services.&#10;    &quot;&quot;&quot;&#10;    # Update basic booking fields&#10;    if obj_in.start_time is not None:&#10;        db_obj.start_at = obj_in.start_time&#10;    if obj_in.notes is not None:&#10;        db_obj.notes = obj_in.notes&#10;    if obj_in.status is not None:&#10;        db_obj.status = obj_in.status&#10;&#10;    # If services are being updated, we need to recalculate everything&#10;    if obj_in.services is not None:&#10;        # Remove existing booking services&#10;        db.query(BookingServices).filter(BookingServices.booking_id == db_obj.id).delete()&#10;&#10;        # Recalculate total duration and price&#10;        total_duration, total_price = calc_service_params(db, obj_in.services, str(db_obj.company_id))&#10;        db_obj.total_price = total_price&#10;&#10;        # Update end time based on new start time and duration&#10;        start_time = obj_in.start_time if obj_in.start_time is not None else db_obj.start_at&#10;        db_obj.end_at = start_time + timedelta(minutes=total_duration)&#10;&#10;        # Create new booking services&#10;        current_start_time = start_time&#10;        for srv in obj_in.services:&#10;            duration, _ = calc_service_params(db, [srv], str(db_obj.company_id))&#10;            db_service_obj = BookingServices(&#10;                booking_id=db_obj.id,&#10;                category_service_id=srv.category_service_id,&#10;                user_id=srv.user_id,&#10;                notes=srv.notes,&#10;                start_at=current_start_time,&#10;                end_at=current_start_time + timedelta(minutes=duration)&#10;            )&#10;            current_start_time = db_service_obj.end_at&#10;            db.add(db_service_obj)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def cancel(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by setting its status to CANCELLED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CANCELLED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None&#10;&#10;&#10;def confirm(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CONFIRMED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None&#10;" />
              <option name="updatedContent" value="from datetime import timedelta&#10;from typing import List, Optional, Any&#10;from datetime import date&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import BookingServices, Customers&#10;from app.models.models import Bookings&#10;from app.models.enums import BookingStatus&#10;from app.schemas import BookingServiceRequest&#10;from app.schemas.schemas import BookingCreate, BookingUpdate&#10;from app.services.crud import service&#10;from app.core.redis_client import publish_event&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Bookings]:&#10;    return db.query(Bookings).filter(Bookings.id == id).first()&#10;&#10;&#10;def get_all(db: Session, skip: int = 0, limit: int = 100) -&gt; list[type[Bookings]]:&#10;    return list(db.query(Bookings).offset(skip).limit(limit).all())&#10;&#10;def get_user_bookings_in_range(db: Session, user_id: str, start_date: Any, end_date: Any) -&gt; list[&quot;Bookings&quot;]:&#10;    return list(db.query(Bookings).join(BookingServices).filter(&#10;        BookingServices.user_id == user_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all())&#10;&#10;def get_all_bookings_in_range(db: Session, start_date: date, end_date: date):&#10;    # Join Bookings and BookingServices, return tuples of (booking, user_id)&#10;    return db.query(Bookings, BookingServices.user_id).join(BookingServices, Bookings.id == BookingServices.booking_id).filter(&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date&#10;    ).all()&#10;&#10;&#10;def get_all_bookings_in_range_by_company(db: Session, company_id: str, start_date: date, end_date: date):&#10;    return (db.query(Bookings).join(BookingServices, Bookings.id == BookingServices.booking_id)&#10;          .filter(&#10;        Bookings.company_id == company_id,&#10;        Bookings.start_at &gt;= start_date,&#10;        Bookings.end_at &lt;= end_date,&#10;        Bookings.status.in_(['scheduled', 'confirmed', 'completed'])&#10;    ).all())&#10;&#10;def calc_service_params(db, services: List[BookingServiceRequest], company_id: str = None) -&gt; tuple[int, int]:&#10;    total_duration = 0&#10;    total_price = 0&#10;&#10;    for srv in services:&#10;        selected_srv = service.get_service(db, srv.category_service_id, company_id)&#10;        total_duration += selected_srv.duration&#10;        total_price += int(selected_srv.price)&#10;&#10;    return total_duration, total_price&#10;&#10;&#10;def create(db: Session, *, obj_in: BookingCreate, customer_id: UUID4) -&gt; Bookings:&#10;    total_duration, total_price = calc_service_params(db, obj_in.services, obj_in.company_id)&#10;    db_obj = Bookings(&#10;        customer_id=customer_id,&#10;        company_id=obj_in.company_id,&#10;        start_at=obj_in.start_time,&#10;        end_at= obj_in.start_time + timedelta(minutes=total_duration),&#10;        total_price=total_price,&#10;        notes=obj_in.notes&#10;    )&#10;    db.add(db_obj)&#10;    db.commit()&#10;&#10;    start_time = obj_in.start_time&#10;    for srv in obj_in.services:&#10;        duration, _ = calc_service_params(db, [srv], obj_in.company_id)&#10;        db_service_obj = BookingServices(&#10;            booking_id=db_obj.id,&#10;            category_service_id=srv.category_service_id,&#10;            user_id=srv.user_id,&#10;            notes=srv.notes,&#10;            start_at=start_time,&#10;            end_at=start_time + timedelta(minutes=duration)&#10;        )&#10;        start_time = db_service_obj.end_at&#10;        db.add(db_service_obj)&#10;&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    # Publish booking created event&#10;    publish_event(&quot;booking_created&quot;, str(db_obj.id))&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Bookings, obj_in: BookingUpdate) -&gt; Bookings:&#10;    &quot;&quot;&quot;&#10;    Update a booking and its associated services.&#10;    &quot;&quot;&quot;&#10;    # Update basic booking fields&#10;    if obj_in.start_time is not None:&#10;        db_obj.start_at = obj_in.start_time&#10;    if obj_in.notes is not None:&#10;        db_obj.notes = obj_in.notes&#10;    if obj_in.status is not None:&#10;        db_obj.status = obj_in.status&#10;&#10;    # If services are being updated, we need to recalculate everything&#10;    if obj_in.services is not None:&#10;        # Remove existing booking services&#10;        db.query(BookingServices).filter(BookingServices.booking_id == db_obj.id).delete()&#10;&#10;        # Recalculate total duration and price&#10;        total_duration, total_price = calc_service_params(db, obj_in.services, str(db_obj.company_id))&#10;        db_obj.total_price = total_price&#10;&#10;        # Update end time based on new start time and duration&#10;        start_time = obj_in.start_time if obj_in.start_time is not None else db_obj.start_at&#10;        db_obj.end_at = start_time + timedelta(minutes=total_duration)&#10;&#10;        # Create new booking services&#10;        current_start_time = start_time&#10;        for srv in obj_in.services:&#10;            duration, _ = calc_service_params(db, [srv], str(db_obj.company_id))&#10;            db_service_obj = BookingServices(&#10;                booking_id=db_obj.id,&#10;                category_service_id=srv.category_service_id,&#10;                user_id=srv.user_id,&#10;                notes=srv.notes,&#10;                start_at=current_start_time,&#10;                end_at=current_start_time + timedelta(minutes=duration)&#10;            )&#10;            current_start_time = db_service_obj.end_at&#10;            db.add(db_service_obj)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def cancel(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Cancel a booking by setting its status to CANCELLED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CANCELLED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None&#10;&#10;&#10;def confirm(db: Session, *, booking_id: UUID4) -&gt; Optional[Bookings]:&#10;    &quot;&quot;&quot;&#10;    Confirm a booking by setting its status to CONFIRMED.&#10;    Returns the updated booking or None if booking not found.&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(Bookings).filter(Bookings.id == booking_id).first()&#10;    if db_obj:&#10;        db_obj.status = BookingStatus.CONFIRMED&#10;        db.add(db_obj)&#10;        db.flush()  # Flush to get the updated object but don't commit yet&#10;        return db_obj&#10;    return None" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/company.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/company.py" />
              <option name="originalContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import date&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyRoleType, StatusType, UserAvailabilities, UserTimeOffs, CategoryServices, \&#10;    CompanyCategories, CompanyEmails, CompanyPhones, Users&#10;from app.models.models import CompanyUsers, Companies&#10;from app.schemas import CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, UserCreate, CompanyUser&#10;from app.schemas.schemas import (&#10;    CompanyCreate,&#10;    User&#10;)&#10;from app.services.auth import hash_password&#10;&#10;&#10;def get(db: Session, id: str) -&gt; Optional[Companies]:&#10;    return db.query(Companies).filter(Companies.id == id).first()&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUsers]:&#10;    &quot;&quot;&quot;Get all users belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyUsers).filter(CompanyUsers.company_id == company_id).all())&#10;&#10;&#10;def get_company_user(db: Session, company_id: str, user_id: str) -&gt; Optional[CompanyUser]:&#10;    &quot;&quot;&quot;Get company user with user details.&quot;&quot;&quot;&#10;    company_user = (db.query(CompanyUsers)&#10;                    .join(Users, Users.id == CompanyUsers.user_id)&#10;                    .filter(CompanyUsers.company_id == company_id, CompanyUsers.user_id == user_id)&#10;                    .first())&#10;    &#10;    if not company_user:&#10;        return None&#10;    &#10;    # Convert SQLAlchemy model to Pydantic schema&#10;    return CompanyUser.model_validate(company_user)&#10;&#10;&#10;def get_company_services(db: Session, company_id: str) -&gt; List[CompanyCategories]:&#10;    &quot;&quot;&quot;Get all services belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyCategories).join(CategoryServices, CategoryServices.category_id==CompanyCategories.id)&#10;                .filter(CompanyCategories.company_id == company_id).all())&#10;&#10;&#10;def get_company_all_users_availabilities(db: Session, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_user_availabilities(db: Session, user_id: str, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_all_users_time_offs(db: Session, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def get_company_user_time_offs(db: Session, user_id: str, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def create(db: Session, *, obj_in: CompanyCreate, current_user: User) -&gt; Companies:&#10;&#10;    db_obj = Companies(**obj_in.model_dump())&#10;    # db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    cmp_usr_obj = CompanyUsers(user_id=current_user.id,&#10;                               company_id=db_obj.id,&#10;                               role=CompanyRoleType.admin,&#10;                               status=StatusType.active)&#10;    db.add(cmp_usr_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Companies, obj_in: dict) -&gt; Companies:&#10;    &quot;&quot;&quot;&#10;    Update company information&#10;&#10;    Args:&#10;        db: Database session&#10;        db_obj: Existing company object to update&#10;        obj_in: Data to update the company with&#10;&#10;    Returns:&#10;        Updated company object&#10;    &quot;&quot;&quot;&#10;    for field, value in obj_in.items():&#10;        if value is not None:&#10;            setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def create_company_email(db: Session, *, obj_in: CompanyEmailCreate):&#10;    &quot;&quot;&quot;&#10;    Create new emails for a company, handling duplicate emails&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company emails to add&#10;&#10;    Returns:&#10;        List of created/updated email objects&#10;    &quot;&quot;&quot;&#10;    # Get existing emails for this company to check duplicates&#10;    existing_emails = db.query(CompanyEmails).filter(&#10;        CompanyEmails.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing email addresses for efficient lookup&#10;    existing_email_set = {str(email.email).lower() for email in existing_emails}&#10;&#10;    for email in obj_in.emails:&#10;        # Check if this email already exists for this company&#10;        if str(email.email).lower() in existing_email_set:&#10;            # Skip this email as it already exists&#10;            continue&#10;&#10;        # Create new email record&#10;        db_obj = CompanyEmails(&#10;            company_id=obj_in.company_id,&#10;            email=str(email.email).lower(),&#10;            status=email.status.lower()&#10;        )&#10;        db_obj.id = str(uuid.uuid4())&#10;        db.add(db_obj)&#10;&#10;    # Commit all new emails at once&#10;    db.commit()&#10;&#10;&#10;def get_company_emails(db: Session, company_id: str) -&gt; List[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get all emails for a specific company&#10;    &quot;&quot;&quot;&#10;    company_emails = db.query(CompanyEmails).filter(CompanyEmails.company_id == company_id).all()&#10;&#10;    return company_emails&#10;&#10;&#10;&#10;def get_company_email(db: Session, email_id: str) -&gt; Optional[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company email by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyEmails).filter(CompanyEmails.id == email_id).first()&#10;&#10;&#10;def delete_company_email(db: Session, email_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company email&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyEmails).filter(&#10;        CompanyEmails.id == email_id,&#10;        CompanyEmails.company_id == company_id&#10;    ).first()&#10;&#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_phone(db: Session, *, obj_in: CompanyPhoneCreate) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Create new phone numbers for a company, handling duplicate phone numbers&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company phone numbers to add&#10;&#10;    Returns:&#10;        List of created phone number objects&#10;    &quot;&quot;&quot;&#10;    # Get existing phone numbers for this company to check duplicates&#10;    existing_phones = db.query(CompanyPhones).filter(&#10;        CompanyPhones.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing phone numbers for efficient lookup&#10;    existing_phone_set = {phone.phone for phone in existing_phones}&#10;&#10;    created_phones = []&#10;    for phone_data in obj_in.company_phones:&#10;        # Check if this phone number already exists for this company&#10;        if phone_data.phone in existing_phone_set:&#10;            # Skip this phone number as it already exists&#10;            continue&#10;&#10;        # Create new phone number record&#10;        db_obj = CompanyPhones(&#10;            company_id=obj_in.company_id,&#10;            phone=phone_data.phone,&#10;            is_primary=phone_data.is_primary,&#10;            status=phone_data.status&#10;        )&#10;        # db_obj.id = str(uuid.uuid4())&#10;        &#10;        db.add(db_obj)&#10;        created_phones.append(db_obj)&#10;        &#10;    # Commit all new phone numbers at once&#10;    db.commit()&#10;&#10;    # Refresh all newly created objects&#10;    for phone in created_phones:&#10;        db.refresh(phone)&#10;&#10;    return created_phones&#10;&#10;&#10;def get_company_phones(db: Session, company_id: str) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers for a specific company&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.company_id == company_id).all()&#10;&#10;&#10;def get_company_phone(db: Session, phone_id: str) -&gt; Optional[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company phone by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.id == phone_id).first()&#10;&#10;&#10;def delete_company_phone(db: Session, phone_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company phone number&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyPhones).filter(&#10;        CompanyPhones.id == phone_id,&#10;        CompanyPhones.company_id == company_id&#10;    ).first()&#10;    &#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_member(db: Session, *, user_in: UserCreate, company_id: str, role: CompanyRoleType) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to a company with the specified role.&#10;&#10;    Args:&#10;        db: Database session&#10;        user_in: User creation data&#10;        company_id: Company ID to add the user to&#10;        role: Role to assign to the user in the company&#10;&#10;    Returns:&#10;        CompanyUsers object with the user relationship&#10;    &quot;&quot;&quot;&#10;    # Check if user with this email already exists&#10;    existing_user = db.query(Users).filter(Users.email == user_in.email).first()&#10;&#10;    if existing_user:&#10;        # Check if user is already part of this company&#10;        existing_company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == company_id&#10;        ).first()&#10;&#10;        if existing_company_user:&#10;            raise ValueError(&quot;User is already a member of this company&quot;)&#10;&#10;        # Add existing user to the company&#10;        company_user = CompanyUsers(&#10;            user_id=existing_user.id,&#10;            company_id=company_id,&#10;            role=role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;        db.commit()&#10;        db.refresh(company_user)&#10;        return company_user&#10;&#10;    # Create new user&#10;    user_data = user_in.model_dump()&#10;    user_data['password'] = hash_password(user_data['password'])&#10;&#10;    new_user = Users(**user_data)&#10;    new_user.id = str(uuid.uuid4())&#10;    new_user.status = StatusType.active&#10;&#10;    db.add(new_user)&#10;    db.commit()&#10;    db.refresh(new_user)&#10;&#10;    # Add user to company&#10;    company_user = CompanyUsers(&#10;        user_id=new_user.id,&#10;        company_id=company_id,&#10;        role=role,&#10;        status=StatusType.active&#10;    )&#10;    db.add(company_user)&#10;    db.commit()&#10;    db.refresh(company_user)&#10;&#10;    return company_user&#10;" />
              <option name="updatedContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import date&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyRoleType, StatusType, UserAvailabilities, UserTimeOffs, CategoryServices, \&#10;    CompanyCategories, CompanyEmails, CompanyPhones, Users&#10;from app.models.models import CompanyUsers, Companies&#10;from app.schemas import CompanyEmailCreate, CompanyEmail, CompanyEmailBase, CompanyPhoneCreate, UserCreate, CompanyUser&#10;from app.schemas.schemas import (&#10;    CompanyCreate,&#10;    User&#10;)&#10;from app.services.auth import hash_password&#10;&#10;&#10;def get(db: Session, id: str) -&gt; Optional[Companies]:&#10;    return db.query(Companies).filter(Companies.id == id).first()&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUsers]:&#10;    &quot;&quot;&quot;Get all users belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyUsers).filter(CompanyUsers.company_id == company_id).all())&#10;&#10;&#10;def get_company_user(db: Session, company_id: str, user_id: str) -&gt; Optional[CompanyUser]:&#10;    &quot;&quot;&quot;Get company user with user details.&quot;&quot;&quot;&#10;    company_user = (db.query(CompanyUsers)&#10;                    .join(Users, Users.id == CompanyUsers.user_id)&#10;                    .filter(CompanyUsers.company_id == company_id, CompanyUsers.user_id == user_id)&#10;                    .first())&#10;    &#10;    if not company_user:&#10;        return None&#10;    &#10;    # Convert SQLAlchemy model to Pydantic schema&#10;    return CompanyUser.model_validate(company_user)&#10;&#10;&#10;def get_company_services(db: Session, company_id: str) -&gt; List[CompanyCategories]:&#10;    &quot;&quot;&quot;Get all services belonging to the given company.&quot;&quot;&quot;&#10;    return list(db.query(CompanyCategories).join(CategoryServices, CategoryServices.category_id==CompanyCategories.id)&#10;                .filter(CompanyCategories.company_id == company_id).all())&#10;&#10;&#10;def get_company_all_users_availabilities(db: Session, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_user_availabilities(db: Session, user_id: str, company_id: str) -&gt; List:&#10;    &quot;&quot;&quot;Get all availabilities for users belonging to the given company.&quot;&quot;&quot;&#10;    return (db.query(UserAvailabilities)&#10;     .join(CompanyUsers, UserAvailabilities.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserAvailabilities.is_available == True&#10;    ).all())&#10;&#10;&#10;def get_company_all_users_time_offs(db: Session, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def get_company_user_time_offs(db: Session, user_id: str, company_id: str, start_date: date, end_date: date) -&gt; List:&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return (db.query(UserTimeOffs, CompanyUsers.user_id)&#10;     .join(CompanyUsers, UserTimeOffs.user_id == CompanyUsers.user_id).filter(&#10;        CompanyUsers.company_id == company_id,&#10;        CompanyUsers.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all())&#10;&#10;&#10;def create(db: Session, *, obj_in: CompanyCreate, current_user: User) -&gt; Companies:&#10;&#10;    db_obj = Companies(**obj_in.model_dump())&#10;    # db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    cmp_usr_obj = CompanyUsers(user_id=current_user.id,&#10;                               company_id=db_obj.id,&#10;                               role=CompanyRoleType.admin,&#10;                               status=StatusType.active)&#10;    db.add(cmp_usr_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    return db_obj&#10;&#10;&#10;def update(db: Session, *, db_obj: Companies, obj_in: dict) -&gt; Companies:&#10;    &quot;&quot;&quot;&#10;    Update company information&#10;&#10;    Args:&#10;        db: Database session&#10;        db_obj: Existing company object to update&#10;        obj_in: Data to update the company with&#10;&#10;    Returns:&#10;        Updated company object&#10;    &quot;&quot;&quot;&#10;    for field, value in obj_in.items():&#10;        if value is not None:&#10;            setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def create_company_email(db: Session, *, obj_in: CompanyEmailCreate):&#10;    &quot;&quot;&quot;&#10;    Create new emails for a company, handling duplicate emails&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company emails to add&#10;&#10;    Returns:&#10;        List of created/updated email objects&#10;    &quot;&quot;&quot;&#10;    # Get existing emails for this company to check duplicates&#10;    existing_emails = db.query(CompanyEmails).filter(&#10;        CompanyEmails.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing email addresses for efficient lookup&#10;    existing_email_set = {str(email.email).lower() for email in existing_emails}&#10;&#10;    for email in obj_in.emails:&#10;        # Check if this email already exists for this company&#10;        if str(email.email).lower() in existing_email_set:&#10;            # Skip this email as it already exists&#10;            continue&#10;&#10;        # Create new email record&#10;        db_obj = CompanyEmails(&#10;            company_id=obj_in.company_id,&#10;            email=str(email.email).lower(),&#10;            status=email.status.lower()&#10;        )&#10;        db_obj.id = str(uuid.uuid4())&#10;        db.add(db_obj)&#10;&#10;    # Commit all new emails at once&#10;    db.commit()&#10;&#10;&#10;def get_company_emails(db: Session, company_id: str) -&gt; List[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get all emails for a specific company&#10;    &quot;&quot;&quot;&#10;    company_emails = db.query(CompanyEmails).filter(CompanyEmails.company_id == company_id).all()&#10;&#10;    return company_emails&#10;&#10;&#10;&#10;def get_company_email(db: Session, email_id: str) -&gt; Optional[CompanyEmails]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company email by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyEmails).filter(CompanyEmails.id == email_id).first()&#10;&#10;&#10;def delete_company_email(db: Session, email_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company email&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyEmails).filter(&#10;        CompanyEmails.id == email_id,&#10;        CompanyEmails.company_id == company_id&#10;    ).first()&#10;&#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_phone(db: Session, *, obj_in: CompanyPhoneCreate) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Create new phone numbers for a company, handling duplicate phone numbers&#10;&#10;    Args:&#10;        db: Database session&#10;        obj_in: Data with company phone numbers to add&#10;&#10;    Returns:&#10;        List of created phone number objects&#10;    &quot;&quot;&quot;&#10;    # Get existing phone numbers for this company to check duplicates&#10;    existing_phones = db.query(CompanyPhones).filter(&#10;        CompanyPhones.company_id == obj_in.company_id&#10;    ).all()&#10;&#10;    # Create a set of existing phone numbers for efficient lookup&#10;    existing_phone_set = {phone.phone for phone in existing_phones}&#10;&#10;    created_phones = []&#10;    for phone_data in obj_in.company_phones:&#10;        # Check if this phone number already exists for this company&#10;        if phone_data.phone in existing_phone_set:&#10;            # Skip this phone number as it already exists&#10;            continue&#10;&#10;        # Create new phone number record&#10;        db_obj = CompanyPhones(&#10;            company_id=obj_in.company_id,&#10;            phone=phone_data.phone,&#10;            is_primary=phone_data.is_primary,&#10;            status=phone_data.status&#10;        )&#10;        # db_obj.id = str(uuid.uuid4())&#10;        &#10;        db.add(db_obj)&#10;        created_phones.append(db_obj)&#10;        &#10;    # Commit all new phone numbers at once&#10;    db.commit()&#10;&#10;    # Refresh all newly created objects&#10;    for phone in created_phones:&#10;        db.refresh(phone)&#10;&#10;    return created_phones&#10;&#10;&#10;def get_company_phones(db: Session, company_id: str) -&gt; List[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get all phone numbers for a specific company&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.company_id == company_id).all()&#10;&#10;&#10;def get_company_phone(db: Session, phone_id: str) -&gt; Optional[CompanyPhones]:&#10;    &quot;&quot;&quot;&#10;    Get a specific company phone by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyPhones).filter(CompanyPhones.id == phone_id).first()&#10;&#10;&#10;def delete_company_phone(db: Session, phone_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company phone number&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyPhones).filter(&#10;        CompanyPhones.id == phone_id,&#10;        CompanyPhones.company_id == company_id&#10;    ).first()&#10;    &#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def create_company_member(db: Session, *, user_in: UserCreate, company_id: str, role: CompanyRoleType) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;&#10;    Create a new user and add them to a company with the specified role.&#10;&#10;    Args:&#10;        db: Database session&#10;        user_in: User creation data&#10;        company_id: Company ID to add the user to&#10;        role: Role to assign to the user in the company&#10;&#10;    Returns:&#10;        CompanyUsers object with the user relationship&#10;    &quot;&quot;&quot;&#10;    # Check if user with this email already exists&#10;    existing_user = db.query(Users).filter(Users.email == user_in.email).first()&#10;&#10;    if existing_user:&#10;        # Check if user is already part of this company&#10;        existing_company_user = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == existing_user.id,&#10;            CompanyUsers.company_id == company_id&#10;        ).first()&#10;&#10;        if existing_company_user:&#10;            raise ValueError(&quot;User is already a member of this company&quot;)&#10;&#10;        # Add existing user to the company&#10;        company_user = CompanyUsers(&#10;            user_id=existing_user.id,&#10;            company_id=company_id,&#10;            role=role,&#10;            status=StatusType.active&#10;        )&#10;        db.add(company_user)&#10;        db.commit()&#10;        db.refresh(company_user)&#10;        return company_user&#10;&#10;    # Create new user&#10;    user_data = user_in.model_dump()&#10;    user_data['password'] = hash_password(user_data['password'])&#10;&#10;    new_user = Users(**user_data)&#10;    new_user.id = str(uuid.uuid4())&#10;    new_user.status = StatusType.active&#10;&#10;    db.add(new_user)&#10;    db.commit()&#10;    db.refresh(new_user)&#10;&#10;    # Add user to company&#10;    company_user = CompanyUsers(&#10;        user_id=new_user.id,&#10;        company_id=company_id,&#10;        role=role,&#10;        status=StatusType.active&#10;    )&#10;    db.add(company_user)&#10;    db.commit()&#10;    db.refresh(company_user)&#10;&#10;    return company_user" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/user.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/user.py" />
              <option name="originalContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyUsers&#10;from app.models.models import Users, UserVerifications&#10;from app.models.enums import VerificationStatus&#10;from app.schemas import CompanyUser, User&#10;from app.schemas.schemas import (&#10;    UserCreate&#10;)&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Users]:&#10;    return db.query(Users, CompanyUsers.company_id).join(CompanyUsers, CompanyUsers.user_id == Users.id).filter(Users.id == id).first()&#10;&#10;&#10;def get_all(db: Session) -&gt; List[Users]:&#10;    return db.query(Users).all()&#10;&#10;&#10;def get_by_email(db: Session, email: str) -&gt; Optional[Users]:&#10;    return db.query(Users).filter(Users.email == email).first()&#10;&#10;&#10;def create(db: Session, *, obj_in: UserCreate) -&gt; Users:&#10;    db_obj = Users(**obj_in.model_dump())&#10;    db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def get_verification_token(db: Session, token: str, type: str) -&gt; Optional[UserVerifications]:&#10;    &quot;&quot;&quot;Get verification token by token string and type&quot;&quot;&quot;&#10;    return db.query(UserVerifications).filter(&#10;        UserVerifications.token == token,&#10;        UserVerifications.type == type&#10;    ).first()&#10;&#10;&#10;def verify_token(db: Session, db_obj: UserVerifications) -&gt; bool:&#10;    &quot;&quot;&quot;Mark verification token as verified and update user email_verified status&quot;&quot;&quot;&#10;    try:&#10;        db_obj.status = VerificationStatus.VERIFIED&#10;        db_obj.used_at = datetime.now()&#10;        &#10;        # Update user's email_verified status&#10;        user = db.query(Users).filter(Users.id == db_obj.user_id).first()&#10;        if user:&#10;            user.email_verified = True&#10;            db.add(user)&#10;        &#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return True&#10;    except Exception as e:&#10;        db.rollback()&#10;        print(f&quot;Error verifying token: {str(e)}&quot;)&#10;        return False&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUser]:&#10;    &quot;&quot;&quot;&#10;    Get all users for a company&#10;    &quot;&quot;&quot;&#10;    users = db.query(CompanyUsers).join(Users, Users.id == CompanyUsers.user_id).filter(&#10;        Users.status == 'active', CompanyUsers.company_id == company_id, CompanyUsers.status == 'active'&#10;    ).all()&#10;    # result = []&#10;    # for company_user, user in users:&#10;    #     result.append(CompanyUser(&#10;    #         user_id=company_user.user_id,&#10;    #         company_id=company_user.company_id,&#10;    #         role=company_user.role,&#10;    #         status=company_user.status,&#10;    #         user=User(&#10;    #             id=user.id,&#10;    #             first_name=user.first_name,&#10;    #             last_name=user.last_name,&#10;    #             email=user.email,&#10;    #             phone=user.phone,&#10;    #             status=user.status,&#10;    #             created_at=user.created_at,&#10;    #             updated_at=user.updated_at&#10;    #         )&#10;    #     ))&#10;    return users&#10;&#10;&#10;def get_company_by_user(db: Session, user_id: str) -&gt; Optional[CompanyUsers]:&#10;    return db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == user_id).first()" />
              <option name="updatedContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;&#10;from app.models import CompanyUsers&#10;from app.models.models import Users, UserVerifications&#10;from app.models.enums import VerificationStatus&#10;from app.schemas import CompanyUser, User&#10;from app.schemas.schemas import (&#10;    UserCreate&#10;)&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Users]:&#10;    return db.query(Users, CompanyUsers.company_id).join(CompanyUsers, CompanyUsers.user_id == Users.id).filter(Users.id == id).first()&#10;&#10;&#10;def get_all(db: Session) -&gt; List[Users]:&#10;    return db.query(Users).all()&#10;&#10;&#10;def get_by_email(db: Session, email: str) -&gt; Optional[Users]:&#10;    return db.query(Users).filter(Users.email == email).first()&#10;&#10;&#10;def create(db: Session, *, obj_in: UserCreate) -&gt; Users:&#10;    db_obj = Users(**obj_in.model_dump())&#10;    db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def get_verification_token(db: Session, token: str, type: str) -&gt; Optional[UserVerifications]:&#10;    &quot;&quot;&quot;Get verification token by token string and type&quot;&quot;&quot;&#10;    return db.query(UserVerifications).filter(&#10;        UserVerifications.token == token,&#10;        UserVerifications.type == type&#10;    ).first()&#10;&#10;&#10;def verify_token(db: Session, db_obj: UserVerifications) -&gt; bool:&#10;    &quot;&quot;&quot;Mark verification token as verified and update user email_verified status&quot;&quot;&quot;&#10;    try:&#10;        db_obj.status = VerificationStatus.VERIFIED&#10;        db_obj.used_at = datetime.now()&#10;        &#10;        # Update user's email_verified status&#10;        user = db.query(Users).filter(Users.id == db_obj.user_id).first()&#10;        if user:&#10;            user.email_verified = True&#10;            db.add(user)&#10;        &#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return True&#10;    except Exception as e:&#10;        db.rollback()&#10;        print(f&quot;Error verifying token: {str(e)}&quot;)&#10;        return False&#10;&#10;&#10;def get_company_users(db: Session, company_id: str) -&gt; List[CompanyUser]:&#10;    &quot;&quot;&quot;&#10;    Get all users for a company&#10;    &quot;&quot;&quot;&#10;    users = db.query(CompanyUsers).join(Users, Users.id == CompanyUsers.user_id).filter(&#10;        Users.status == 'active', CompanyUsers.company_id == company_id, CompanyUsers.status == 'active'&#10;    ).all()&#10;    # result = []&#10;    # for company_user, user in users:&#10;    #     result.append(CompanyUser(&#10;    #         user_id=company_user.user_id,&#10;    #         company_id=company_user.company_id,&#10;    #         role=company_user.role,&#10;    #         status=company_user.status,&#10;    #         user=User(&#10;    #             id=user.id,&#10;    #             first_name=user.first_name,&#10;    #             last_name=user.last_name,&#10;    #             email=user.email,&#10;    #             phone=user.phone,&#10;    #             status=user.status,&#10;    #             created_at=user.created_at,&#10;    #             updated_at=user.updated_at&#10;    #         )&#10;    #     ))&#10;    return users&#10;&#10;&#10;def get_company_by_user(db: Session, user_id: str) -&gt; Optional[CompanyUsers]:&#10;    return db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == user_id).first()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/email_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/email_service.py" />
              <option name="originalContent" value="import smtplib&#10;import uuid&#10;from email.mime.text import MIMEText&#10;from email.mime.multipart import MIMEMultipart&#10;from datetime import datetime, timedelta&#10;from typing import Optional, Union&#10;from sqlalchemy.orm import Session&#10;&#10;from app.core.config import settings&#10;from app.models.models import CustomerVerifications, UserVerifications&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;&#10;class EmailService:&#10;    &quot;&quot;&quot;Service for sending emails via SMTP - works for both users and customers&quot;&quot;&quot;&#10;    &#10;    def __init__(&#10;        self,&#10;        smtp_host: Optional[str] = None,&#10;        smtp_port: Optional[int] = None,&#10;        smtp_user: Optional[str] = None,&#10;        smtp_password: Optional[str] = None,&#10;        from_email: Optional[str] = None,&#10;        from_name: Optional[str] = None&#10;    ):&#10;        self.smtp_host = smtp_host or getattr(settings, 'SMTP_HOST', '')&#10;        self.smtp_port = smtp_port or getattr(settings, 'SMTP_PORT', 587)&#10;        self.smtp_user = smtp_user or getattr(settings, 'SMTP_USER', '')&#10;        self.smtp_password = smtp_password or getattr(settings, 'SMTP_PASSWORD', '')&#10;        self.from_email = from_email or getattr(settings, 'SMTP_FROM_EMAIL', self.smtp_user)&#10;        self.from_name = from_name or getattr(settings, 'SMTP_FROM_NAME', 'Salona')&#10;    &#10;    def _send_email(&#10;        self,&#10;        to_email: str,&#10;        subject: str,&#10;        html_content: str,&#10;        text_content: Optional[str] = None&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send an email via SMTP&#10;        &#10;        Args:&#10;            to_email: Recipient email address&#10;            subject: Email subject&#10;            html_content: HTML content of the email&#10;            text_content: Plain text fallback content&#10;            &#10;        Returns:&#10;            bool: True if email sent successfully, False otherwise&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Create message&#10;            msg = MIMEMultipart('alternative')&#10;            msg['Subject'] = subject&#10;            msg['From'] = f&quot;{self.from_name} &lt;{self.from_email}&gt;&quot;&#10;            msg['To'] = to_email&#10;            &#10;            # Add text and HTML parts&#10;            if text_content:&#10;                part1 = MIMEText(text_content, 'plain')&#10;                msg.attach(part1)&#10;            &#10;            part2 = MIMEText(html_content, 'html')&#10;            msg.attach(part2)&#10;            &#10;            # Send email&#10;            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:&#10;                server.starttls()&#10;                if self.smtp_user and self.smtp_password:&#10;                    server.login(self.smtp_user, self.smtp_password)&#10;                server.send_message(msg)&#10;            &#10;            return True&#10;        except Exception as e:&#10;            print(f&quot;Error sending email: {str(e)}&quot;)&#10;            return False&#10;    &#10;    def send_verification_email(&#10;        self,&#10;        to_email: str,&#10;        verification_token: str,&#10;        user_name: str&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send email verification email (works for both users and customers)&#10;        &#10;        Args:&#10;            to_email: Email address&#10;            verification_token: Verification token&#10;            user_name: User's name&#10;            &#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        verification_url = f&quot;{settings.FRONTEND_URL}/verify-email?token={verification_token}&quot;&#10;        &#10;        subject = &quot;Verify Your Email Address - Salona&quot;&#10;        &#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Welcome to Salona!&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {user_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;Thank you for signing up! To complete your registration, please verify your email address by clicking the button below:&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{verification_url}&quot; &#10;                       style=&quot;background-color: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        Verify Email Address&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                    {verification_url}&#10;                &lt;/p&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                    This verification link will expire in 24 hours. If you didn't create an account with Salona, please ignore this email.&#10;                &lt;/p&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;        &#10;        text_content = f&quot;&quot;&quot;&#10;        Welcome to Salona!&#10;        &#10;        Hi {user_name},&#10;        &#10;        Thank you for signing up! To complete your registration, please verify your email address by clicking the link below:&#10;        &#10;        {verification_url}&#10;        &#10;        This verification link will expire in 24 hours. If you didn't create an account with Salona, please ignore this email.&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;        &#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;    &#10;    def send_password_reset_email(&#10;        self,&#10;        to_email: str,&#10;        reset_token: str,&#10;        user_name: str&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send password reset email (works for both users and customers)&#10;        &#10;        Args:&#10;            to_email: Email address&#10;            reset_token: Password reset token&#10;            user_name: User's name&#10;            &#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        reset_url = f&quot;{settings.FRONTEND_URL}/reset-password?token={reset_token}&quot;&#10;        &#10;        subject = &quot;Reset Your Password - Salona&quot;&#10;        &#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Password Reset Request&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {user_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;We received a request to reset your password. Click the button below to create a new password:&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{reset_url}&quot; &#10;                       style=&quot;background-color: #dc3545; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        Reset Password&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                    {reset_url}&#10;                &lt;/p&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                    This password reset link will expire in 1 hour. If you didn't request a password reset, please ignore this email or contact support if you have concerns.&#10;                &lt;/p&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;        &#10;        text_content = f&quot;&quot;&quot;&#10;        Password Reset Request&#10;        &#10;        Hi {user_name},&#10;        &#10;        We received a request to reset your password. Click the link below to create a new password:&#10;        &#10;        {reset_url}&#10;        &#10;        This password reset link will expire in 1 hour. If you didn't request a password reset, please ignore this email.&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;        &#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;&#10;&#10;def create_verification_token(&#10;    db: Session,&#10;    entity_id: str,&#10;    verification_type: VerificationType,&#10;    entity_type: str = &quot;user&quot;,&#10;    expires_in_hours: int = 24&#10;) -&gt; Union[UserVerifications, CustomerVerifications]:&#10;    &quot;&quot;&quot;&#10;    Create a verification token for a user or customer&#10;    &#10;    Args:&#10;        db: Database session&#10;        entity_id: User or Customer ID&#10;        verification_type: Type of verification (email, phone, etc.)&#10;        entity_type: Either &quot;user&quot; or &quot;customer&quot;&#10;        expires_in_hours: Hours until token expires&#10;        &#10;    Returns:&#10;        UserVerifications or CustomerVerifications: The created verification record&#10;    &quot;&quot;&quot;&#10;    token = str(uuid.uuid4())&#10;    expires_at = datetime.now() + timedelta(hours=expires_in_hours)&#10;    &#10;    if entity_type == &quot;user&quot;:&#10;        db_obj = UserVerifications(&#10;            id=uuid.uuid4(),&#10;            user_id=entity_id,&#10;            token=token,&#10;            type=verification_type,&#10;            status=VerificationStatus.PENDING,&#10;            expires_at=expires_at&#10;        )&#10;    else:  # customer&#10;        db_obj = CustomerVerifications(&#10;            id=uuid.uuid4(),&#10;            customer_id=entity_id,&#10;            token=token,&#10;            type=verification_type,&#10;            status=VerificationStatus.PENDING,&#10;            expires_at=expires_at&#10;        )&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    &#10;    return db_obj&#10;&#10;&#10;# Singleton instance&#10;email_service = EmailService()&#10;" />
              <option name="updatedContent" value="import smtplib&#10;import uuid&#10;from email.mime.text import MIMEText&#10;from email.mime.multipart import MIMEMultipart&#10;from datetime import datetime, timedelta&#10;from typing import Optional, Union&#10;from sqlalchemy.orm import Session&#10;&#10;from app.core.config import settings&#10;from app.models.models import CustomerVerifications, UserVerifications&#10;from app.models.enums import VerificationType, VerificationStatus&#10;&#10;&#10;class EmailService:&#10;    &quot;&quot;&quot;Service for sending emails via SMTP - works for both users and customers&quot;&quot;&quot;&#10;    &#10;    def __init__(&#10;        self,&#10;        smtp_host: Optional[str] = None,&#10;        smtp_port: Optional[int] = None,&#10;        smtp_user: Optional[str] = None,&#10;        smtp_password: Optional[str] = None,&#10;        from_email: Optional[str] = None,&#10;        from_name: Optional[str] = None&#10;    ):&#10;        self.smtp_host = smtp_host or getattr(settings, 'SMTP_HOST', '')&#10;        self.smtp_port = smtp_port or getattr(settings, 'SMTP_PORT', 587)&#10;        self.smtp_user = smtp_user or getattr(settings, 'SMTP_USER', '')&#10;        self.smtp_password = smtp_password or getattr(settings, 'SMTP_PASSWORD', '')&#10;        self.from_email = from_email or getattr(settings, 'SMTP_FROM_EMAIL', self.smtp_user)&#10;        self.from_name = from_name or getattr(settings, 'SMTP_FROM_NAME', 'Salona')&#10;    &#10;    def _send_email(&#10;        self,&#10;        to_email: str,&#10;        subject: str,&#10;        html_content: str,&#10;        text_content: Optional[str] = None&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send an email via SMTP&#10;        &#10;        Args:&#10;            to_email: Recipient email address&#10;            subject: Email subject&#10;            html_content: HTML content of the email&#10;            text_content: Plain text fallback content&#10;            &#10;        Returns:&#10;            bool: True if email sent successfully, False otherwise&#10;        &quot;&quot;&quot;&#10;        try:&#10;            # Create message&#10;            msg = MIMEMultipart('alternative')&#10;            msg['Subject'] = subject&#10;            msg['From'] = f&quot;{self.from_name} &lt;{self.from_email}&gt;&quot;&#10;            msg['To'] = to_email&#10;            &#10;            # Add text and HTML parts&#10;            if text_content:&#10;                part1 = MIMEText(text_content, 'plain')&#10;                msg.attach(part1)&#10;            &#10;            part2 = MIMEText(html_content, 'html')&#10;            msg.attach(part2)&#10;            &#10;            # Send email&#10;            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:&#10;                server.starttls()&#10;                if self.smtp_user and self.smtp_password:&#10;                    server.login(self.smtp_user, self.smtp_password)&#10;                server.send_message(msg)&#10;            &#10;            return True&#10;        except Exception as e:&#10;            print(f&quot;Error sending email: {str(e)}&quot;)&#10;            return False&#10;    &#10;    def send_verification_email(&#10;        self,&#10;        to_email: str,&#10;        verification_token: str,&#10;        user_name: str&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send email verification email (works for both users and customers)&#10;        &#10;        Args:&#10;            to_email: Email address&#10;            verification_token: Verification token&#10;            user_name: User's name&#10;            &#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        verification_url = f&quot;{settings.FRONTEND_URL}/verify-email?token={verification_token}&quot;&#10;        &#10;        subject = &quot;Verify Your Email Address - Salona&quot;&#10;        &#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Welcome to Salona!&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {user_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;Thank you for signing up! To complete your registration, please verify your email address by clicking the button below:&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{verification_url}&quot; &#10;                       style=&quot;background-color: #007bff; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        Verify Email Address&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                    {verification_url}&#10;                &lt;/p&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                    This verification link will expire in 24 hours. If you didn't create an account with Salona, please ignore this email.&#10;                &lt;/p&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;        &#10;        text_content = f&quot;&quot;&quot;&#10;        Welcome to Salona!&#10;        &#10;        Hi {user_name},&#10;        &#10;        Thank you for signing up! To complete your registration, please verify your email address by clicking the link below:&#10;        &#10;        {verification_url}&#10;        &#10;        This verification link will expire in 24 hours. If you didn't create an account with Salona, please ignore this email.&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;        &#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;    &#10;    def send_password_reset_email(&#10;        self,&#10;        to_email: str,&#10;        reset_token: str,&#10;        user_name: str&#10;    ) -&gt; bool:&#10;        &quot;&quot;&quot;&#10;        Send password reset email (works for both users and customers)&#10;        &#10;        Args:&#10;            to_email: Email address&#10;            reset_token: Password reset token&#10;            user_name: User's name&#10;            &#10;        Returns:&#10;            bool: True if email sent successfully&#10;        &quot;&quot;&quot;&#10;        reset_url = f&quot;{settings.FRONTEND_URL}/reset-password?token={reset_token}&quot;&#10;        &#10;        subject = &quot;Reset Your Password - Salona&quot;&#10;        &#10;        html_content = f&quot;&quot;&quot;&#10;        &lt;!DOCTYPE html&gt;&#10;        &lt;html&gt;&#10;        &lt;head&gt;&#10;            &lt;meta charset=&quot;UTF-8&quot;&gt;&#10;            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&#10;        &lt;/head&gt;&#10;        &lt;body style=&quot;font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;&quot;&gt;&#10;            &lt;div style=&quot;background-color: #f8f9fa; padding: 20px; border-radius: 10px;&quot;&gt;&#10;                &lt;h1 style=&quot;color: #2c3e50; margin-bottom: 20px;&quot;&gt;Password Reset Request&lt;/h1&gt;&#10;                &#10;                &lt;p&gt;Hi {user_name},&lt;/p&gt;&#10;                &#10;                &lt;p&gt;We received a request to reset your password. Click the button below to create a new password:&lt;/p&gt;&#10;                &#10;                &lt;div style=&quot;text-align: center; margin: 30px 0;&quot;&gt;&#10;                    &lt;a href=&quot;{reset_url}&quot; &#10;                       style=&quot;background-color: #dc3545; color: white; padding: 12px 30px; text-decoration: none; border-radius: 5px; display: inline-block; font-weight: bold;&quot;&gt;&#10;                        Reset Password&#10;                    &lt;/a&gt;&#10;                &lt;/div&gt;&#10;                &#10;                &lt;p&gt;Or copy and paste this link into your browser:&lt;/p&gt;&#10;                &lt;p style=&quot;background-color: #e9ecef; padding: 10px; border-radius: 5px; word-break: break-all;&quot;&gt;&#10;                    {reset_url}&#10;                &lt;/p&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 14px; margin-top: 30px;&quot;&gt;&#10;                    This password reset link will expire in 1 hour. If you didn't request a password reset, please ignore this email or contact support if you have concerns.&#10;                &lt;/p&gt;&#10;                &#10;                &lt;hr style=&quot;border: none; border-top: 1px solid #dee2e6; margin: 30px 0;&quot;&gt;&#10;                &#10;                &lt;p style=&quot;color: #6c757d; font-size: 12px; text-align: center;&quot;&gt;&#10;                     {datetime.now().year} Salona. All rights reserved.&#10;                &lt;/p&gt;&#10;            &lt;/div&gt;&#10;        &lt;/body&gt;&#10;        &lt;/html&gt;&#10;        &quot;&quot;&quot;&#10;        &#10;        text_content = f&quot;&quot;&quot;&#10;        Password Reset Request&#10;        &#10;        Hi {user_name},&#10;        &#10;        We received a request to reset your password. Click the link below to create a new password:&#10;        &#10;        {reset_url}&#10;        &#10;        This password reset link will expire in 1 hour. If you didn't request a password reset, please ignore this email.&#10;        &#10;         {datetime.now().year} Salona. All rights reserved.&#10;        &quot;&quot;&quot;&#10;        &#10;        return self._send_email(to_email, subject, html_content, text_content)&#10;&#10;&#10;def create_verification_token(&#10;    db: Session,&#10;    entity_id: str,&#10;    verification_type: VerificationType,&#10;    entity_type: str = &quot;user&quot;,&#10;    expires_in_hours: int = 24&#10;) -&gt; Union[UserVerifications, CustomerVerifications]:&#10;    &quot;&quot;&quot;&#10;    Create a verification token for a user or customer&#10;    &#10;    Args:&#10;        db: Database session&#10;        entity_id: User or Customer ID&#10;        verification_type: Type of verification (email, phone, etc.)&#10;        entity_type: Either &quot;user&quot; or &quot;customer&quot;&#10;        expires_in_hours: Hours until token expires&#10;        &#10;    Returns:&#10;        UserVerifications or CustomerVerifications: The created verification record&#10;    &quot;&quot;&quot;&#10;    token = str(uuid.uuid4())&#10;    expires_at = datetime.now() + timedelta(hours=expires_in_hours)&#10;    &#10;    if entity_type == &quot;user&quot;:&#10;        db_obj = UserVerifications(&#10;            id=uuid.uuid4(),&#10;            user_id=entity_id,&#10;            token=token,&#10;            type=verification_type,&#10;            status=VerificationStatus.PENDING,&#10;            expires_at=expires_at&#10;        )&#10;    else:  # customer&#10;        db_obj = CustomerVerifications(&#10;            id=uuid.uuid4(),&#10;            customer_id=entity_id,&#10;            token=token,&#10;            type=verification_type,&#10;            status=VerificationStatus.PENDING,&#10;            expires_at=expires_at&#10;        )&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    &#10;    return db_obj&#10;&#10;&#10;# Singleton instance&#10;email_service = EmailService()" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>