<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/alembic/versions/add_membership_tables.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/alembic/versions/add_membership_tables.py" />
              <option name="originalContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;&#10;" />
              <option name="updatedContent" value="&quot;&quot;&quot;add membership functionality&#10;&#10;Revision ID: add_membership_tables&#10;Revises: 837a5dae2814&#10;Create Date: 2025-10-30 12:00:00.000000&#10;&#10;&quot;&quot;&quot;&#10;from alembic import op&#10;import sqlalchemy as sa&#10;from sqlalchemy.dialects import postgresql&#10;import uuid&#10;&#10;# revision identifiers, used by Alembic.&#10;revision = 'add_membership_tables'&#10;down_revision = '837a5dae2814'&#10;branch_labels = None&#10;depends_on = None&#10;&#10;&#10;def upgrade() -&gt; None:&#10;    # Create enum type for membership plan&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype', create_type=True)&#10;    membership_plan_type.create(op.get_bind(), checkfirst=True)&#10;    &#10;    # Create membership_plans table&#10;    op.create_table(&#10;        'membership_plans',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('name', sa.String(100), nullable=False, unique=True),&#10;        sa.Column('plan_type', membership_plan_type, nullable=False, unique=True),&#10;        sa.Column('description', sa.Text, nullable=True),&#10;        sa.Column('price', sa.Integer, nullable=False),&#10;        sa.Column('duration_days', sa.Integer, nullable=False, server_default='30'),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now())&#10;    )&#10;&#10;    # Create company_memberships table&#10;    op.create_table(&#10;        'company_memberships',&#10;        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),&#10;        sa.Column('company_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('membership_plan_id', postgresql.UUID(as_uuid=True), nullable=False),&#10;        sa.Column('status', postgresql.ENUM('active', 'inactive', 'suspended', name='statustype'), server_default='active'),&#10;        sa.Column('start_date', sa.DateTime, nullable=False, server_default=sa.func.now()),&#10;        sa.Column('end_date', sa.DateTime, nullable=False),&#10;        sa.Column('auto_renew', sa.Boolean, server_default='true'),&#10;        sa.Column('created_at', sa.DateTime, server_default=sa.func.now()),&#10;        sa.Column('updated_at', sa.DateTime, server_default=sa.func.now(), onupdate=sa.func.now()),&#10;        sa.ForeignKeyConstraint(['company_id'], ['companies.id'], ondelete='CASCADE'),&#10;        sa.ForeignKeyConstraint(['membership_plan_id'], ['membership_plans.id'], ondelete='CASCADE'),&#10;    )&#10;    &#10;    # Create index for company_memberships&#10;    op.create_index('idx_company_memberships_company_id', 'company_memberships', ['company_id'])&#10;    op.create_index('idx_company_memberships_status', 'company_memberships', ['status'])&#10;    &#10;    # Insert default membership plans&#10;    op.execute(&quot;&quot;&quot;&#10;        INSERT INTO membership_plans (id, name, plan_type, description, price, duration_days, max_bookings_per_month, discount_percentage, priority_booking, cancellation_hours, features, status)&#10;        VALUES &#10;        (gen_random_uuid(), 'Standard Membership', 'standard', 'Basic membership with limited features', 999, 30, 5, 5, false, 24, '{&quot;support&quot;: &quot;email&quot;, &quot;booking_window&quot;: 7}', 'active'),&#10;        (gen_random_uuid(), 'Premium Membership', 'premium', 'Enhanced membership with more features and better benefits', 1999, 30, 15, 10, true, 48, '{&quot;support&quot;: &quot;priority_email&quot;, &quot;booking_window&quot;: 14, &quot;exclusive_services&quot;: true}', 'active'),&#10;        (gen_random_uuid(), 'VIP Membership', 'vip', 'Unlimited bookings with premium benefits', 4999, 30, NULL, 20, true, 72, '{&quot;support&quot;: &quot;24/7_phone&quot;, &quot;booking_window&quot;: 30, &quot;exclusive_services&quot;: true, &quot;concierge&quot;: true}', 'active')&#10;    &quot;&quot;&quot;)&#10;&#10;&#10;def downgrade() -&gt; None:&#10;    # Drop tables&#10;    op.drop_index('idx_company_memberships_status', 'company_memberships')&#10;    op.drop_index('idx_company_memberships_company_id', 'company_memberships')&#10;    op.drop_table('company_memberships')&#10;    &#10;    op.drop_table('membership_plans')&#10;    &#10;    # Drop enum type&#10;    membership_plan_type = postgresql.ENUM('standard', 'premium', 'vip', name='membershipplantype')&#10;    membership_plan_type.drop(op.get_bind(), checkfirst=True)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/dependencies.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/dependencies.py" />
              <option name="originalContent" value="from fastapi import Depends, HTTPException, status, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from app.db.session import get_db&#10;from app.schemas import User&#10;from app.services.auth import get_current_id, verify_token&#10;from app.services.crud import user as crud_user, customer as crud_customer, company as crud_company&#10;from app.models.models import Users, Customers, CompanyUsers&#10;from app.models.enums import CompanyRoleType&#10;&#10;&#10;async def get_current_user(&#10;    request: Request,&#10;    db: Session = Depends(get_db)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current authenticated user from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;    &#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract user ID from token (this will raise HTTPException with specific message if token is expired)&#10;    user_id = get_current_id(access_token)&#10;    if user_id is None:&#10;        raise credentials_exception&#10;&#10;    # Get user from database&#10;    user, company_id = crud_user.get(db, id=user_id)&#10;    if user is None:&#10;        raise credentials_exception&#10;&#10;    user.company_id = company_id&#10;    return user&#10;&#10;&#10;def get_current_customer(&#10;        request: Request,&#10;        db: Session = Depends(get_db)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current authenticated customer from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    try:&#10;        # Extract access token from HTTP-only cookie&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise credentials_exception&#10;&#10;        # Extract customer ID from token&#10;        customer_id = get_current_id(access_token)&#10;        if customer_id is None:&#10;            raise credentials_exception&#10;&#10;    except Exception:&#10;        raise credentials_exception&#10;&#10;    # Get customer from database&#10;    customer = crud_customer.get(db, id=customer_id)&#10;&#10;    if customer is None:&#10;        raise credentials_exception&#10;&#10;    return customer&#10;&#10;&#10;def get_token_payload(&#10;        request: Request&#10;) -&gt; dict:&#10;    &quot;&quot;&quot;Extract and return the payload from the JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract payload from token (this will raise HTTPException with specific message if token is expired)&#10;    payload = verify_token(access_token)&#10;    if payload is None:&#10;        raise credentials_exception&#10;&#10;    return payload&#10;&#10;&#10;def get_current_company_id(token_payload: dict = Depends(get_token_payload)) -&gt; str:&#10;    company_id = token_payload.get(&quot;company_id&quot;)&#10;    if not company_id:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            detail=&quot;Company ID not found in token&quot;&#10;        )&#10;    return company_id&#10;&#10;&#10;async def get_current_active_user(&#10;    current_user: Users = Depends(get_current_user)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_user&#10;&#10;&#10;async def get_current_company_user(&#10;        current_user: Users = Depends(get_current_user),&#10;        company_id: str = Depends(get_current_company_id),&#10;        db: Session = Depends(get_db)&#10;) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    company_user = crud_company.get_company_user(db, user_id=current_user.id, company_id=company_id)&#10;&#10;    return company_user&#10;&#10;&#10;async def get_current_active_customer(&#10;    current_customer: Customers = Depends(get_current_customer)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current active customer (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_customer&#10;&#10;&#10;async def get_current_user_role(&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_user),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Get the current user's role in the company.&quot;&quot;&quot;&#10;    company_user = db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == current_user.id,&#10;        CompanyUsers.company_id == company_id&#10;    ).first()&#10;&#10;    if not company_user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;User is not a member of this company&quot;&#10;        )&#10;&#10;    return company_user.role&#10;&#10;&#10;def require_role(allowed_roles: List[CompanyRoleType]):&#10;    &quot;&quot;&quot;&#10;    Dependency factory to check if user has one of the allowed roles.&#10;&#10;    Usage:&#10;        @router.get(&quot;/staff&quot;)&#10;        async def list_staff(&#10;            role: CompanyRoleType = Depends(require_role([CompanyRoleType.owner, CompanyRoleType.admin]))&#10;        ):&#10;            ...&#10;    &quot;&quot;&quot;&#10;    async def role_checker(&#10;        user_role: CompanyRoleType = Depends(get_current_user_role)&#10;    ) -&gt; CompanyRoleType:&#10;        if user_role not in allowed_roles:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                detail=f&quot;Insufficient permissions, contact your administrator&quot;&#10;            )&#10;        return user_role&#10;&#10;    return role_checker&#10;&#10;&#10;async def require_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require owner role.&quot;&quot;&quot;&#10;    if user_role != CompanyRoleType.owner:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_admin_or_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require admin or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners or admins can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_staff_or_higher(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require staff, admin, or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin, CompanyRoleType.staff]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company staff, admins, or owners can access this resource&quot;&#10;        )&#10;    return user_role&#10;" />
              <option name="updatedContent" value="from fastapi import Depends, HTTPException, status, Request&#10;from sqlalchemy.orm import Session&#10;from typing import List&#10;from app.db.session import get_db&#10;from app.schemas import User&#10;from app.services.auth import get_current_id, verify_token&#10;from app.services.crud import user as crud_user, customer as crud_customer, company as crud_company&#10;from app.models.models import Users, Customers, CompanyUsers&#10;from app.models.enums import CompanyRoleType&#10;&#10;&#10;async def get_current_user(&#10;    request: Request,&#10;    db: Session = Depends(get_db)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current authenticated user from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;    &#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract user ID from token (this will raise HTTPException with specific message if token is expired)&#10;    user_id = get_current_id(access_token)&#10;    if user_id is None:&#10;        raise credentials_exception&#10;&#10;    # Get user from database&#10;    user, company_id = crud_user.get(db, id=user_id)&#10;    if user is None:&#10;        raise credentials_exception&#10;&#10;    user.company_id = company_id&#10;    return user&#10;&#10;&#10;def get_current_customer(&#10;        request: Request,&#10;        db: Session = Depends(get_db)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current authenticated customer from JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    try:&#10;        # Extract access token from HTTP-only cookie&#10;        access_token = request.cookies.get(&quot;access_token&quot;)&#10;        if not access_token:&#10;            raise credentials_exception&#10;&#10;        # Extract customer ID from token&#10;        customer_id = get_current_id(access_token)&#10;        if customer_id is None:&#10;            raise credentials_exception&#10;&#10;    except Exception:&#10;        raise credentials_exception&#10;&#10;    # Get customer from database&#10;    customer = crud_customer.get(db, id=customer_id)&#10;&#10;    if customer is None:&#10;        raise credentials_exception&#10;&#10;    return customer&#10;&#10;&#10;def get_token_payload(&#10;        request: Request&#10;) -&gt; dict:&#10;    &quot;&quot;&quot;Extract and return the payload from the JWT token in HTTP-only cookie.&quot;&quot;&quot;&#10;    credentials_exception = HTTPException(&#10;        status_code=status.HTTP_401_UNAUTHORIZED,&#10;        detail=&quot;Could not validate credentials&quot;,&#10;        headers={&quot;WWW-Authenticate&quot;: &quot;Bearer&quot;},&#10;    )&#10;&#10;    # Extract access token from HTTP-only cookie&#10;    access_token = request.cookies.get(&quot;access_token&quot;)&#10;    if not access_token:&#10;        raise credentials_exception&#10;&#10;    # Extract payload from token (this will raise HTTPException with specific message if token is expired)&#10;    payload = verify_token(access_token)&#10;    if payload is None:&#10;        raise credentials_exception&#10;&#10;    return payload&#10;&#10;&#10;def get_current_company_id(token_payload: dict = Depends(get_token_payload)) -&gt; str:&#10;    company_id = token_payload.get(&quot;company_id&quot;)&#10;    if not company_id:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_400_BAD_REQUEST,&#10;            detail=&quot;Company ID not found in token&quot;&#10;        )&#10;    return company_id&#10;&#10;&#10;async def get_current_active_user(&#10;    current_user: Users = Depends(get_current_user)&#10;) -&gt; Users:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_user&#10;&#10;&#10;async def get_current_company_user(&#10;        current_user: Users = Depends(get_current_user),&#10;        company_id: str = Depends(get_current_company_id),&#10;        db: Session = Depends(get_db)&#10;) -&gt; CompanyUsers:&#10;    &quot;&quot;&quot;Get the current active user (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    company_user = crud_company.get_company_user(db, user_id=current_user.id, company_id=company_id)&#10;&#10;    return company_user&#10;&#10;&#10;async def get_current_active_customer(&#10;    current_customer: Customers = Depends(get_current_customer)&#10;) -&gt; Customers:&#10;    &quot;&quot;&quot;Get the current active customer (can be extended for status checks).&quot;&quot;&quot;&#10;    # Here you can add additional checks like account status, subscription, etc.&#10;    return current_customer&#10;&#10;&#10;async def get_current_user_role(&#10;    db: Session = Depends(get_db),&#10;    current_user: Users = Depends(get_current_user),&#10;    company_id: str = Depends(get_current_company_id)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Get the current user's role in the company.&quot;&quot;&quot;&#10;    company_user = db.query(CompanyUsers).filter(&#10;        CompanyUsers.user_id == current_user.id,&#10;        CompanyUsers.company_id == company_id&#10;    ).first()&#10;&#10;    if not company_user:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;User is not a member of this company&quot;&#10;        )&#10;&#10;    return company_user.role&#10;&#10;&#10;def require_role(allowed_roles: List[CompanyRoleType]):&#10;    &quot;&quot;&quot;&#10;    Dependency factory to check if user has one of the allowed roles.&#10;&#10;    Usage:&#10;        @router.get(&quot;/staff&quot;)&#10;        async def list_staff(&#10;            role: CompanyRoleType = Depends(require_role([CompanyRoleType.owner, CompanyRoleType.admin]))&#10;        ):&#10;            ...&#10;    &quot;&quot;&quot;&#10;    async def role_checker(&#10;        user_role: CompanyRoleType = Depends(get_current_user_role)&#10;    ) -&gt; CompanyRoleType:&#10;        if user_role not in allowed_roles:&#10;            raise HTTPException(&#10;                status_code=status.HTTP_403_FORBIDDEN,&#10;                detail=f&quot;Insufficient permissions, contact your administrator&quot;&#10;            )&#10;        return user_role&#10;&#10;    return role_checker&#10;&#10;&#10;async def require_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require owner role.&quot;&quot;&quot;&#10;    if user_role != CompanyRoleType.owner:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_admin_or_owner(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require admin or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company owners or admins can access this resource&quot;&#10;        )&#10;    return user_role&#10;&#10;&#10;async def require_staff_or_higher(&#10;    user_role: CompanyRoleType = Depends(get_current_user_role)&#10;) -&gt; CompanyRoleType:&#10;    &quot;&quot;&quot;Require staff, admin, or owner role.&quot;&quot;&quot;&#10;    if user_role not in [CompanyRoleType.owner, CompanyRoleType.admin, CompanyRoleType.staff]:&#10;        raise HTTPException(&#10;            status_code=status.HTTP_403_FORBIDDEN,&#10;            detail=&quot;Only company staff, admins, or owners can access this resource&quot;&#10;        )&#10;    return user_role" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/core/config.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/core/config.py" />
              <option name="originalContent" value="from pydantic_settings import BaseSettings&#10;from typing import Optional&#10;&#10;class Settings(BaseSettings):&#10;    &#10;    PROJECT_NAME: str = &quot;Salona Business API&quot;&#10;    VERSION: str = &quot;1.0.0&quot;&#10;    API_V1_STR: str = &quot;/api/v1&quot;&#10;    &#10;    POSTGRES_USER: str = ''&#10;    POSTGRES_PASSWORD: str = ''&#10;    POSTGRES_SERVER: str = ''&#10;    POSTGRES_DB: str = ''&#10;    DATABASE_URL: Optional[str] = None&#10;    SECRET_KEY: Optional[str] = None&#10;    REDIS_URL: Optional[str] = None&#10;    STRIPE_WEBHOOK_SECRET: Optional[str] = None&#10;    STRIPE_API_KEY: Optional[str] = None&#10;    API_URL: str = &quot;https://api.salona.me&quot;&#10;    FRONTEND_URL: str = &quot;https://salona.me&quot;&#10;&#10;    # SMTP Email Configuration&#10;    SMTP_HOST: Optional[str] = None&#10;    SMTP_PORT: int = 587&#10;    SMTP_USER: Optional[str] = None&#10;    SMTP_PASSWORD: Optional[str] = None&#10;    SMTP_FROM_EMAIL: Optional[str] = None&#10;    SMTP_FROM_NAME: str = &quot;Salona&quot;&#10;    MAILERSEND_API_KEY: Optional[str] = None&#10;    MAILERSEND_FROM_EMAIL: Optional[str] = None&#10;    MAILERSEND_FROM_NAME: str = &quot;Salona&quot;&#10;&#10;    # Google OAuth Configuration&#10;    GOOGLE_CLIENT_ID: Optional[str] = None&#10;    GOOGLE_CLIENT_SECRET: Optional[str] = None&#10;    GOOGLE_REDIRECT_URI: Optional[str] = None&#10;&#10;    # AWS S3 Configuration&#10;    AWS_ACCESS_KEY_ID: Optional[str] = None&#10;    AWS_SECRET_ACCESS_KEY: Optional[str] = None&#10;    AWS_REGION_NAME: Optional[str] = None&#10;    AWS_S3_BUCKET_NAME: Optional[str] = None&#10;&#10;    class Config:&#10;        env_file = &quot;.env&quot;  # only used locally if no system env vars are set&#10;        env_file_encoding = &quot;utf-8&quot;&#10;        extra = &quot;ignore&quot;  # ignore extra env vars Railway injects&#10;&#10;    # Map Railway defaults&#10;    def get_database_url(self):&#10;        return self.DATABASE_URL or f&quot;postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_SERVER}/{self.POSTGRES_DB}&quot;&#10;&#10;&#10;settings = Settings()&#10;# settings.DATABASE_URL = settings._build_database_url()" />
              <option name="updatedContent" value="from pydantic_settings import BaseSettings&#10;from typing import Optional&#10;&#10;class Settings(BaseSettings):&#10;    &#10;    PROJECT_NAME: str = &quot;Salona Business API&quot;&#10;    VERSION: str = &quot;1.0.0&quot;&#10;    API_V1_STR: str = &quot;/api/v1&quot;&#10;    &#10;    POSTGRES_USER: str = ''&#10;    POSTGRES_PASSWORD: str = ''&#10;    POSTGRES_SERVER: str = ''&#10;    POSTGRES_DB: str = ''&#10;    DATABASE_URL: Optional[str] = None&#10;    SECRET_KEY: Optional[str] = None&#10;    REDIS_URL: Optional[str] = None&#10;    STRIPE_WEBHOOK_SECRET: Optional[str] = None&#10;    STRIPE_API_KEY: Optional[str] = None&#10;    API_URL: str = &quot;https://api.salona.me&quot;&#10;    FRONTEND_URL: str = &quot;https://salona.me&quot;&#10;&#10;    # SMTP Email Configuration&#10;    SMTP_HOST: Optional[str] = None&#10;    SMTP_PORT: int = 587&#10;    SMTP_USER: Optional[str] = None&#10;    SMTP_PASSWORD: Optional[str] = None&#10;    SMTP_FROM_EMAIL: Optional[str] = None&#10;    SMTP_FROM_NAME: str = &quot;Salona&quot;&#10;    MAILERSEND_API_KEY: Optional[str] = None&#10;    MAILERSEND_FROM_EMAIL: Optional[str] = None&#10;    MAILERSEND_FROM_NAME: str = &quot;Salona&quot;&#10;&#10;    # Google OAuth Configuration&#10;    GOOGLE_CLIENT_ID: Optional[str] = None&#10;    GOOGLE_CLIENT_SECRET: Optional[str] = None&#10;    GOOGLE_REDIRECT_URI: Optional[str] = None&#10;&#10;    # AWS S3 Configuration&#10;    AWS_ACCESS_KEY_ID: Optional[str] = None&#10;    AWS_SECRET_ACCESS_KEY: Optional[str] = None&#10;    AWS_REGION_NAME: Optional[str] = None&#10;    AWS_S3_BUCKET_NAME: Optional[str] = None&#10;&#10;    class Config:&#10;        env_file = &quot;.env&quot;  # only used locally if no system env vars are set&#10;        env_file_encoding = &quot;utf-8&quot;&#10;        extra = &quot;ignore&quot;  # ignore extra env vars Railway injects&#10;&#10;    # Map Railway defaults&#10;    def get_database_url(self):&#10;        return self.DATABASE_URL or f&quot;postgresql://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_SERVER}/{self.POSTGRES_DB}&quot;&#10;&#10;&#10;settings = Settings()&#10;# settings.DATABASE_URL = settings._build_database_url()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/models/models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/models/models.py" />
              <option name="originalContent" value="import uuid&#10;&#10;from pydantic.v1 import create_model_from_typeddict&#10;from sqlalchemy import (Column, Integer, String, Boolean, DateTime, Text, Date, ForeignKey, UniqueConstraint, UUID,&#10;                        Time, Computed,&#10;                        CheckConstraint, false, BLOB, LargeBinary, Index, select)&#10;from sqlalchemy.dialects.postgresql import ENUM as SQLAlchemyEnum&#10;from sqlalchemy.orm import relationship, column_property&#10;from sqlalchemy.sql import func&#10;from sqlalchemy.sql import expression&#10;from sqlalchemy.ext.hybrid import hybrid_property&#10;&#10;from app.db.base_class import BaseModel&#10;from app.models.enums import (StatusType, BookingStatus, CustomerStatusType, EmailStatusType,&#10;                              PhoneStatusType, VerificationType, VerificationStatus,&#10;                              CompanyRoleType, NotificationType, NotificationStatus, MembershipPlanType, InvitationStatus)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;#&#10;class Users(BaseModel):&#10;    __tablename__ = &quot;users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;    languages = Column(String(255), nullable=True)&#10;    position = Column(String(255), nullable=True)&#10;    profile_photo_url = Column(String(510), nullable=True)&#10;&#10;    company_user = relationship(&quot;CompanyUsers&quot;, back_populates=&quot;user&quot;)&#10;    user_time_offs = relationship(&quot;UserTimeOffs&quot;, back_populates=&quot;user&quot;)&#10;    booked_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;assigned_staff&quot;)&#10;&#10;&#10;class UserVerifications(BaseModel):&#10;    __tablename__ = &quot;user_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;&#10;class UserAvailabilities(BaseModel):&#10;    __tablename__ = &quot;user_availabilities&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    day_of_week = Column(Integer, nullable=False)  # 0=Monday, 6=Sunday&#10;    start_time = Column(Time, nullable=False)  # Store only time (HH:MM)&#10;    end_time = Column(Time, nullable=False)    # Store only time (HH:MM)&#10;    is_available = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    __table_args__ = (&#10;        # Add constraint to ensure start_time is before end_time&#10;        CheckConstraint('start_time &lt; end_time', name='check_time_order'),&#10;        # Add unique constraint to prevent overlapping time slots for the same user and day&#10;        UniqueConstraint('user_id', 'day_of_week', 'start_time', 'end_time', name='unique_user_availability')&#10;    )&#10;&#10;&#10;class UserTimeOffs(BaseModel):&#10;    __tablename__ = &quot;user_time_offs&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    start_date = Column(DateTime, nullable=False)&#10;    end_date = Column(DateTime, nullable=False)&#10;    reason = Column(Text)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;user_time_offs&quot;)&#10;&#10;&#10;class Companies(BaseModel):&#10;    __tablename__ = &quot;companies&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(255), nullable=False)&#10;    type = Column(String(255), nullable=False)&#10;    logo_url = Column(String(255))&#10;    website = Column(String(255))&#10;    description = Column(Text)&#10;    team_size = Column(Integer, default=1)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;    slug = Column(&#10;        String,&#10;        Computed(&quot;REPLACE(LOWER(name), ' ', '-')&quot;, persisted=True)&#10;    )&#10;&#10;    invitations = relationship(&quot;Invitations&quot;, back_populates=&quot;company&quot;)&#10;&#10;&#10;class CompanyEmails(BaseModel):&#10;    __tablename__ = &quot;company_emails&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CompanyPhones(BaseModel):&#10;    __tablename__ = &quot;company_phones&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CompanyAddresses(BaseModel):&#10;    __tablename__ = &quot;company_addresses&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address = Column(String(255), nullable=False)&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;&#10;class CompanyUsers(BaseModel):&#10;    __tablename__ = &quot;company_users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)  # e.g., admin, member&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.inactive)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;company_user&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('user_id', 'company_id', name='_user_company_uc'),)&#10;&#10;&#10;class Customers(BaseModel):&#10;    __tablename__ = &quot;customers&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;customer&quot;)&#10;&#10;class CustomerEmails(BaseModel):&#10;    __tablename__ = &quot;customer_emails&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CustomerPhones(BaseModel):&#10;    __tablename__ = &quot;customer_phones&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CustomerAddresses(BaseModel):&#10;    __tablename__ = &quot;customer_addresses&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address_line1 = Column(String(255), nullable=False)&#10;    address_line2 = Column(String(255))&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CustomerVerifications(BaseModel):&#10;    __tablename__ = &quot;customer_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;class Bookings(BaseModel):&#10;    __tablename__ = &quot;bookings&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    status = Column(SQLAlchemyEnum(BookingStatus), default=BookingStatus.SCHEDULED)&#10;    start_at = Column(DateTime, nullable=False)&#10;    end_at = Column(DateTime, nullable=False)&#10;    total_price = Column(Integer, nullable=False)&#10;    notes = Column(Text)&#10;&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    customer = relationship(&quot;Customers&quot;, back_populates=&quot;booking&quot;)&#10;    booking_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;booking&quot;)&#10;&#10;&#10;class CompanyCategories(BaseModel):&#10;    __tablename__ = &quot;company_categories&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    parent_category_id = Column(UUID(as_uuid=True), ForeignKey(&quot;company_categories.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=True, index=True)&#10;    name = Column(String(100), nullable=False)&#10;    name_en = Column(String(100), nullable=True)&#10;    name_ee = Column(String(100), nullable=True)&#10;    name_ru = Column(String(100), nullable=True)&#10;    description = Column(Text)&#10;    description_en = Column(Text, nullable=True)&#10;    description_ee = Column(Text, nullable=True)&#10;    description_ru = Column(Text, nullable=True)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;company_category&quot;)&#10;    subcategories = relationship(&quot;CompanyCategories&quot;,&#10;                                  backref=&quot;parent&quot;,&#10;                                  remote_side=[id],&#10;                                  cascade=&quot;all, delete&quot;)&#10;&#10;    @hybrid_property&#10;    def services_count(self):&#10;        &quot;&quot;&quot;Return the count of services in this category&quot;&quot;&quot;&#10;        if self.category_service is None:&#10;            return 0&#10;        try:&#10;            return len(self.category_service)&#10;        except (TypeError, AttributeError):&#10;            return 0&#10;&#10;    @hybrid_property&#10;    def has_subcategories(self):&#10;        &quot;&quot;&quot;Check if this category has subcategories&quot;&quot;&quot;&#10;        if self.subcategories is None:&#10;            return False&#10;        try:&#10;            return len(self.subcategories) &gt; 0&#10;        except (TypeError, AttributeError):&#10;            return False&#10;&#10;&#10;class CategoryServices(BaseModel):&#10;    __tablename__ = &quot;category_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    category_id = Column(UUID, ForeignKey(&quot;company_categories.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(255))&#10;    name_en = Column(String(255), nullable=True)&#10;    name_ee = Column(String(255), nullable=True)&#10;    name_ru = Column(String(255), nullable=True)&#10;    duration = Column(Integer)&#10;    price = Column(Integer)&#10;    discount_price = Column(Integer)&#10;    additional_info = Column(Text)&#10;    additional_info_en = Column(Text, nullable=True)&#10;    additional_info_ee = Column(Text, nullable=True)&#10;    additional_info_ru = Column(Text, nullable=True)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    buffer_before = Column(Integer, default=0)  # in minutes&#10;    buffer_after = Column(Integer, default=0)   # in minutes&#10;    image_url = Column(String(510), nullable=True)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    company_category = relationship(&quot;CompanyCategories&quot;, back_populates=&quot;category_service&quot;)&#10;    booking_category_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;category_service&quot;)&#10;    service_staff = relationship(&quot;ServiceStaff&quot;, back_populates=&quot;service&quot;)&#10;&#10;&#10;class ServiceStaff(BaseModel):&#10;    __tablename__ = &quot;service_staff&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    service_id = Column(UUID, ForeignKey(&quot;category_services.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;service_staff&quot;)&#10;    user = relationship(&quot;Users&quot;)&#10;&#10;    __table_args__ = (&#10;        UniqueConstraint('service_id', 'user_id', name='_service_user_uc'),&#10;    )&#10;&#10;&#10;class BookingServices(BaseModel):&#10;    __tablename__ = &quot;booking_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    booking_id = Column(UUID, ForeignKey(&quot;bookings.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    category_service_id = Column(UUID, ForeignKey(&quot;category_services.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;SET NULL&quot;))&#10;    notes = Column(Text)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;    start_at = Column(DateTime, nullable=True)&#10;    end_at = Column(DateTime, nullable=True)&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;booking_services&quot;)&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;booking_category_services&quot;)&#10;    assigned_staff = relationship(&quot;Users&quot;, back_populates=&quot;booked_services&quot;)&#10;&#10;&#10;&#10;class CompanyNotifications(BaseModel):&#10;    __tablename__ = &quot;company_notifications&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    type = Column(SQLAlchemyEnum(NotificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(NotificationStatus), default=NotificationStatus.UNREAD)&#10;    message = Column(Text, nullable=False)&#10;    data = Column(LargeBinary, nullable=True)  # JSON or additional data&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;&#10;class MembershipPlans(BaseModel):&#10;    __tablename__ = &quot;membership_plans&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(100), nullable=False, unique=True)&#10;    plan_type = Column(SQLAlchemyEnum(MembershipPlanType), nullable=False, unique=True)&#10;    description = Column(Text)&#10;    url = Column(Text)&#10;    price = Column(Integer, nullable=False)  # Price in cents&#10;    duration_days = Column(Integer, nullable=False, default=30)  # Subscription duration&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    subscriptions = relationship(&quot;CompanyMemberships&quot;, back_populates=&quot;membership_plan&quot;)&#10;&#10;&#10;class CompanyMemberships(BaseModel):&#10;    __tablename__ = &quot;company_memberships&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    membership_plan_id = Column(UUID, ForeignKey(&quot;membership_plans.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    start_date = Column(DateTime, nullable=False, default=utcnow)&#10;    end_date = Column(DateTime, nullable=False)&#10;    auto_renew = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    membership_plan = relationship(&quot;MembershipPlans&quot;, back_populates=&quot;subscriptions&quot;)&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active membership at a time&#10;        Index(&#10;            'unique_active_company_membership',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class TelegramIntegrations(BaseModel):&#10;    __tablename__ = &quot;telegram_integrations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    bot_token_encrypted = Column(String(255), nullable=False)&#10;    chat_id = Column(String(255), nullable=True)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active telegram integration&#10;        Index(&#10;            'unique_active_telegram_integration',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class Invitations(BaseModel):&#10;    __tablename__ = &quot;invitations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    email = Column(String(255), nullable=False)&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)&#10;    status = Column(SQLAlchemyEnum(InvitationStatus), default=InvitationStatus.PENDING)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    company = relationship(&quot;Companies&quot;, back_populates=&quot;invitations&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('email', 'company_id', name='_email_company_uc'),)" />
              <option name="updatedContent" value="import uuid&#10;&#10;from pydantic.v1 import create_model_from_typeddict&#10;from sqlalchemy import (Column, Integer, String, Boolean, DateTime, Text, Date, ForeignKey, UniqueConstraint, UUID,&#10;                        Time, Computed,&#10;                        CheckConstraint, false, BLOB, LargeBinary, Index, select)&#10;from sqlalchemy.dialects.postgresql import ENUM as SQLAlchemyEnum&#10;from sqlalchemy.orm import relationship, column_property&#10;from sqlalchemy.sql import func&#10;from sqlalchemy.sql import expression&#10;from sqlalchemy.ext.hybrid import hybrid_property&#10;&#10;from app.db.base_class import BaseModel&#10;from app.models.enums import (StatusType, BookingStatus, CustomerStatusType, EmailStatusType,&#10;                              PhoneStatusType, VerificationType, VerificationStatus,&#10;                              CompanyRoleType, NotificationType, NotificationStatus, MembershipPlanType, InvitationStatus)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;#&#10;class Users(BaseModel):&#10;    __tablename__ = &quot;users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;    languages = Column(String(255), nullable=True)&#10;    position = Column(String(255), nullable=True)&#10;    profile_photo_url = Column(String(510), nullable=True)&#10;&#10;    company_user = relationship(&quot;CompanyUsers&quot;, back_populates=&quot;user&quot;)&#10;    user_time_offs = relationship(&quot;UserTimeOffs&quot;, back_populates=&quot;user&quot;)&#10;    booked_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;assigned_staff&quot;)&#10;&#10;&#10;class UserVerifications(BaseModel):&#10;    __tablename__ = &quot;user_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;&#10;class UserAvailabilities(BaseModel):&#10;    __tablename__ = &quot;user_availabilities&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    day_of_week = Column(Integer, nullable=False)  # 0=Monday, 6=Sunday&#10;    start_time = Column(Time, nullable=False)  # Store only time (HH:MM)&#10;    end_time = Column(Time, nullable=False)    # Store only time (HH:MM)&#10;    is_available = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    __table_args__ = (&#10;        # Add constraint to ensure start_time is before end_time&#10;        CheckConstraint('start_time &lt; end_time', name='check_time_order'),&#10;        # Add unique constraint to prevent overlapping time slots for the same user and day&#10;        UniqueConstraint('user_id', 'day_of_week', 'start_time', 'end_time', name='unique_user_availability')&#10;    )&#10;&#10;&#10;class UserTimeOffs(BaseModel):&#10;    __tablename__ = &quot;user_time_offs&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    start_date = Column(DateTime, nullable=False)&#10;    end_date = Column(DateTime, nullable=False)&#10;    reason = Column(Text)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;user_time_offs&quot;)&#10;&#10;&#10;class Companies(BaseModel):&#10;    __tablename__ = &quot;companies&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(255), nullable=False)&#10;    type = Column(String(255), nullable=False)&#10;    logo_url = Column(String(255))&#10;    website = Column(String(255))&#10;    description = Column(Text)&#10;    team_size = Column(Integer, default=1)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;    slug = Column(&#10;        String,&#10;        Computed(&quot;REPLACE(LOWER(name), ' ', '-')&quot;, persisted=True)&#10;    )&#10;&#10;    invitations = relationship(&quot;Invitations&quot;, back_populates=&quot;company&quot;)&#10;&#10;&#10;class CompanyEmails(BaseModel):&#10;    __tablename__ = &quot;company_emails&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CompanyPhones(BaseModel):&#10;    __tablename__ = &quot;company_phones&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CompanyAddresses(BaseModel):&#10;    __tablename__ = &quot;company_addresses&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address = Column(String(255), nullable=False)&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;&#10;class CompanyUsers(BaseModel):&#10;    __tablename__ = &quot;company_users&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)  # e.g., admin, member&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.inactive)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    user = relationship(&quot;Users&quot;, back_populates=&quot;company_user&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('user_id', 'company_id', name='_user_company_uc'),)&#10;&#10;&#10;class Customers(BaseModel):&#10;    __tablename__ = &quot;customers&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    first_name = Column(String(100), nullable=False)&#10;    last_name = Column(String(100), nullable=False)&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    password = Column(String(255), nullable=False)&#10;    phone = Column(String(20), nullable=False)&#10;    status = Column(SQLAlchemyEnum(CustomerStatusType), default=CustomerStatusType.pending_verification)&#10;    email_verified = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;customer&quot;)&#10;&#10;class CustomerEmails(BaseModel):&#10;    __tablename__ = &quot;customer_emails&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    email = Column(String(255), nullable=False, unique=True)&#10;    status = Column(SQLAlchemyEnum(EmailStatusType), default=EmailStatusType.unverified)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CustomerPhones(BaseModel):&#10;    __tablename__ = &quot;customer_phones&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    phone = Column(String(20), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    status = Column(SQLAlchemyEnum(PhoneStatusType), default=PhoneStatusType.unverified)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CustomerAddresses(BaseModel):&#10;    __tablename__ = &quot;customer_addresses&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    address_line1 = Column(String(255), nullable=False)&#10;    address_line2 = Column(String(255))&#10;    city = Column(String(100), nullable=False)&#10;    zip = Column(String(20))&#10;    country = Column(String(100), nullable=False)&#10;    is_primary = Column(Boolean, default=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;class CustomerVerifications(BaseModel):&#10;    __tablename__ = &quot;customer_verifications&quot;&#10;&#10;    id = Column(UUID, primary_key=True, index=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    type = Column(SQLAlchemyEnum(VerificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(VerificationStatus), default=VerificationStatus.PENDING)&#10;    expires_at = Column(DateTime, nullable=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    used_at = Column(DateTime, nullable=True)&#10;&#10;class Bookings(BaseModel):&#10;    __tablename__ = &quot;bookings&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    customer_id = Column(UUID, ForeignKey(&quot;customers.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    status = Column(SQLAlchemyEnum(BookingStatus), default=BookingStatus.SCHEDULED)&#10;    start_at = Column(DateTime, nullable=False)&#10;    end_at = Column(DateTime, nullable=False)&#10;    total_price = Column(Integer, nullable=False)&#10;    notes = Column(Text)&#10;&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    customer = relationship(&quot;Customers&quot;, back_populates=&quot;booking&quot;)&#10;    booking_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;booking&quot;)&#10;&#10;&#10;class CompanyCategories(BaseModel):&#10;    __tablename__ = &quot;company_categories&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    parent_category_id = Column(UUID(as_uuid=True), ForeignKey(&quot;company_categories.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=True, index=True)&#10;    name = Column(String(100), nullable=False)&#10;    name_en = Column(String(100), nullable=True)&#10;    name_ee = Column(String(100), nullable=True)&#10;    name_ru = Column(String(100), nullable=True)&#10;    description = Column(Text)&#10;    description_en = Column(Text, nullable=True)&#10;    description_ee = Column(Text, nullable=True)&#10;    description_ru = Column(Text, nullable=True)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;company_category&quot;)&#10;    subcategories = relationship(&quot;CompanyCategories&quot;,&#10;                                  backref=&quot;parent&quot;,&#10;                                  remote_side=[id],&#10;                                  cascade=&quot;all, delete&quot;)&#10;&#10;    @hybrid_property&#10;    def services_count(self):&#10;        &quot;&quot;&quot;Return the count of services in this category&quot;&quot;&quot;&#10;        if self.category_service is None:&#10;            return 0&#10;        try:&#10;            return len(self.category_service)&#10;        except (TypeError, AttributeError):&#10;            return 0&#10;&#10;    @hybrid_property&#10;    def has_subcategories(self):&#10;        &quot;&quot;&quot;Check if this category has subcategories&quot;&quot;&quot;&#10;        if self.subcategories is None:&#10;            return False&#10;        try:&#10;            return len(self.subcategories) &gt; 0&#10;        except (TypeError, AttributeError):&#10;            return False&#10;&#10;&#10;class CategoryServices(BaseModel):&#10;    __tablename__ = &quot;category_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    category_id = Column(UUID, ForeignKey(&quot;company_categories.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    name = Column(String(255))&#10;    name_en = Column(String(255), nullable=True)&#10;    name_ee = Column(String(255), nullable=True)&#10;    name_ru = Column(String(255), nullable=True)&#10;    duration = Column(Integer)&#10;    price = Column(Integer)&#10;    discount_price = Column(Integer)&#10;    additional_info = Column(Text)&#10;    additional_info_en = Column(Text, nullable=True)&#10;    additional_info_ee = Column(Text, nullable=True)&#10;    additional_info_ru = Column(Text, nullable=True)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    buffer_before = Column(Integer, default=0)  # in minutes&#10;    buffer_after = Column(Integer, default=0)   # in minutes&#10;    image_url = Column(String(510), nullable=True)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    company_category = relationship(&quot;CompanyCategories&quot;, back_populates=&quot;category_service&quot;)&#10;    booking_category_services = relationship(&quot;BookingServices&quot;, back_populates=&quot;category_service&quot;)&#10;    service_staff = relationship(&quot;ServiceStaff&quot;, back_populates=&quot;service&quot;)&#10;&#10;&#10;class ServiceStaff(BaseModel):&#10;    __tablename__ = &quot;service_staff&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    service_id = Column(UUID, ForeignKey(&quot;category_services.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;service_staff&quot;)&#10;    user = relationship(&quot;Users&quot;)&#10;&#10;    __table_args__ = (&#10;        UniqueConstraint('service_id', 'user_id', name='_service_user_uc'),&#10;    )&#10;&#10;&#10;class BookingServices(BaseModel):&#10;    __tablename__ = &quot;booking_services&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True, unique=True)&#10;    booking_id = Column(UUID, ForeignKey(&quot;bookings.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    category_service_id = Column(UUID, ForeignKey(&quot;category_services.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    user_id = Column(UUID, ForeignKey(&quot;users.id&quot;, ondelete=&quot;SET NULL&quot;))&#10;    notes = Column(Text)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;    start_at = Column(DateTime, nullable=True)&#10;    end_at = Column(DateTime, nullable=True)&#10;&#10;    booking = relationship(&quot;Bookings&quot;, back_populates=&quot;booking_services&quot;)&#10;    category_service = relationship(&quot;CategoryServices&quot;, back_populates=&quot;booking_category_services&quot;)&#10;    assigned_staff = relationship(&quot;Users&quot;, back_populates=&quot;booked_services&quot;)&#10;&#10;&#10;&#10;class CompanyNotifications(BaseModel):&#10;    __tablename__ = &quot;company_notifications&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    type = Column(SQLAlchemyEnum(NotificationType), nullable=False)&#10;    status = Column(SQLAlchemyEnum(NotificationStatus), default=NotificationStatus.UNREAD)&#10;    message = Column(Text, nullable=False)&#10;    data = Column(LargeBinary, nullable=True)  # JSON or additional data&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;&#10;class MembershipPlans(BaseModel):&#10;    __tablename__ = &quot;membership_plans&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    name = Column(String(100), nullable=False, unique=True)&#10;    plan_type = Column(SQLAlchemyEnum(MembershipPlanType), nullable=False, unique=True)&#10;    description = Column(Text)&#10;    url = Column(Text)&#10;    price = Column(Integer, nullable=False)  # Price in cents&#10;    duration_days = Column(Integer, nullable=False, default=30)  # Subscription duration&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    subscriptions = relationship(&quot;CompanyMemberships&quot;, back_populates=&quot;membership_plan&quot;)&#10;&#10;&#10;class CompanyMemberships(BaseModel):&#10;    __tablename__ = &quot;company_memberships&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    membership_plan_id = Column(UUID, ForeignKey(&quot;membership_plans.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    start_date = Column(DateTime, nullable=False, default=utcnow)&#10;    end_date = Column(DateTime, nullable=False)&#10;    auto_renew = Column(Boolean, default=True)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    membership_plan = relationship(&quot;MembershipPlans&quot;, back_populates=&quot;subscriptions&quot;)&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active membership at a time&#10;        Index(&#10;            'unique_active_company_membership',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class TelegramIntegrations(BaseModel):&#10;    __tablename__ = &quot;telegram_integrations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), default=uuid.uuid4, primary_key=True, index=True)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;), nullable=False)&#10;    bot_token_encrypted = Column(String(255), nullable=False)&#10;    chat_id = Column(String(255), nullable=True)&#10;    status = Column(SQLAlchemyEnum(StatusType), default=StatusType.active)&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    __table_args__ = (&#10;        # Ensure a company can only have one active telegram integration&#10;        Index(&#10;            'unique_active_telegram_integration',&#10;            'company_id',&#10;            unique=True,&#10;            postgresql_where=(expression.text(&quot;status = 'active'&quot;))&#10;        ),&#10;    )&#10;&#10;&#10;class Invitations(BaseModel):&#10;    __tablename__ = &quot;invitations&quot;&#10;&#10;    id = Column(UUID(as_uuid=True), primary_key=True, index=True)&#10;    email = Column(String(255), nullable=False)&#10;    token = Column(String(255), nullable=False, unique=True)&#10;    role = Column(SQLAlchemyEnum(CompanyRoleType), default=CompanyRoleType.viewer)&#10;    status = Column(SQLAlchemyEnum(InvitationStatus), default=InvitationStatus.PENDING)&#10;    company_id = Column(UUID, ForeignKey(&quot;companies.id&quot;, ondelete=&quot;CASCADE&quot;))&#10;    created_at = Column(DateTime, default=utcnow)&#10;    updated_at = Column(DateTime, default=utcnow, onupdate=utcnow)&#10;&#10;    company = relationship(&quot;Companies&quot;, back_populates=&quot;invitations&quot;)&#10;&#10;    __table_args__ = (UniqueConstraint('email', 'company_id', name='_email_company_uc'),)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/schemas/schemas.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/schemas/schemas.py" />
              <option name="originalContent" value="from datetime import datetime, date, time, timezone&#10;from decimal import Decimal&#10;from typing import Optional, List, Annotated&#10;from pydantic import BaseModel, Field, field_validator, ConfigDict, UUID4, EmailStr&#10;&#10;from app.models import CustomerStatusType, CompanyCategories&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType, EmailStatusType, PhoneStatusType, NotificationType, NotificationStatus, CompanyRoleType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;    languages: Optional[str] = &quot;English&quot;&#10;    position: Optional[str] = 'Professional'&#10;    profile_photo_url: Optional[str] = None&#10;&#10;&#10;# User Availability schemas&#10;class UserAvailabilityBase(BaseModel):&#10;    day_of_week: int = Field(..., ge=0, le=6, description=&quot;Day of week: 0=Monday, 6=Sunday&quot;)&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool = True&#10;&#10;&#10;class UserAvailabilityCreate(UserAvailabilityBase):&#10;    pass&#10;&#10;&#10;class UserAvailabilityUpdate(BaseModel):&#10;    start_time: Optional[time] = None&#10;    end_time: Optional[time] = None&#10;    is_available: Optional[bool] = None&#10;&#10;&#10;class UserAvailability(UserAvailabilityBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = []&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;    languages: Optional[str] = None&#10;    position: Optional[str] = None&#10;    profile_photo_url: Optional[str] = None&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    company_id: Optional[UUID4] = None&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(TimestampedModel):&#10;    id: UUID4&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;&#10;    user: Optional[User] = None&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;&#10;class CompanyUserUpdate(BaseModel):&#10;    role: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    availabilities: List[UserAvailabilityCreate] = []&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.active&#10;    slug: Optional[str] = None&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class CompanyUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    type: Optional[str] = None&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    id: Optional[UUID4] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: Optional[UUID4] = None&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: Optional[UUID4] = None&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    start_time: Optional[datetime] = None&#10;    notes: Optional[str] = None&#10;    status: Optional[BookingStatus] = None&#10;    services: Optional[List[BookingServiceRequest]] = None&#10;&#10;&#10;class ServiceStaff(BaseModel):&#10;    &quot;&quot;&quot;Schema for the service_staff junction table linking services to staff members&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;    # Optional nested user information&#10;    user: Optional['User'] = None&#10;&#10;&#10;class ServiceStaffCreate(BaseModel):&#10;    &quot;&quot;&quot;Schema for creating service-staff assignments&quot;&quot;&quot;&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;class ServiceStaffResponse(BaseModel):&#10;    &quot;&quot;&quot;Simplified response schema for staff assigned to a service&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    image_url: Optional[str] = None&#10;    service_staff: Optional[List['ServiceStaff']] = []  # List of staff assigned to this service&#10;&#10;&#10;class StaffMember(BaseModel):&#10;    &quot;&quot;&quot;Simple staff member schema for booking assignments&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class BookingService(TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    booking_id: UUID4&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;    start_date: Optional[datetime] = None&#10;    end_date: Optional[datetime] = None&#10;&#10;    category_service: Optional[CategoryServiceResponse] = None&#10;    assigned_staff: Optional[User] = None  # Changed from assigned_staff to match the model relationship&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;    customer: Optional[Customer] = None&#10;    booking_services: Optional[List[BookingService]] = []&#10;    user_ids: set[str] = set([])&#10;&#10;&#10;#&#10;class CompanyCustomer(Customer):&#10;    email_verified: bool = False&#10;    total_bookings: int = 0&#10;    total_spent: int = 0&#10;    last_visit: Optional[datetime] = None&#10;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: Optional[str]&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceBase(BaseModel):&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    image_url: Optional[str] = None&#10;&#10;class CategoryServiceCreate(CategoryServiceBase):&#10;    category_id: str&#10;    staff_ids: List[UUID4] = []  # List of staff member IDs to assign to this service&#10;&#10;class CategoryServiceUpdate(BaseModel):&#10;    category_id: Optional[str] = None  # Allow changing the category&#10;    name: Optional[str] = None&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: Optional[int] = None&#10;    price: Optional[float] = None&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    buffer_before: Optional[int] = None&#10;    buffer_after: Optional[int] = None&#10;    staff_ids: Optional[List[UUID4]] = None  # List of staff member IDs to assign to this service&#10;    image_url: Optional[str] = None&#10;    remove_image: Optional[bool] = False  # Set to True to remove the current image&#10;&#10;&#10;class CompanyCategoryBase(BaseModel):&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    description: Optional[str] = None&#10;    description_en: Optional[str] = None&#10;    description_ee: Optional[str] = None&#10;    description_ru: Optional[str] = None&#10;    parent_category_id: Optional[UUID4] = None&#10;&#10;class CompanyCategoryCreate(CompanyCategoryBase):&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyCategoryUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    description: Optional[str] = None&#10;    description_en: Optional[str] = None&#10;    description_ee: Optional[str] = None&#10;    description_ru: Optional[str] = None&#10;    company_id: Optional[str] = None&#10;    parent_category_id: Optional[UUID4] = None&#10;&#10;class CompanyCategory(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    services_count: int = 0  # Optional field to store the count of services in this category&#10;    has_subcategories: bool = False&#10;&#10;&#10;# Hierarchical category response with subcategories&#10;class CompanyCategoryHierarchical(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    services_count: int = 0&#10;    has_subcategories: bool = False&#10;    subcategories: List['CompanyCategoryHierarchical'] = []&#10;&#10;&#10;# CompanyCategoryWithServicesResponse already exists&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []&#10;    parent_category_id: Optional[UUID4] = None&#10;    subcategories: List['CompanyCategoryWithServicesResponse'] = []&#10;&#10;&#10;# Time Off schemas&#10;class TimeOffBase(BaseModel):&#10;    start_date: datetime&#10;    end_date: datetime&#10;    user_id: UUID4&#10;    reason: Optional[str] = None&#10;&#10;class TimeOffCreate(TimeOffBase):&#10;    pass&#10;&#10;class TimeOffUpdate(BaseModel):&#10;    start_date: Optional[date] = None&#10;    end_date: Optional[date] = None&#10;    reason: Optional[str] = None&#10;&#10;class TimeOff(TimeOffBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user: User&#10;&#10;&#10;class CompanyEmailBase(BaseModel):&#10;    email: EmailStr&#10;    status: EmailStatusType = EmailStatusType.unverified&#10;&#10;class CompanyEmailCreate(BaseModel):&#10;    emails: List[CompanyEmailBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyEmail(CompanyEmailBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyPhoneBase(BaseModel):&#10;    phone: str&#10;    is_primary: bool = False&#10;    status: PhoneStatusType = PhoneStatusType.unverified&#10;&#10;class CompanyPhoneCreate(BaseModel):&#10;    company_phones: List[CompanyPhoneBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyPhone(CompanyPhoneBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;# Company Address schemas&#10;class CompanyAddressBase(BaseModel):&#10;    address: str&#10;    city: str&#10;    zip: Optional[str] = None&#10;    country: str&#10;    is_primary: bool = False&#10;&#10;&#10;class CompanyAddressCreate(CompanyAddressBase):&#10;    pass&#10;&#10;&#10;class CompanyAddressResponse(CompanyAddressBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class NotificationBase(BaseModel):&#10;    type: NotificationType&#10;    message: str&#10;    data: Optional[bytes] = None&#10;    status: NotificationStatus = NotificationStatus.UNREAD&#10;    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))&#10;&#10;&#10;class NotificationCreate(NotificationBase):&#10;    pass&#10;&#10;&#10;class CompanyNotificationCreate(NotificationCreate):&#10;    company_id: Optional[UUID4] = None&#10;&#10;&#10;class NotificationUpdate(BaseModel):&#10;    status: Optional[NotificationStatus] = None&#10;&#10;class Notification(NotificationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyMemberCreate(BaseModel):&#10;    user: UserCreate&#10;    company_id: UUID4&#10;    role: CompanyRoleType&#10;&#10;&#10;# Telegram Integration schemas&#10;class TelegramIntegrationBase(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;&#10;&#10;class TelegramIntegrationCreate(TelegramIntegrationBase):&#10;    bot_token: str&#10;&#10;&#10;class TelegramIntegrationUpdate(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    bot_token: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class TelegramIntegration(TelegramIntegrationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    bot_token: Optional[str] = None  # Decrypted token returned in response&#10;&#10;&#10;# Invitation schemas&#10;class InvitationBase(BaseModel):&#10;    email: str&#10;    role: Optional[CompanyRoleType] = CompanyRoleType.staff&#10;&#10;&#10;class InvitationCreate(InvitationBase):&#10;    pass&#10;&#10;&#10;class InvitationAccept(BaseModel):&#10;    token: str&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    phone: Optional[str] = None&#10;    password: Optional[str] = None  # Only required if user doesn't exist&#10;&#10;&#10;class Invitation(InvitationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    token: Optional[str] = None  # Don't expose token in responses&#10;    status: str&#10;" />
              <option name="updatedContent" value="from datetime import datetime, date, time, timezone&#10;from decimal import Decimal&#10;from typing import Optional, List, Annotated&#10;from pydantic import BaseModel, Field, field_validator, ConfigDict, UUID4, EmailStr&#10;&#10;from app.models import CustomerStatusType, CompanyCategories&#10;from app.models.enums import GenderType, StatusType, PriceType, SourceType, BookingStatus, AvailabilityType, EmailStatusType, PhoneStatusType, NotificationType, NotificationStatus, CompanyRoleType&#10;&#10;&#10;# Base schemas&#10;class TimestampedModel(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;&#10;# Users schemas&#10;class UserBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;    languages: Optional[str] = &quot;English&quot;&#10;    position: Optional[str] = 'Professional'&#10;    profile_photo_url: Optional[str] = None&#10;&#10;&#10;# User Availability schemas&#10;class UserAvailabilityBase(BaseModel):&#10;    day_of_week: int = Field(..., ge=0, le=6, description=&quot;Day of week: 0=Monday, 6=Sunday&quot;)&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool = True&#10;&#10;&#10;class UserAvailabilityCreate(UserAvailabilityBase):&#10;    pass&#10;&#10;&#10;class UserAvailabilityUpdate(BaseModel):&#10;    start_time: Optional[time] = None&#10;    end_time: Optional[time] = None&#10;    is_available: Optional[bool] = None&#10;&#10;&#10;class UserAvailability(UserAvailabilityBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;&#10;class UserCreate(UserBase):&#10;    password: str&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = []&#10;&#10;&#10;class UserUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;    languages: Optional[str] = None&#10;    position: Optional[str] = None&#10;    profile_photo_url: Optional[str] = None&#10;    availabilities: Optional[List[UserAvailabilityCreate]] = None&#10;&#10;&#10;class User(UserBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    company_id: Optional[UUID4] = None&#10;    status: CustomerStatusType&#10;&#10;&#10;class CompanyUser(TimestampedModel):&#10;    id: UUID4&#10;    user_id: UUID4&#10;    company_id: UUID4&#10;    role: str&#10;    status: StatusType&#10;&#10;    user: Optional[User] = None&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;&#10;class CompanyUserUpdate(BaseModel):&#10;    role: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    availabilities: List[UserAvailabilityCreate] = []&#10;&#10;&#10;# Company schemas&#10;class CompanyBase(BaseModel):&#10;    name: str&#10;    type: str&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = 0&#10;    status: StatusType = StatusType.active&#10;    slug: Optional[str] = None&#10;&#10;&#10;class CompanyCreate(CompanyBase):&#10;    pass&#10;&#10;&#10;class CompanyUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    type: Optional[str] = None&#10;    logo_url: Optional[str] = None&#10;    website: Optional[str] = None&#10;    description: Optional[str] = None&#10;    team_size: Optional[int] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class Company(CompanyBase, TimestampedModel):&#10;    id: UUID4&#10;&#10;    model_config = ConfigDict(from_attributes=True, arbitrary_types_allowed=True)&#10;&#10;&#10;# Customer schemas&#10;class CustomerBase(BaseModel):&#10;    first_name: str&#10;    last_name: str&#10;    email: EmailStr&#10;    phone: str&#10;    status: CustomerStatusType = CustomerStatusType.disabled&#10;&#10;&#10;class CustomerCreate(CustomerBase):&#10;    password: str&#10;&#10;&#10;class CustomerUpdate(BaseModel):&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone_number: Optional[str] = None&#10;    birthdate: Optional[date] = None&#10;    gender: Optional[GenderType] = None&#10;    preferred_language: Optional[str] = None&#10;    source: Optional[SourceType] = None&#10;&#10;&#10;class Customer(CustomerBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;    &#10;    id: UUID4&#10;    status: CustomerStatusType&#10;    created_at: datetime&#10;&#10;&#10;# Booking schemas&#10;class BookingBase(BaseModel):&#10;    customer_id: UUID4&#10;    company_id: UUID4&#10;    start_at: datetime&#10;    end_at: datetime&#10;    status: BookingStatus = BookingStatus.SCHEDULED&#10;    notes: Optional[str] = None&#10;&#10;class GuestCustomerInfo(BaseModel):&#10;    id: Optional[UUID4] = None&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    email: Optional[EmailStr] = None&#10;    phone: Optional[str] = None&#10;&#10;class BookingServiceRequest(BaseModel):&#10;    category_service_id: UUID4&#10;    user_id: Optional[UUID4] = None&#10;    notes: Optional[str] = None&#10;&#10;class BookingCreate(BaseModel):&#10;    company_id: Optional[UUID4] = None&#10;    start_time: datetime&#10;    services: List[BookingServiceRequest]&#10;    notes: Optional[str] = None&#10;    customer_info: Optional[GuestCustomerInfo] = None  # For unregistered customers&#10;&#10;&#10;class BookingUpdate(BaseModel):&#10;    start_time: Optional[datetime] = None&#10;    notes: Optional[str] = None&#10;    status: Optional[BookingStatus] = None&#10;    services: Optional[List[BookingServiceRequest]] = None&#10;&#10;&#10;class ServiceStaff(BaseModel):&#10;    &quot;&quot;&quot;Schema for the service_staff junction table linking services to staff members&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;    created_at: datetime&#10;    updated_at: datetime&#10;&#10;    # Optional nested user information&#10;    user: Optional['User'] = None&#10;&#10;&#10;class ServiceStaffCreate(BaseModel):&#10;    &quot;&quot;&quot;Schema for creating service-staff assignments&quot;&quot;&quot;&#10;    service_id: UUID4&#10;    user_id: UUID4&#10;&#10;&#10;class ServiceStaffResponse(BaseModel):&#10;    &quot;&quot;&quot;Simplified response schema for staff assigned to a service&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class CategoryServiceResponse(BaseModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    status: StatusType&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    image_url: Optional[str] = None&#10;    service_staff: Optional[List['ServiceStaff']] = []  # List of staff assigned to this service&#10;&#10;&#10;class StaffMember(BaseModel):&#10;    &quot;&quot;&quot;Simple staff member schema for booking assignments&quot;&quot;&quot;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    first_name: str&#10;    last_name: str&#10;    email: str&#10;    phone: str&#10;&#10;&#10;class BookingService(TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    booking_id: UUID4&#10;    category_service_id: UUID4&#10;    user_id: UUID4&#10;    notes: Optional[str] = None&#10;    start_date: Optional[datetime] = None&#10;    end_date: Optional[datetime] = None&#10;&#10;    category_service: Optional[CategoryServiceResponse] = None&#10;    assigned_staff: Optional[User] = None  # Changed from assigned_staff to match the model relationship&#10;&#10;&#10;class Booking(BookingBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    total_price: int&#10;    customer: Optional[Customer] = None&#10;    booking_services: Optional[List[BookingService]] = []&#10;    user_ids: set[str] = set([])&#10;&#10;&#10;#&#10;class CompanyCustomer(Customer):&#10;    email_verified: bool = False&#10;    total_bookings: int = 0&#10;    total_spent: int = 0&#10;    last_visit: Optional[datetime] = None&#10;&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;# # Enhanced schemas with relationships&#10;# class BusinessWithDetails(Business):&#10;#     owner: Optional[User] = None&#10;#     categories: List[BusinessCategory] = []&#10;#&#10;#&#10;# class ServiceWithDetails(Service):&#10;#     service_type: Optional[ServiceType] = None&#10;#     service_category: Optional[ServiceCategory] = None&#10;#&#10;#&#10;# class BookingWithDetails(Booking):&#10;#     service: Optional[Service] = None&#10;#     client: Optional[Customer] = None&#10;#&#10;&#10;class ResponseMessage(BaseModel):&#10;    message: str&#10;    status: str = &quot;success&quot;&#10;&#10;&#10;class TimeSlot(BaseModel):&#10;    start_time: time&#10;    end_time: time&#10;    is_available: bool&#10;&#10;class DailyAvailability(BaseModel):&#10;    date: date&#10;    time_slots: List[TimeSlot]&#10;&#10;class WeeklyAvailability(BaseModel):&#10;    week_start_date: date&#10;    week_end_date: date&#10;    daily_slots: List[DailyAvailability]&#10;&#10;class MonthlyAvailability(BaseModel):&#10;    month: int&#10;    year: int&#10;    weekly_slots: List[WeeklyAvailability]&#10;&#10;class AvailabilityResponse(BaseModel):&#10;    user_id: Optional[str]&#10;    availability_type: AvailabilityType&#10;    daily: Optional[DailyAvailability] = None&#10;    weekly: Optional[WeeklyAvailability] = None&#10;    monthly: Optional[MonthlyAvailability] = None&#10;&#10;&#10;class CategoryServiceBase(BaseModel):&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: int&#10;    price: float&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;    buffer_before: Optional[int] = 0&#10;    buffer_after: Optional[int] = 0&#10;    image_url: Optional[str] = None&#10;&#10;class CategoryServiceCreate(CategoryServiceBase):&#10;    category_id: str&#10;    staff_ids: List[UUID4] = []  # List of staff member IDs to assign to this service&#10;&#10;class CategoryServiceUpdate(BaseModel):&#10;    category_id: Optional[str] = None  # Allow changing the category&#10;    name: Optional[str] = None&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    duration: Optional[int] = None&#10;    price: Optional[float] = None&#10;    discount_price: Optional[float] = None&#10;    additional_info: Optional[str] = None&#10;    additional_info_en: Optional[str] = None&#10;    additional_info_ee: Optional[str] = None&#10;    additional_info_ru: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;    buffer_before: Optional[int] = None&#10;    buffer_after: Optional[int] = None&#10;    staff_ids: Optional[List[UUID4]] = None  # List of staff member IDs to assign to this service&#10;    image_url: Optional[str] = None&#10;    remove_image: Optional[bool] = False  # Set to True to remove the current image&#10;&#10;&#10;class CompanyCategoryBase(BaseModel):&#10;    name: str&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    description: Optional[str] = None&#10;    description_en: Optional[str] = None&#10;    description_ee: Optional[str] = None&#10;    description_ru: Optional[str] = None&#10;    parent_category_id: Optional[UUID4] = None&#10;&#10;class CompanyCategoryCreate(CompanyCategoryBase):&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyCategoryUpdate(BaseModel):&#10;    name: Optional[str] = None&#10;    name_en: Optional[str] = None&#10;    name_ee: Optional[str] = None&#10;    name_ru: Optional[str] = None&#10;    description: Optional[str] = None&#10;    description_en: Optional[str] = None&#10;    description_ee: Optional[str] = None&#10;    description_ru: Optional[str] = None&#10;    company_id: Optional[str] = None&#10;    parent_category_id: Optional[UUID4] = None&#10;&#10;class CompanyCategory(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    services_count: int = 0  # Optional field to store the count of services in this category&#10;    has_subcategories: bool = False&#10;&#10;&#10;# Hierarchical category response with subcategories&#10;class CompanyCategoryHierarchical(CompanyCategoryBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    services_count: int = 0&#10;    has_subcategories: bool = False&#10;    subcategories: List['CompanyCategoryHierarchical'] = []&#10;&#10;&#10;# CompanyCategoryWithServicesResponse already exists&#10;class CompanyCategoryWithServicesResponse(BaseModel):&#10;    id: UUID4&#10;    name: str&#10;    description: Optional[str] = None&#10;    services: List['CategoryServiceResponse'] = []&#10;    parent_category_id: Optional[UUID4] = None&#10;    subcategories: List['CompanyCategoryWithServicesResponse'] = []&#10;&#10;&#10;# Time Off schemas&#10;class TimeOffBase(BaseModel):&#10;    start_date: datetime&#10;    end_date: datetime&#10;    user_id: UUID4&#10;    reason: Optional[str] = None&#10;&#10;class TimeOffCreate(TimeOffBase):&#10;    pass&#10;&#10;class TimeOffUpdate(BaseModel):&#10;    start_date: Optional[date] = None&#10;    end_date: Optional[date] = None&#10;    reason: Optional[str] = None&#10;&#10;class TimeOff(TimeOffBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    user: User&#10;&#10;&#10;class CompanyEmailBase(BaseModel):&#10;    email: EmailStr&#10;    status: EmailStatusType = EmailStatusType.unverified&#10;&#10;class CompanyEmailCreate(BaseModel):&#10;    emails: List[CompanyEmailBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyEmail(CompanyEmailBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyPhoneBase(BaseModel):&#10;    phone: str&#10;    is_primary: bool = False&#10;    status: PhoneStatusType = PhoneStatusType.unverified&#10;&#10;class CompanyPhoneCreate(BaseModel):&#10;    company_phones: List[CompanyPhoneBase] = []&#10;    company_id: Optional[str] = None&#10;&#10;class CompanyPhone(CompanyPhoneBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;# Company Address schemas&#10;class CompanyAddressBase(BaseModel):&#10;    address: str&#10;    city: str&#10;    zip: Optional[str] = None&#10;    country: str&#10;    is_primary: bool = False&#10;&#10;&#10;class CompanyAddressCreate(CompanyAddressBase):&#10;    pass&#10;&#10;&#10;class CompanyAddressResponse(CompanyAddressBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class NotificationBase(BaseModel):&#10;    type: NotificationType&#10;    message: str&#10;    data: Optional[bytes] = None&#10;    status: NotificationStatus = NotificationStatus.UNREAD&#10;    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))&#10;&#10;&#10;class NotificationCreate(NotificationBase):&#10;    pass&#10;&#10;&#10;class CompanyNotificationCreate(NotificationCreate):&#10;    company_id: Optional[UUID4] = None&#10;&#10;&#10;class NotificationUpdate(BaseModel):&#10;    status: Optional[NotificationStatus] = None&#10;&#10;class Notification(NotificationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;&#10;&#10;class CompanyMemberCreate(BaseModel):&#10;    user: UserCreate&#10;    company_id: UUID4&#10;    role: CompanyRoleType&#10;&#10;&#10;# Telegram Integration schemas&#10;class TelegramIntegrationBase(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    status: StatusType = StatusType.active&#10;&#10;&#10;class TelegramIntegrationCreate(TelegramIntegrationBase):&#10;    bot_token: str&#10;&#10;&#10;class TelegramIntegrationUpdate(BaseModel):&#10;    chat_id: Optional[str] = None&#10;    bot_token: Optional[str] = None&#10;    status: Optional[StatusType] = None&#10;&#10;&#10;class TelegramIntegration(TelegramIntegrationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    bot_token: Optional[str] = None  # Decrypted token returned in response&#10;&#10;&#10;# Invitation schemas&#10;class InvitationBase(BaseModel):&#10;    email: str&#10;    role: Optional[CompanyRoleType] = CompanyRoleType.staff&#10;&#10;&#10;class InvitationCreate(InvitationBase):&#10;    pass&#10;&#10;&#10;class InvitationAccept(BaseModel):&#10;    token: str&#10;    first_name: Optional[str] = None&#10;    last_name: Optional[str] = None&#10;    phone: Optional[str] = None&#10;    password: Optional[str] = None  # Only required if user doesn't exist&#10;&#10;&#10;class Invitation(InvitationBase, TimestampedModel):&#10;    model_config = ConfigDict(from_attributes=True)&#10;&#10;    id: UUID4&#10;    company_id: UUID4&#10;    token: Optional[str] = None  # Don't expose token in responses&#10;    status: str&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/base.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/base.py" />
              <option name="updatedContent" value="from typing import Generic, TypeVar, Type, Any, Optional, List, Union, Dict&#10;from pydantic import BaseModel&#10;from sqlalchemy.orm import Session&#10;from app.db.base_class import BaseModel as DBBaseModel&#10;&#10;ModelType = TypeVar(&quot;ModelType&quot;, bound=DBBaseModel)&#10;CreateSchemaType = TypeVar(&quot;CreateSchemaType&quot;, bound=BaseModel)&#10;UpdateSchemaType = TypeVar(&quot;UpdateSchemaType&quot;, bound=BaseModel)&#10;&#10;class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):&#10;    def __init__(self, model: Type[ModelType]):&#10;        &quot;&quot;&quot;&#10;        CRUD object with default methods to Create, Read, Update, Delete (CRUD).&#10;        **Parameters**&#10;        * `model`: A SQLAlchemy model class&#10;        * `schema`: A Pydantic model (schema) class&#10;        &quot;&quot;&quot;&#10;        self.model = model&#10;&#10;    def get(self, db: Session, id: Any) -&gt; Optional[ModelType]:&#10;        return db.query(self.model).filter(self.model.id == id).first()&#10;&#10;    def get_multi(&#10;        self, db: Session, *, skip: int = 0, limit: int = 100&#10;    ) -&gt; List[ModelType]:&#10;        return db.query(self.model).offset(skip).limit(limit).all()&#10;&#10;    def create(self, db: Session, *, obj_in: CreateSchemaType) -&gt; ModelType:&#10;        obj_in_data = obj_in.model_dump()&#10;        db_obj = self.model(**obj_in_data)&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def update(&#10;        self,&#10;        db: Session,&#10;        *,&#10;        db_obj: ModelType,&#10;        obj_in: Union[UpdateSchemaType, Dict[str, Any]]&#10;    ) -&gt; ModelType:&#10;        obj_data = db_obj.__dict__&#10;        if isinstance(obj_in, dict):&#10;            update_data = obj_in&#10;        else:&#10;            update_data = obj_in.model_dump(exclude_unset=True)&#10;        for field in obj_data:&#10;            if field in update_data:&#10;                setattr(db_obj, field, update_data[field])&#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return db_obj&#10;&#10;    def remove(self, db: Session, *, id: Any) -&gt; ModelType:&#10;        obj = db.query(self.model).get(id)&#10;        db.delete(obj)&#10;        db.commit()&#10;        return obj" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/customer.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/customer.py" />
              <option name="originalContent" value="import uuid&#10;from typing import Optional, List&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy import func&#10;&#10;from app.models import Bookings&#10;from app.models.models import (Customers, CustomerVerifications, CustomerEmails)&#10;from app.models.enums import VerificationStatus, BookingStatus&#10;from app.schemas.schemas import (&#10;    CustomerCreate, CustomerUpdate, CompanyCustomer&#10;)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Customers]:&#10;    return db.query(Customers).filter(Customers.id == id).first()&#10;&#10;def get_by_email(db: Session, email: str) -&gt; Optional[Customers]:&#10;    return db.query(Customers).filter(Customers.email == email).first()&#10;&#10;def create(db: Session, *, obj_in: CustomerCreate) -&gt; Customers:&#10;    db_obj = Customers(**obj_in.model_dump())&#10;    db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def create_customer_email(db: Session, customer_id: int, email: str, status: str) -&gt; CustomerEmails:&#10;    db_obj = CustomerEmails(customer_id=customer_id, email=email, status=status)&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def update(db: Session, *, db_obj: Customers, obj_in: CustomerUpdate) -&gt; Customers:&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;    &#10;    # Ensure updated_at is set to current UTC time&#10;    db_obj.updated_at = utcnow()&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def get_verification_token(db: Session, token: str, type: str) -&gt; Optional[CustomerVerifications]:&#10;    return db.query(CustomerVerifications).filter(CustomerVerifications.token == token,&#10;                                                  CustomerVerifications.type == type).first()&#10;&#10;def verify_token(db: Session, db_obj: CustomerVerifications) -&gt; bool:&#10;    try:&#10;        db_obj.status = VerificationStatus.VERIFIED&#10;        db_obj.used_at = utcnow()&#10;        &#10;        # Update customer's email verification status&#10;        customer = db.query(Customers).filter(Customers.id == db_obj.customer_id).first()&#10;        if customer:&#10;            customer.email_verified = True&#10;            customer.updated_at = utcnow()&#10;            db.add(customer)&#10;        &#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return True&#10;    except Exception:&#10;        db.rollback()&#10;        return False&#10;&#10;def get_company_customers(db: Session, company_id: str) -&gt; List[CompanyCustomer]:&#10;    # Get all unique customers who have bookings with this company&#10;    customers = (&#10;        db.query(Customers)&#10;        .join(Bookings, Customers.id == Bookings.customer_id)&#10;        .filter(Bookings.company_id == company_id)&#10;        .distinct()&#10;        .all()&#10;    )&#10;    &#10;    # Build the response with calculated fields&#10;    result = []&#10;    for customer in customers:&#10;        # Count total bookings for this customer with this company&#10;        total_bookings = (&#10;            db.query(func.count(Bookings.id))&#10;            .filter(&#10;                Bookings.customer_id == customer.id,&#10;                Bookings.company_id == company_id&#10;            )&#10;            .scalar()&#10;        ) or 0&#10;        &#10;        # Calculate total spent from completed bookings only&#10;        total_spent = (&#10;            db.query(func.sum(Bookings.total_price))&#10;            .filter(&#10;                Bookings.customer_id == customer.id,&#10;                Bookings.company_id == company_id,&#10;                Bookings.status == BookingStatus.COMPLETED&#10;            )&#10;            .scalar()&#10;        ) or 0&#10;        &#10;        # Get the last visit date (most recent completed booking)&#10;        last_visit = (&#10;            db.query(func.max(Bookings.end_at))&#10;            .filter(&#10;                Bookings.customer_id == customer.id,&#10;                Bookings.company_id == company_id,&#10;                Bookings.status == BookingStatus.COMPLETED&#10;            )&#10;            .scalar()&#10;        )&#10;        &#10;        # Create CompanyCustomer schema with calculated fields&#10;        company_customer = CompanyCustomer(&#10;            id=customer.id,&#10;            first_name=customer.first_name,&#10;            last_name=customer.last_name,&#10;            email=customer.email,&#10;            phone=customer.phone,&#10;            status=customer.status,&#10;            email_verified=customer.email_verified,&#10;            created_at=customer.created_at,&#10;            updated_at=customer.updated_at,&#10;            total_bookings=total_bookings,&#10;            total_spent=total_spent,&#10;            last_visit=last_visit&#10;        )&#10;        result.append(company_customer)&#10;    &#10;    return result&#10;" />
              <option name="updatedContent" value="import uuid&#10;from typing import Optional, List&#10;&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy import func&#10;&#10;from app.models import Bookings&#10;from app.models.models import (Customers, CustomerVerifications, CustomerEmails)&#10;from app.models.enums import VerificationStatus, BookingStatus&#10;from app.schemas.schemas import (&#10;    CustomerCreate, CustomerUpdate, CompanyCustomer&#10;)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;def get(db: Session, id: UUID4) -&gt; Optional[Customers]:&#10;    return db.query(Customers).filter(Customers.id == id).first()&#10;&#10;def get_by_email(db: Session, email: str) -&gt; Optional[Customers]:&#10;    return db.query(Customers).filter(Customers.email == email).first()&#10;&#10;def create(db: Session, *, obj_in: CustomerCreate) -&gt; Customers:&#10;    db_obj = Customers(**obj_in.model_dump())&#10;    db_obj.id = str(uuid.uuid4())&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def create_customer_email(db: Session, customer_id: int, email: str, status: str) -&gt; CustomerEmails:&#10;    db_obj = CustomerEmails(customer_id=customer_id, email=email, status=status)&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def update(db: Session, *, db_obj: Customers, obj_in: CustomerUpdate) -&gt; Customers:&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;    &#10;    # Ensure updated_at is set to current UTC time&#10;    db_obj.updated_at = utcnow()&#10;    &#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;def get_verification_token(db: Session, token: str, type: str) -&gt; Optional[CustomerVerifications]:&#10;    return db.query(CustomerVerifications).filter(CustomerVerifications.token == token,&#10;                                                  CustomerVerifications.type == type).first()&#10;&#10;def verify_token(db: Session, db_obj: CustomerVerifications) -&gt; bool:&#10;    try:&#10;        db_obj.status = VerificationStatus.VERIFIED&#10;        db_obj.used_at = utcnow()&#10;        &#10;        # Update customer's email verification status&#10;        customer = db.query(Customers).filter(Customers.id == db_obj.customer_id).first()&#10;        if customer:&#10;            customer.email_verified = True&#10;            customer.updated_at = utcnow()&#10;            db.add(customer)&#10;        &#10;        db.add(db_obj)&#10;        db.commit()&#10;        db.refresh(db_obj)&#10;        return True&#10;    except Exception:&#10;        db.rollback()&#10;        return False&#10;&#10;def get_company_customers(db: Session, company_id: str) -&gt; List[CompanyCustomer]:&#10;    # Get all unique customers who have bookings with this company&#10;    customers = (&#10;        db.query(Customers)&#10;        .join(Bookings, Customers.id == Bookings.customer_id)&#10;        .filter(Bookings.company_id == company_id)&#10;        .distinct()&#10;        .all()&#10;    )&#10;    &#10;    # Build the response with calculated fields&#10;    result = []&#10;    for customer in customers:&#10;        # Count total bookings for this customer with this company&#10;        total_bookings = (&#10;            db.query(func.count(Bookings.id))&#10;            .filter(&#10;                Bookings.customer_id == customer.id,&#10;                Bookings.company_id == company_id&#10;            )&#10;            .scalar()&#10;        ) or 0&#10;        &#10;        # Calculate total spent from completed bookings only&#10;        total_spent = (&#10;            db.query(func.sum(Bookings.total_price))&#10;            .filter(&#10;                Bookings.customer_id == customer.id,&#10;                Bookings.company_id == company_id,&#10;                Bookings.status == BookingStatus.COMPLETED&#10;            )&#10;            .scalar()&#10;        ) or 0&#10;        &#10;        # Get the last visit date (most recent completed booking)&#10;        last_visit = (&#10;            db.query(func.max(Bookings.end_at))&#10;            .filter(&#10;                Bookings.customer_id == customer.id,&#10;                Bookings.company_id == company_id,&#10;                Bookings.status == BookingStatus.COMPLETED&#10;            )&#10;            .scalar()&#10;        )&#10;        &#10;        # Create CompanyCustomer schema with calculated fields&#10;        company_customer = CompanyCustomer(&#10;            id=customer.id,&#10;            first_name=customer.first_name,&#10;            last_name=customer.last_name,&#10;            email=customer.email,&#10;            phone=customer.phone,&#10;            status=customer.status,&#10;            email_verified=customer.email_verified,&#10;            created_at=customer.created_at,&#10;            updated_at=customer.updated_at,&#10;            total_bookings=total_bookings,&#10;            total_spent=total_spent,&#10;            last_visit=last_visit&#10;        )&#10;        result.append(company_customer)&#10;    &#10;    return result&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/invitation.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/invitation.py" />
              <option name="originalContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime, timedelta, timezone&#10;from pydantic import UUID4&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy.exc import SQLAlchemyError&#10;&#10;from app.models.models import Invitations, CompanyUsers&#10;from app.schemas.schemas import Invitation&#10;from app.models.enums import InvitationStatus, StatusType, CompanyRoleType&#10;from app.core.datetime_utils import utcnow&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;def create_invitation(&#10;    db: Session,&#10;    company_id: str,&#10;    email: str,&#10;    role: CompanyRoleType = CompanyRoleType.staff,&#10;    token: str = None&#10;) -&gt; Invitation:&#10;    &quot;&quot;&quot;&#10;    Create a new invitation for a staff member.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        email: Email to invite&#10;        role: Role to assign (default: staff)&#10;        token: Invitation token (if not provided, one will be generated)&#10;&#10;    Returns:&#10;        Invitations: The created invitation record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        if not token:&#10;            token = str(uuid.uuid4())&#10;&#10;        # Check if an active invitation already exists for this email and company&#10;        existing = db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id,&#10;            Invitations.status == InvitationStatus.PENDING&#10;        ).first()&#10;&#10;        if existing:&#10;            # Update the existing invitation&#10;            existing.token = token&#10;            existing.role = role&#10;            existing.updated_at = utcnow()&#10;            db.add(existing)&#10;            db.commit()&#10;            db.refresh(existing)&#10;&#10;            return Invitation.model_validate(existing)&#10;&#10;        # Create new invitation&#10;        invitation = Invitations(&#10;            id=str(uuid.uuid4()),&#10;            email=email,&#10;            token=token,&#10;            role=role,&#10;            company_id=company_id,&#10;            status=InvitationStatus.PENDING&#10;        )&#10;        &#10;        db.add(invitation)&#10;        db.commit()&#10;        db.refresh(invitation)&#10;        return Invitation.model_validate(invitation)&#10;&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error creating invitation: {e}&quot;)&#10;        db.rollback()&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Unexpected error creating invitation: {e}&quot;)&#10;        db.rollback()&#10;        raise&#10;&#10;&#10;def get_invitation_by_token(db: Session, token: str) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get an invitation by token.&#10;&#10;    Args:&#10;        db: Database session&#10;        token: Invitation token&#10;&#10;    Returns:&#10;        Invitations: The invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.status == InvitationStatus.PENDING&#10;        ).first()&#10;&#10;        # Check if invitation has expired (older than 3 days)&#10;        if invitation:&#10;            expires_at = invitation.created_at + timedelta(days=3)&#10;            if datetime.now(timezone.utc) &gt; expires_at:&#10;                invitation.status = InvitationStatus.EXPIRED&#10;                db.add(invitation)&#10;                db.commit()&#10;                db.refresh(invitation)&#10;                return None&#10;&#10;        return invitation&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Unexpected error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def get_invitation_by_email_and_company(&#10;    db: Session,&#10;    email: str,&#10;    company_id: UUID4&#10;) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get an invitation by email and company.&#10;&#10;    Args:&#10;        db: Database session&#10;        email: Email address&#10;        company_id: Company ID&#10;&#10;    Returns:&#10;        Invitations: The invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id&#10;        ).first()&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def get_company_invitations(&#10;    db: Session,&#10;    company_id: str,&#10;    status: Optional[InvitationStatus] = None&#10;) -&gt; List[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company, optionally filtered by status.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        status: Optional status filter&#10;&#10;    Returns:&#10;        List[Invitations]: List of invitation records&#10;    &quot;&quot;&quot;&#10;    try:&#10;        query = db.query(Invitations).filter(&#10;            Invitations.company_id == company_id, Invitations.status != 'used'&#10;        )&#10;&#10;        if status:&#10;            query = query.filter(Invitations.status == status)&#10;&#10;        return query.all()&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitations: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def accept_invitation(&#10;    db: Session,&#10;    invitation: Invitations,&#10;    user_id: UUID4&#10;) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Accept an invitation and add user to company.&#10;&#10;    Args:&#10;        db: Database session&#10;        invitation: Invitation record&#10;        user_id: User ID&#10;&#10;    Returns:&#10;        bool: True if successful&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Update invitation status&#10;        invitation.status = InvitationStatus.USED&#10;        invitation.updated_at = utcnow()&#10;        db.add(invitation)&#10;&#10;        # Check if user is already a company member&#10;        existing_member = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == user_id,&#10;            CompanyUsers.company_id == invitation.company_id&#10;        ).first()&#10;&#10;        if not existing_member:&#10;            # Add user to company&#10;            company_user = CompanyUsers(&#10;                id=uuid.uuid4(),&#10;                user_id=user_id,&#10;                company_id=invitation.company_id,&#10;                role=invitation.role,&#10;                status=StatusType.active&#10;            )&#10;            db.add(company_user)&#10;        else:&#10;            # If already a member, update their role and status&#10;            existing_member.role = invitation.role&#10;            existing_member.status = StatusType.active&#10;            db.add(existing_member)&#10;&#10;        db.commit()&#10;        return True&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while accepting invitation: {str(e)}&quot;)&#10;        raise&#10;    except Exception as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Unexpected error while accepting invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def decline_invitation(db: Session, token: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Decline an invitation.&#10;&#10;    Args:&#10;        db: Database session&#10;        token: Invitation token&#10;&#10;    Returns:&#10;        bool: True if successful&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return False&#10;&#10;        invitation.status = InvitationStatus.DECLINED&#10;        invitation.updated_at = utcnow()&#10;        db.add(invitation)&#10;        db.commit()&#10;        return True&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while declining invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def resend_invitation(&#10;    db: Session,&#10;    company_id: UUID4,&#10;    email: str&#10;) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation by generating a new token.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        email: Email address&#10;&#10;    Returns:&#10;        Invitations: The updated invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id,&#10;            Invitations.status.in_([InvitationStatus.PENDING, InvitationStatus.EXPIRED])&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return None&#10;&#10;        # Generate new token and reset to pending&#10;        invitation.token = str(uuid.uuid4())&#10;        invitation.status = InvitationStatus.PENDING&#10;        invitation.created_at = utcnow()&#10;        invitation.updated_at = utcnow()&#10;&#10;        db.add(invitation)&#10;        db.commit()&#10;        db.refresh(invitation)&#10;        return invitation&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while resending invitation: {str(e)}&quot;)&#10;        raise&#10;" />
              <option name="updatedContent" value="import uuid&#10;from typing import Optional, List&#10;from datetime import datetime, timedelta, timezone&#10;from pydantic import UUID4&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy.exc import SQLAlchemyError&#10;&#10;from app.models.models import Invitations, CompanyUsers&#10;from app.schemas.schemas import Invitation&#10;from app.models.enums import InvitationStatus, StatusType, CompanyRoleType&#10;from app.core.datetime_utils import utcnow&#10;import logging&#10;&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;def create_invitation(&#10;    db: Session,&#10;    company_id: str,&#10;    email: str,&#10;    role: CompanyRoleType = CompanyRoleType.staff,&#10;    token: str = None&#10;) -&gt; Invitation:&#10;    &quot;&quot;&quot;&#10;    Create a new invitation for a staff member.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        email: Email to invite&#10;        role: Role to assign (default: staff)&#10;        token: Invitation token (if not provided, one will be generated)&#10;&#10;    Returns:&#10;        Invitations: The created invitation record&#10;    &quot;&quot;&quot;&#10;    try:&#10;        if not token:&#10;            token = str(uuid.uuid4())&#10;&#10;        # Check if an active invitation already exists for this email and company&#10;        existing = db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id,&#10;            Invitations.status == InvitationStatus.PENDING&#10;        ).first()&#10;&#10;        if existing:&#10;            # Update the existing invitation&#10;            existing.token = token&#10;            existing.role = role&#10;            existing.updated_at = utcnow()&#10;            db.add(existing)&#10;            db.commit()&#10;            db.refresh(existing)&#10;&#10;            return Invitation.model_validate(existing)&#10;&#10;        # Create new invitation&#10;        invitation = Invitations(&#10;            id=str(uuid.uuid4()),&#10;            email=email,&#10;            token=token,&#10;            role=role,&#10;            company_id=company_id,&#10;            status=InvitationStatus.PENDING&#10;        )&#10;        &#10;        db.add(invitation)&#10;        db.commit()&#10;        db.refresh(invitation)&#10;        return Invitation.model_validate(invitation)&#10;&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error creating invitation: {e}&quot;)&#10;        db.rollback()&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Unexpected error creating invitation: {e}&quot;)&#10;        db.rollback()&#10;        raise&#10;&#10;&#10;def get_invitation_by_token(db: Session, token: str) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get an invitation by token.&#10;&#10;    Args:&#10;        db: Database session&#10;        token: Invitation token&#10;&#10;    Returns:&#10;        Invitations: The invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token,&#10;            Invitations.status == InvitationStatus.PENDING&#10;        ).first()&#10;&#10;        # Check if invitation has expired (older than 3 days)&#10;        if invitation:&#10;            expires_at = invitation.created_at + timedelta(days=3)&#10;            if datetime.now(timezone.utc) &gt; expires_at:&#10;                invitation.status = InvitationStatus.EXPIRED&#10;                db.add(invitation)&#10;                db.commit()&#10;                db.refresh(invitation)&#10;                return None&#10;&#10;        return invitation&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;    except Exception as e:&#10;        logger.error(f&quot;Unexpected error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def get_invitation_by_email_and_company(&#10;    db: Session,&#10;    email: str,&#10;    company_id: UUID4&#10;) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get an invitation by email and company.&#10;&#10;    Args:&#10;        db: Database session&#10;        email: Email address&#10;        company_id: Company ID&#10;&#10;    Returns:&#10;        Invitations: The invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        return db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id&#10;        ).first()&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def get_company_invitations(&#10;    db: Session,&#10;    company_id: str,&#10;    status: Optional[InvitationStatus] = None&#10;) -&gt; List[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Get all invitations for a company, optionally filtered by status.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        status: Optional status filter&#10;&#10;    Returns:&#10;        List[Invitations]: List of invitation records&#10;    &quot;&quot;&quot;&#10;    try:&#10;        query = db.query(Invitations).filter(&#10;            Invitations.company_id == company_id, Invitations.status != 'used'&#10;        )&#10;&#10;        if status:&#10;            query = query.filter(Invitations.status == status)&#10;&#10;        return query.all()&#10;    except SQLAlchemyError as e:&#10;        logger.error(f&quot;Database error while fetching invitations: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def accept_invitation(&#10;    db: Session,&#10;    invitation: Invitations,&#10;    user_id: UUID4&#10;) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Accept an invitation and add user to company.&#10;&#10;    Args:&#10;        db: Database session&#10;        invitation: Invitation record&#10;        user_id: User ID&#10;&#10;    Returns:&#10;        bool: True if successful&#10;    &quot;&quot;&quot;&#10;    try:&#10;        # Update invitation status&#10;        invitation.status = InvitationStatus.USED&#10;        invitation.updated_at = utcnow()&#10;        db.add(invitation)&#10;&#10;        # Check if user is already a company member&#10;        existing_member = db.query(CompanyUsers).filter(&#10;            CompanyUsers.user_id == user_id,&#10;            CompanyUsers.company_id == invitation.company_id&#10;        ).first()&#10;&#10;        if not existing_member:&#10;            # Add user to company&#10;            company_user = CompanyUsers(&#10;                id=uuid.uuid4(),&#10;                user_id=user_id,&#10;                company_id=invitation.company_id,&#10;                role=invitation.role,&#10;                status=StatusType.active&#10;            )&#10;            db.add(company_user)&#10;        else:&#10;            # If already a member, update their role and status&#10;            existing_member.role = invitation.role&#10;            existing_member.status = StatusType.active&#10;            db.add(existing_member)&#10;&#10;        db.commit()&#10;        return True&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while accepting invitation: {str(e)}&quot;)&#10;        raise&#10;    except Exception as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Unexpected error while accepting invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def decline_invitation(db: Session, token: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Decline an invitation.&#10;&#10;    Args:&#10;        db: Database session&#10;        token: Invitation token&#10;&#10;    Returns:&#10;        bool: True if successful&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.token == token&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return False&#10;&#10;        invitation.status = InvitationStatus.DECLINED&#10;        invitation.updated_at = utcnow()&#10;        db.add(invitation)&#10;        db.commit()&#10;        return True&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while declining invitation: {str(e)}&quot;)&#10;        raise&#10;&#10;&#10;def resend_invitation(&#10;    db: Session,&#10;    company_id: UUID4,&#10;    email: str&#10;) -&gt; Optional[Invitations]:&#10;    &quot;&quot;&quot;&#10;    Resend an invitation by generating a new token.&#10;&#10;    Args:&#10;        db: Database session&#10;        company_id: Company ID&#10;        email: Email address&#10;&#10;    Returns:&#10;        Invitations: The updated invitation record or None if not found&#10;    &quot;&quot;&quot;&#10;    try:&#10;        invitation = db.query(Invitations).filter(&#10;            Invitations.email == email,&#10;            Invitations.company_id == company_id,&#10;            Invitations.status.in_([InvitationStatus.PENDING, InvitationStatus.EXPIRED])&#10;        ).first()&#10;&#10;        if not invitation:&#10;            return None&#10;&#10;        # Generate new token and reset to pending&#10;        invitation.token = str(uuid.uuid4())&#10;        invitation.status = InvitationStatus.PENDING&#10;        invitation.created_at = utcnow()&#10;        invitation.updated_at = utcnow()&#10;&#10;        db.add(invitation)&#10;        db.commit()&#10;        db.refresh(invitation)&#10;        return invitation&#10;    except SQLAlchemyError as e:&#10;        db.rollback()&#10;        logger.error(f&quot;Database error while resending invitation: {str(e)}&quot;)&#10;        raise" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/service.py" />
              <option name="originalContent" value="from typing import Optional, Dict, List&#10;from collections import defaultdict&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy import func&#10;&#10;from app.models.models import CategoryServices, CompanyCategories, ServiceStaff, Users&#10;from app.schemas import CategoryServiceResponse, CompanyCategoryCreate, CompanyCategoryUpdate, CategoryServiceCreate, \&#10;    CategoryServiceUpdate, StaffMember&#10;from app.schemas.schemas import CompanyCategoryWithServicesResponse&#10;&#10;&#10;&#10;#&#10;#     def get_multi_by_business(self, db: Session, business_id: int, skip: int = 0, limit: int = 100) -&gt; List[Service]:&#10;#         return db.query(Service).filter(Service.business_id == business_id).offset(skip).limit(limit).all()&#10;#&#10;#     def create(self, db: Session, *, obj_in: ServiceCreate) -&gt; Service:&#10;#         db_obj = Service(**obj_in.model_dump())&#10;#         db.add(db_obj)&#10;#         db.commit()&#10;#         db.refresh(db_obj)&#10;#         return db_obj&#10;#&#10;#     def update(self, db: Session, *, db_obj: Service, obj_in: ServiceUpdate) -&gt; Service:&#10;#         update_data = obj_in.model_dump(exclude_unset=True)&#10;#         for field, value in update_data.items():&#10;#             setattr(db_obj, field, value)&#10;#         db.add(db_obj)&#10;#         db.commit()&#10;#         db.refresh(db_obj)&#10;#         return db_obj&#10;&#10;&#10;def get_service(db: Session, service_id: str, company_id: str) -&gt; Optional[CategoryServices]:&#10;    &quot;&quot;&quot;&#10;    Get all services for a company grouped by category&#10;    Returns a dictionary where keys are categories and values are lists of services&#10;    &quot;&quot;&quot;&#10;    service = (db.query(CategoryServices)&#10;                .join(CompanyCategories, CategoryServices.category_id==CompanyCategories.id).filter(&#10;                CompanyCategories.company_id == company_id, CategoryServices.id == service_id&#10;    ).one_or_none())&#10;&#10;    return service&#10;&#10;&#10;def get_company_services(db: Session, company_id: str) -&gt; List[CompanyCategoryWithServicesResponse]:&#10;    &quot;&quot;&quot;&#10;    Get all services for a company grouped by category with assigned staff in hierarchical structure&#10;    Returns categories with their services and subcategories&#10;    &quot;&quot;&quot;&#10;    # Get all categories and services for the company&#10;    all_categories = db.query(CompanyCategories).filter(&#10;        CompanyCategories.company_id == company_id&#10;    ).all()&#10;&#10;    # Build a dictionary for quick lookup&#10;    category_dict = {}&#10;    for cat in all_categories:&#10;        category_dict[str(cat.id)] = {&#10;            'category': cat,&#10;            'services': [],&#10;            'subcategories': []&#10;        }&#10;&#10;    # Get all services for the company&#10;    services = (db.query(CategoryServices, CompanyCategories)&#10;                .join(CompanyCategories, CategoryServices.category_id == CompanyCategories.id)&#10;                .filter(CompanyCategories.company_id == company_id)&#10;                .all())&#10;&#10;    # Map services to their categories&#10;    for service, category in services:&#10;        staff_members = get_service_staff(db, service.id)&#10;        service_response = CategoryServiceResponse(&#10;            id=service.id,&#10;            name=service.name,&#10;            name_en=service.name_en,&#10;            name_ee=service.name_ee,&#10;            name_ru=service.name_ru,&#10;            duration=service.duration,&#10;            discount_price=service.discount_price,&#10;            price=service.price,&#10;            additional_info=service.additional_info,&#10;            additional_info_en=service.additional_info_en,&#10;            additional_info_ee=service.additional_info_ee,&#10;            additional_info_ru=service.additional_info_ru,&#10;            status=service.status,&#10;            buffer_before=service.buffer_before,&#10;            buffer_after=service.buffer_after,&#10;            service_staff=staff_members,&#10;            image_url=service.image_url&#10;        )&#10;        category_dict[str(category.id)]['services'].append(service_response)&#10;&#10;    # Build hierarchical structure&#10;    def build_category_hierarchy(cat_data) -&gt; CompanyCategoryWithServicesResponse:&#10;        cat = cat_data['category']&#10;        subcats = []&#10;&#10;        # Find subcategories by looking for categories that have this category as parent&#10;        for other_cat_id, other_cat_data in category_dict.items():&#10;            other_cat = other_cat_data['category']&#10;            if other_cat.parent_category_id and str(other_cat.parent_category_id) == str(cat.id):&#10;                subcats.append(build_category_hierarchy(other_cat_data))&#10;&#10;        return CompanyCategoryWithServicesResponse(&#10;            id=cat.id,&#10;            name=cat.name,&#10;            description=cat.description,&#10;            parent_category_id=cat.parent_category_id,&#10;            services=cat_data['services'],&#10;            subcategories=subcats&#10;        )&#10;&#10;    # Get root categories (no parent) and build hierarchy&#10;    result = []&#10;    for cat_id, cat_data in category_dict.items():&#10;        if cat_data['category'].parent_category_id is None:&#10;            result.append(build_category_hierarchy(cat_data))&#10;&#10;    return result&#10;&#10;&#10;def get_category(db: Session, category_id: str) -&gt; Optional[CompanyCategories]:&#10;    &quot;&quot;&quot;&#10;    Get a specific category by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyCategories).filter(CompanyCategories.id == category_id).first()&#10;&#10;&#10;def create_category(db: Session, obj_in: CompanyCategoryCreate) -&gt; CompanyCategories:&#10;    &quot;&quot;&quot;&#10;    Create a new company category&#10;    &quot;&quot;&quot;&#10;    db_obj = CompanyCategories(&#10;        name=obj_in.name,&#10;        name_en=obj_in.name_en,&#10;        name_ru=obj_in.name_ru,&#10;        name_ee=obj_in.name_ee,&#10;        description_en=obj_in.description_en,&#10;        description_ee=obj_in.description_ee,&#10;        description_ru=obj_in.description_ru,&#10;        company_id=obj_in.company_id,&#10;        parent_category_id=obj_in.parent_category_id&#10;    )&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def update_category(db: Session, db_obj: CompanyCategories, obj_in: CompanyCategoryUpdate) -&gt; CompanyCategories:&#10;    &quot;&quot;&quot;&#10;    Update an existing company category&#10;    &quot;&quot;&quot;&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def delete_category(db: Session, category_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company category&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyCategories).filter(CompanyCategories.id == category_id, CompanyCategories.company_id==company_id).first()&#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def get_company_categories(db: Session, company_id: str) -&gt; List[CompanyCategories]:&#10;    &quot;&quot;&quot;&#10;    Get all categories for a specific company with services count&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyCategories).filter(CompanyCategories.company_id == company_id).all()&#10;&#10;&#10;def get_company_categories_hierarchical(db: Session, company_id: str):&#10;    &quot;&quot;&quot;&#10;    Get all categories for a company in hierarchical structure (parent categories with their subcategories)&#10;    Returns only root categories (those without parent_category_id) with nested subcategories&#10;    &quot;&quot;&quot;&#10;    from app.schemas.schemas import CompanyCategoryHierarchical&#10;&#10;    # Get all categories for the company&#10;    all_categories = db.query(CompanyCategories).filter(&#10;        CompanyCategories.company_id == company_id&#10;    ).all()&#10;&#10;    # Build a dictionary for quick lookup&#10;    category_dict = {str(cat.id): cat for cat in all_categories}&#10;&#10;    # Build hierarchical structure&#10;    def build_hierarchy(category: CompanyCategories) -&gt; CompanyCategoryHierarchical:&#10;        subcats = [build_hierarchy(category_dict[str(sub.id)])&#10;                   for sub in category.subcategories if str(sub.id) in category_dict]&#10;&#10;        return CompanyCategoryHierarchical(&#10;            id=category.id,&#10;            company_id=category.company_id,&#10;            parent_category_id=category.parent_category_id,&#10;            name=category.name,&#10;            name_en=category.name_en,&#10;            name_ee=category.name_ee,&#10;            name_ru=category.name_ru,&#10;            description=category.description,&#10;            description_en=category.description_en,&#10;            description_ee=category.description_ee,&#10;            description_ru=category.description_ru,&#10;            created_at=category.created_at,&#10;            updated_at=category.updated_at,&#10;            services_count=category.services_count,&#10;            has_subcategories=category.has_subcategories,&#10;            subcategories=subcats&#10;        )&#10;&#10;    # Get root categories (no parent)&#10;    root_categories = [cat for cat in all_categories if cat.parent_category_id is None]&#10;&#10;    # Build hierarchy for each root&#10;    return [build_hierarchy(cat) for cat in root_categories]&#10;&#10;&#10;def category_has_subcategories(db: Session, category_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if a category has any subcategories&#10;    &quot;&quot;&quot;&#10;    count = db.query(CompanyCategories).filter(&#10;        CompanyCategories.parent_category_id == category_id&#10;    ).count()&#10;    return count &gt; 0&#10;&#10;&#10;def validate_service_category(db: Session, category_id: str) -&gt; tuple[bool, str]:&#10;    &quot;&quot;&quot;&#10;    Validate if services can be added to this category.&#10;    Returns (is_valid, error_message)&#10;&#10;    Rules:&#10;    - Services can only be added to categories that don't have subcategories&#10;    &quot;&quot;&quot;&#10;    category = get_category(db, category_id)&#10;    if not category:&#10;        return False, &quot;Category not found&quot;&#10;&#10;    if category_has_subcategories(db, category_id):&#10;        return False, &quot;Cannot add services to a category that has subcategories. Please add services to the subcategories instead.&quot;&#10;&#10;    return True, &quot;&quot;&#10;&#10;&#10;def create_service(db: Session, obj_in: CategoryServiceCreate) -&gt; CategoryServices:&#10;    &quot;&quot;&quot;&#10;    Create a new service within a category&#10;    Validates that the category doesn't have subcategories&#10;    &quot;&quot;&quot;&#10;    # Validate category before creating service&#10;    is_valid, error_msg = validate_service_category(db, str(obj_in.category_id))&#10;    if not is_valid:&#10;        raise ValueError(error_msg)&#10;&#10;    db_obj = CategoryServices(&#10;        category_id=obj_in.category_id,&#10;        name=obj_in.name,&#10;        name_en=obj_in.name_en,&#10;        name_ee=obj_in.name_ee,&#10;        name_ru=obj_in.name_ru,&#10;        duration=obj_in.duration,&#10;        price=int(obj_in.price * 100),  # Store price in cents&#10;        discount_price=int(obj_in.discount_price * 100),&#10;        additional_info_ee=obj_in.additional_info_ee,&#10;        additional_info_en=obj_in.additional_info_en,&#10;        additional_info_ru=obj_in.additional_info_ru,&#10;        status=obj_in.status,&#10;        buffer_before=obj_in.buffer_before,&#10;        buffer_after=obj_in.buffer_after,&#10;        image_url=obj_in.image_url&#10;    )&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    # Assign staff members to the service&#10;    if obj_in.staff_ids:&#10;        assign_staff_to_service(db, db_obj.id, obj_in.staff_ids)&#10;&#10;    return db_obj&#10;&#10;&#10;def update_service(db: Session, db_obj: CategoryServices, obj_in: CategoryServiceUpdate) -&gt; CategoryServices:&#10;    &quot;&quot;&quot;&#10;    Update an existing service&#10;    Validates category if being changed&#10;    &quot;&quot;&quot;&#10;    # Validate new category if provided&#10;    if obj_in.category_id and str(obj_in.category_id) != str(db_obj.category_id):&#10;        is_valid, error_msg = validate_service_category(db, str(obj_in.category_id))&#10;        if not is_valid:&#10;            raise ValueError(error_msg)&#10;&#10;    # Handle price conversion&#10;    if obj_in.price is not None:&#10;        obj_in.price = int(obj_in.price * 100)&#10;    if obj_in.discount_price is not None:&#10;        obj_in.discount_price = int(obj_in.discount_price * 100)&#10;&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;&#10;    # Handle staff_ids and remove_image separately&#10;    staff_ids = update_data.pop('staff_ids', None)&#10;    remove_image = update_data.pop('remove_image', False)&#10;&#10;    # Handle image removal&#10;    if remove_image:&#10;        update_data['image_url'] = None&#10;&#10;    # Update service fields&#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    # Update staff assignments if provided&#10;    if staff_ids is not None:&#10;        # Remove existing assignments&#10;        db.query(ServiceStaff).filter(ServiceStaff.service_id == db_obj.id).delete()&#10;        db.commit()&#10;&#10;        # Add new assignments&#10;        if staff_ids:&#10;            assign_staff_to_service(db, db_obj.id, staff_ids)&#10;&#10;    return db_obj&#10;&#10;&#10;def assign_staff_to_service(db: Session, service_id: UUID4, staff_ids: List[UUID4]) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Assign multiple staff members to a service&#10;    &quot;&quot;&quot;&#10;    for staff_id in staff_ids:&#10;        # Check if assignment already exists&#10;        existing = db.query(ServiceStaff).filter(&#10;            ServiceStaff.service_id == service_id,&#10;            ServiceStaff.user_id == staff_id&#10;        ).first()&#10;&#10;        if not existing:&#10;            staff_assignment = ServiceStaff(&#10;                service_id=service_id,&#10;                user_id=staff_id&#10;            )&#10;            db.add(staff_assignment)&#10;&#10;    db.commit()&#10;&#10;&#10;def get_service_staff(db: Session, service_id: UUID4) -&gt; List[ServiceStaff]:&#10;    &quot;&quot;&quot;&#10;    Get all staff members assigned to a service&#10;    &quot;&quot;&quot;&#10;    staff = (db.query(ServiceStaff)&#10;             .filter(ServiceStaff.service_id == service_id)&#10;             .all())&#10;    return staff&#10;&#10;&#10;def remove_staff_from_service(db: Session, service_id: UUID4, staff_id: UUID4) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Remove a staff member from a service&#10;    &quot;&quot;&quot;&#10;    assignment = db.query(ServiceStaff).filter(&#10;        ServiceStaff.service_id == service_id,&#10;        ServiceStaff.user_id == staff_id&#10;    ).first()&#10;&#10;    if assignment:&#10;        db.delete(assignment)&#10;        db.commit()&#10;        return True&#10;    return False&#10;&#10;&#10;def delete_service(db: Session, service_id: UUID4, company_id: Optional[UUID4] = None) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a service and any staff assignments tied to it.&#10;&#10;    If company_id is provided, ensure the service belongs to a category for that company&#10;    before deleting (extra safety).&#10;&#10;    Returns True when deletion happened, False when the service was not found or the&#10;    company check failed.&#10;    &quot;&quot;&quot;&#10;    # If company_id is provided, ensure the service belongs to that company&#10;    if company_id:&#10;        service = (db.query(CategoryServices)&#10;                   .join(CompanyCategories, CategoryServices.category_id == CompanyCategories.id)&#10;                   .filter(CategoryServices.id == service_id, CompanyCategories.company_id == company_id)&#10;                   .one_or_none())&#10;    else:&#10;        service = db.query(CategoryServices).filter(CategoryServices.id == service_id).one_or_none()&#10;&#10;    if not service:&#10;        return False&#10;&#10;    # Remove any ServiceStaff assignments for this service&#10;    db.query(ServiceStaff).filter(ServiceStaff.service_id == service_id).delete(synchronize_session=False)&#10;&#10;    # Delete the service itself&#10;    db.delete(service)&#10;    db.commit()&#10;    return True&#10;" />
              <option name="updatedContent" value="from typing import Optional, Dict, List&#10;from collections import defaultdict&#10;from pydantic.v1 import UUID4&#10;from sqlalchemy.orm import Session&#10;from sqlalchemy import func&#10;&#10;from app.models.models import CategoryServices, CompanyCategories, ServiceStaff, Users&#10;from app.schemas import CategoryServiceResponse, CompanyCategoryCreate, CompanyCategoryUpdate, CategoryServiceCreate, \&#10;    CategoryServiceUpdate, StaffMember&#10;from app.schemas.schemas import CompanyCategoryWithServicesResponse&#10;&#10;&#10;&#10;#&#10;#     def get_multi_by_business(self, db: Session, business_id: int, skip: int = 0, limit: int = 100) -&gt; List[Service]:&#10;#         return db.query(Service).filter(Service.business_id == business_id).offset(skip).limit(limit).all()&#10;#&#10;#     def create(self, db: Session, *, obj_in: ServiceCreate) -&gt; Service:&#10;#         db_obj = Service(**obj_in.model_dump())&#10;#         db.add(db_obj)&#10;#         db.commit()&#10;#         db.refresh(db_obj)&#10;#         return db_obj&#10;#&#10;#     def update(self, db: Session, *, db_obj: Service, obj_in: ServiceUpdate) -&gt; Service:&#10;#         update_data = obj_in.model_dump(exclude_unset=True)&#10;#         for field, value in update_data.items():&#10;#             setattr(db_obj, field, value)&#10;#         db.add(db_obj)&#10;#         db.commit()&#10;#         db.refresh(db_obj)&#10;#         return db_obj&#10;&#10;&#10;def get_service(db: Session, service_id: str, company_id: str) -&gt; Optional[CategoryServices]:&#10;    &quot;&quot;&quot;&#10;    Get all services for a company grouped by category&#10;    Returns a dictionary where keys are categories and values are lists of services&#10;    &quot;&quot;&quot;&#10;    service = (db.query(CategoryServices)&#10;                .join(CompanyCategories, CategoryServices.category_id==CompanyCategories.id).filter(&#10;                CompanyCategories.company_id == company_id, CategoryServices.id == service_id&#10;    ).one_or_none())&#10;&#10;    return service&#10;&#10;&#10;def get_company_services(db: Session, company_id: str) -&gt; List[CompanyCategoryWithServicesResponse]:&#10;    &quot;&quot;&quot;&#10;    Get all services for a company grouped by category with assigned staff in hierarchical structure&#10;    Returns categories with their services and subcategories&#10;    &quot;&quot;&quot;&#10;    # Get all categories and services for the company&#10;    all_categories = db.query(CompanyCategories).filter(&#10;        CompanyCategories.company_id == company_id&#10;    ).all()&#10;&#10;    # Build a dictionary for quick lookup&#10;    category_dict = {}&#10;    for cat in all_categories:&#10;        category_dict[str(cat.id)] = {&#10;            'category': cat,&#10;            'services': [],&#10;            'subcategories': []&#10;        }&#10;&#10;    # Get all services for the company&#10;    services = (db.query(CategoryServices, CompanyCategories)&#10;                .join(CompanyCategories, CategoryServices.category_id == CompanyCategories.id)&#10;                .filter(CompanyCategories.company_id == company_id)&#10;                .all())&#10;&#10;    # Map services to their categories&#10;    for service, category in services:&#10;        staff_members = get_service_staff(db, service.id)&#10;        service_response = CategoryServiceResponse(&#10;            id=service.id,&#10;            name=service.name,&#10;            name_en=service.name_en,&#10;            name_ee=service.name_ee,&#10;            name_ru=service.name_ru,&#10;            duration=service.duration,&#10;            discount_price=service.discount_price,&#10;            price=service.price,&#10;            additional_info=service.additional_info,&#10;            additional_info_en=service.additional_info_en,&#10;            additional_info_ee=service.additional_info_ee,&#10;            additional_info_ru=service.additional_info_ru,&#10;            status=service.status,&#10;            buffer_before=service.buffer_before,&#10;            buffer_after=service.buffer_after,&#10;            service_staff=staff_members,&#10;            image_url=service.image_url&#10;        )&#10;        category_dict[str(category.id)]['services'].append(service_response)&#10;&#10;    # Build hierarchical structure&#10;    def build_category_hierarchy(cat_data) -&gt; CompanyCategoryWithServicesResponse:&#10;        cat = cat_data['category']&#10;        subcats = []&#10;&#10;        # Find subcategories by looking for categories that have this category as parent&#10;        for other_cat_id, other_cat_data in category_dict.items():&#10;            other_cat = other_cat_data['category']&#10;            if other_cat.parent_category_id and str(other_cat.parent_category_id) == str(cat.id):&#10;                subcats.append(build_category_hierarchy(other_cat_data))&#10;&#10;        return CompanyCategoryWithServicesResponse(&#10;            id=cat.id,&#10;            name=cat.name,&#10;            description=cat.description,&#10;            parent_category_id=cat.parent_category_id,&#10;            services=cat_data['services'],&#10;            subcategories=subcats&#10;        )&#10;&#10;    # Get root categories (no parent) and build hierarchy&#10;    result = []&#10;    for cat_id, cat_data in category_dict.items():&#10;        if cat_data['category'].parent_category_id is None:&#10;            result.append(build_category_hierarchy(cat_data))&#10;&#10;    return result&#10;&#10;&#10;def get_category(db: Session, category_id: str) -&gt; Optional[CompanyCategories]:&#10;    &quot;&quot;&quot;&#10;    Get a specific category by ID&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyCategories).filter(CompanyCategories.id == category_id).first()&#10;&#10;&#10;def create_category(db: Session, obj_in: CompanyCategoryCreate) -&gt; CompanyCategories:&#10;    &quot;&quot;&quot;&#10;    Create a new company category&#10;    &quot;&quot;&quot;&#10;    db_obj = CompanyCategories(&#10;        name=obj_in.name,&#10;        name_en=obj_in.name_en,&#10;        name_ru=obj_in.name_ru,&#10;        name_ee=obj_in.name_ee,&#10;        description_en=obj_in.description_en,&#10;        description_ee=obj_in.description_ee,&#10;        description_ru=obj_in.description_ru,&#10;        company_id=obj_in.company_id,&#10;        parent_category_id=obj_in.parent_category_id&#10;    )&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def update_category(db: Session, db_obj: CompanyCategories, obj_in: CompanyCategoryUpdate) -&gt; CompanyCategories:&#10;    &quot;&quot;&quot;&#10;    Update an existing company category&#10;    &quot;&quot;&quot;&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;    return db_obj&#10;&#10;&#10;def delete_category(db: Session, category_id: str, company_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a company category&#10;    &quot;&quot;&quot;&#10;    db_obj = db.query(CompanyCategories).filter(CompanyCategories.id == category_id, CompanyCategories.company_id==company_id).first()&#10;    if not db_obj:&#10;        return False&#10;&#10;    db.delete(db_obj)&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def get_company_categories(db: Session, company_id: str) -&gt; List[CompanyCategories]:&#10;    &quot;&quot;&quot;&#10;    Get all categories for a specific company with services count&#10;    &quot;&quot;&quot;&#10;    return db.query(CompanyCategories).filter(CompanyCategories.company_id == company_id).all()&#10;&#10;&#10;def get_company_categories_hierarchical(db: Session, company_id: str):&#10;    &quot;&quot;&quot;&#10;    Get all categories for a company in hierarchical structure (parent categories with their subcategories)&#10;    Returns only root categories (those without parent_category_id) with nested subcategories&#10;    &quot;&quot;&quot;&#10;    from app.schemas.schemas import CompanyCategoryHierarchical&#10;&#10;    # Get all categories for the company&#10;    all_categories = db.query(CompanyCategories).filter(&#10;        CompanyCategories.company_id == company_id&#10;    ).all()&#10;&#10;    # Build a dictionary for quick lookup&#10;    category_dict = {str(cat.id): cat for cat in all_categories}&#10;&#10;    # Build hierarchical structure&#10;    def build_hierarchy(category: CompanyCategories) -&gt; CompanyCategoryHierarchical:&#10;        subcats = [build_hierarchy(category_dict[str(sub.id)])&#10;                   for sub in category.subcategories if str(sub.id) in category_dict]&#10;&#10;        return CompanyCategoryHierarchical(&#10;            id=category.id,&#10;            company_id=category.company_id,&#10;            parent_category_id=category.parent_category_id,&#10;            name=category.name,&#10;            name_en=category.name_en,&#10;            name_ee=category.name_ee,&#10;            name_ru=category.name_ru,&#10;            description=category.description,&#10;            description_en=category.description_en,&#10;            description_ee=category.description_ee,&#10;            description_ru=category.description_ru,&#10;            created_at=category.created_at,&#10;            updated_at=category.updated_at,&#10;            services_count=category.services_count,&#10;            has_subcategories=category.has_subcategories,&#10;            subcategories=subcats&#10;        )&#10;&#10;    # Get root categories (no parent)&#10;    root_categories = [cat for cat in all_categories if cat.parent_category_id is None]&#10;&#10;    # Build hierarchy for each root&#10;    return [build_hierarchy(cat) for cat in root_categories]&#10;&#10;&#10;def category_has_subcategories(db: Session, category_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Check if a category has any subcategories&#10;    &quot;&quot;&quot;&#10;    count = db.query(CompanyCategories).filter(&#10;        CompanyCategories.parent_category_id == category_id&#10;    ).count()&#10;    return count &gt; 0&#10;&#10;&#10;def validate_service_category(db: Session, category_id: str) -&gt; tuple[bool, str]:&#10;    &quot;&quot;&quot;&#10;    Validate if services can be added to this category.&#10;    Returns (is_valid, error_message)&#10;&#10;    Rules:&#10;    - Services can only be added to categories that don't have subcategories&#10;    &quot;&quot;&quot;&#10;    category = get_category(db, category_id)&#10;    if not category:&#10;        return False, &quot;Category not found&quot;&#10;&#10;    if category_has_subcategories(db, category_id):&#10;        return False, &quot;Cannot add services to a category that has subcategories. Please add services to the subcategories instead.&quot;&#10;&#10;    return True, &quot;&quot;&#10;&#10;&#10;def create_service(db: Session, obj_in: CategoryServiceCreate) -&gt; CategoryServices:&#10;    &quot;&quot;&quot;&#10;    Create a new service within a category&#10;    Validates that the category doesn't have subcategories&#10;    &quot;&quot;&quot;&#10;    # Validate category before creating service&#10;    is_valid, error_msg = validate_service_category(db, str(obj_in.category_id))&#10;    if not is_valid:&#10;        raise ValueError(error_msg)&#10;&#10;    db_obj = CategoryServices(&#10;        category_id=obj_in.category_id,&#10;        name=obj_in.name,&#10;        name_en=obj_in.name_en,&#10;        name_ee=obj_in.name_ee,&#10;        name_ru=obj_in.name_ru,&#10;        duration=obj_in.duration,&#10;        price=int(obj_in.price * 100),  # Store price in cents&#10;        discount_price=int(obj_in.discount_price * 100),&#10;        additional_info_ee=obj_in.additional_info_ee,&#10;        additional_info_en=obj_in.additional_info_en,&#10;        additional_info_ru=obj_in.additional_info_ru,&#10;        status=obj_in.status,&#10;        buffer_before=obj_in.buffer_before,&#10;        buffer_after=obj_in.buffer_after,&#10;        image_url=obj_in.image_url&#10;    )&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    # Assign staff members to the service&#10;    if obj_in.staff_ids:&#10;        assign_staff_to_service(db, db_obj.id, obj_in.staff_ids)&#10;&#10;    return db_obj&#10;&#10;&#10;def update_service(db: Session, db_obj: CategoryServices, obj_in: CategoryServiceUpdate) -&gt; CategoryServices:&#10;    &quot;&quot;&quot;&#10;    Update an existing service&#10;    Validates category if being changed&#10;    &quot;&quot;&quot;&#10;    # Validate new category if provided&#10;    if obj_in.category_id and str(obj_in.category_id) != str(db_obj.category_id):&#10;        is_valid, error_msg = validate_service_category(db, str(obj_in.category_id))&#10;        if not is_valid:&#10;            raise ValueError(error_msg)&#10;&#10;    # Handle price conversion&#10;    if obj_in.price is not None:&#10;        obj_in.price = int(obj_in.price * 100)&#10;    if obj_in.discount_price is not None:&#10;        obj_in.discount_price = int(obj_in.discount_price * 100)&#10;&#10;    update_data = obj_in.model_dump(exclude_unset=True)&#10;&#10;    # Handle staff_ids and remove_image separately&#10;    staff_ids = update_data.pop('staff_ids', None)&#10;    remove_image = update_data.pop('remove_image', False)&#10;&#10;    # Handle image removal&#10;    if remove_image:&#10;        update_data['image_url'] = None&#10;&#10;    # Update service fields&#10;    for field, value in update_data.items():&#10;        setattr(db_obj, field, value)&#10;&#10;    db.add(db_obj)&#10;    db.commit()&#10;    db.refresh(db_obj)&#10;&#10;    # Update staff assignments if provided&#10;    if staff_ids is not None:&#10;        # Remove existing assignments&#10;        db.query(ServiceStaff).filter(ServiceStaff.service_id == db_obj.id).delete()&#10;        db.commit()&#10;&#10;        # Add new assignments&#10;        if staff_ids:&#10;            assign_staff_to_service(db, db_obj.id, staff_ids)&#10;&#10;    return db_obj&#10;&#10;&#10;def assign_staff_to_service(db: Session, service_id: UUID4, staff_ids: List[UUID4]) -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Assign multiple staff members to a service&#10;    &quot;&quot;&quot;&#10;    for staff_id in staff_ids:&#10;        # Check if assignment already exists&#10;        existing = db.query(ServiceStaff).filter(&#10;            ServiceStaff.service_id == service_id,&#10;            ServiceStaff.user_id == staff_id&#10;        ).first()&#10;&#10;        if not existing:&#10;            staff_assignment = ServiceStaff(&#10;                service_id=service_id,&#10;                user_id=staff_id&#10;            )&#10;            db.add(staff_assignment)&#10;&#10;    db.commit()&#10;&#10;&#10;def get_service_staff(db: Session, service_id: UUID4) -&gt; List[ServiceStaff]:&#10;    &quot;&quot;&quot;&#10;    Get all staff members assigned to a service&#10;    &quot;&quot;&quot;&#10;    staff = (db.query(ServiceStaff)&#10;             .filter(ServiceStaff.service_id == service_id)&#10;             .all())&#10;    return staff&#10;&#10;&#10;def remove_staff_from_service(db: Session, service_id: UUID4, staff_id: UUID4) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Remove a staff member from a service&#10;    &quot;&quot;&quot;&#10;    assignment = db.query(ServiceStaff).filter(&#10;        ServiceStaff.service_id == service_id,&#10;        ServiceStaff.user_id == staff_id&#10;    ).first()&#10;&#10;    if assignment:&#10;        db.delete(assignment)&#10;        db.commit()&#10;        return True&#10;    return False&#10;&#10;&#10;def delete_service(db: Session, service_id: UUID4, company_id: Optional[UUID4] = None) -&gt; bool:&#10;    &quot;&quot;&quot;&#10;    Delete a service and any staff assignments tied to it.&#10;&#10;    If company_id is provided, ensure the service belongs to a category for that company&#10;    before deleting (extra safety).&#10;&#10;    Returns True when deletion happened, False when the service was not found or the&#10;    company check failed.&#10;    &quot;&quot;&quot;&#10;    # If company_id is provided, ensure the service belongs to that company&#10;    if company_id:&#10;        service = (db.query(CategoryServices)&#10;                   .join(CompanyCategories, CategoryServices.category_id == CompanyCategories.id)&#10;                   .filter(CategoryServices.id == service_id, CompanyCategories.company_id == company_id)&#10;                   .one_or_none())&#10;    else:&#10;        service = db.query(CategoryServices).filter(CategoryServices.id == service_id).one_or_none()&#10;&#10;    if not service:&#10;        return False&#10;&#10;    # Remove any ServiceStaff assignments for this service&#10;    db.query(ServiceStaff).filter(ServiceStaff.service_id == service_id).delete(synchronize_session=False)&#10;&#10;    # Delete the service itself&#10;    db.delete(service)&#10;    db.commit()&#10;    return True&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/services/crud/user_availability.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/services/crud/user_availability.py" />
              <option name="originalContent" value="from typing import List, Optional, Any&#10;from datetime import datetime, date, time, timedelta&#10;from sqlalchemy.orm import Session&#10;import uuid&#10;from app.models.models import UserAvailabilities, UserTimeOffs&#10;from app.models.enums import AvailabilityType&#10;from app.schemas.schemas import (&#10;    TimeSlot,&#10;    DailyAvailability,&#10;    WeeklyAvailability,&#10;    MonthlyAvailability,&#10;    AvailabilityResponse,&#10;    UserAvailabilityCreate&#10;)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;def create_user_availability(db: Session, user_id: str, availability_in: UserAvailabilityCreate) -&gt; UserAvailabilities:&#10;    &quot;&quot;&quot;Create a new availability entry for a user&quot;&quot;&quot;&#10;    db_availability = UserAvailabilities(&#10;        id=str(uuid.uuid4()),&#10;        user_id=user_id,&#10;        day_of_week=availability_in.day_of_week,&#10;        start_time=availability_in.start_time,&#10;        end_time=availability_in.end_time,&#10;        is_available=availability_in.is_available,&#10;        created_at=utcnow(),&#10;        updated_at=utcnow()&#10;    )&#10;    db.add(db_availability)&#10;    db.commit()&#10;    db.refresh(db_availability)&#10;    return db_availability&#10;&#10;&#10;def bulk_create_user_availabilities(db: Session, user_id: str, availabilities: List[UserAvailabilityCreate]) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Create multiple availability entries for a user&quot;&quot;&quot;&#10;    db_availabilities = []&#10;    for availability_in in availabilities:&#10;        db_availability = UserAvailabilities(&#10;            id=str(uuid.uuid4()),&#10;            user_id=user_id,&#10;            day_of_week=availability_in.day_of_week,&#10;            start_time=availability_in.start_time,&#10;            end_time=availability_in.end_time,&#10;            is_available=availability_in.is_available,&#10;            created_at=utcnow(),&#10;            updated_at=utcnow()&#10;        )&#10;        db_availabilities.append(db_availability)&#10;    &#10;    db.add_all(db_availabilities)&#10;    db.commit()&#10;    for db_availability in db_availabilities:&#10;        db.refresh(db_availability)&#10;    return db_availabilities&#10;&#10;&#10;def delete_user_availabilities(db: Session, user_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;Delete all availability entries for a user&quot;&quot;&quot;&#10;    db.query(UserAvailabilities).filter(UserAvailabilities.user_id == user_id).delete()&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def update_user_availabilities(db: Session, user_id: str, availabilities: List[UserAvailabilityCreate]) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Replace all availability entries for a user with new ones&quot;&quot;&quot;&#10;    # Delete existing availabilities&#10;    delete_user_availabilities(db, user_id)&#10;    &#10;    # Create new availabilities&#10;    if availabilities:&#10;        return bulk_create_user_availabilities(db, user_id, availabilities)&#10;    return []&#10;&#10;&#10;def get_user_availabilities(db: Session, user_id: str) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Get all availability entries for a user&quot;&quot;&quot;&#10;    return list(db.query(UserAvailabilities).filter(UserAvailabilities.user_id == user_id,&#10;                                                    UserAvailabilities.is_available == True).all())&#10;&#10;def get_user_time_offs(&#10;    db: Session,&#10;    user_id: str,&#10;    start_date: date,&#10;    end_date: date&#10;) -&gt; List[&quot;UserTimeOffs&quot;]:&#10;    &quot;&quot;&quot;Get all time-offs for a user within a date range&quot;&quot;&quot;&#10;    return db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date).all()&#10;&#10;def get_all_availabilities(db: Session):&#10;    &quot;&quot;&quot;Get all available user availabilities&quot;&quot;&quot;&#10;    return db.query(UserAvailabilities).filter(UserAvailabilities.is_available == True).all()&#10;&#10;def get_all_time_offs(db: Session, start_date: date, end_date: date):&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all()&#10;&#10;def subtract_intervals(base_start: time, base_end: time, intervals: List[tuple]) -&gt; List[tuple]:&#10;    &quot;&quot;&quot;Subtract intervals (bookings/time-offs) from a base interval. Returns list of available intervals.&quot;&quot;&quot;&#10;    result = [(base_start, base_end)]&#10;    for interval_start, interval_end in intervals:&#10;        new_result = []&#10;        for avail_start, avail_end in result:&#10;            # If no overlap, keep as is&#10;            if interval_end &lt;= avail_start or interval_start &gt;= avail_end:&#10;                new_result.append((avail_start, avail_end))&#10;            else:&#10;                # Overlap: split interval&#10;                if interval_start &gt; avail_start:&#10;                    new_result.append((avail_start, interval_start))&#10;                if interval_end &lt; avail_end:&#10;                    new_result.append((interval_end, avail_end))&#10;        result = new_result&#10;    return result&#10;&#10;def get_daily_slots(target_date: date, availabilities: List[UserAvailabilities], time_offs: List[UserTimeOffs], bookings: List[Any], service_duration_minutes: Optional[int] = None) -&gt; DailyAvailability:&#10;    day_of_week = target_date.weekday()&#10;    day_availabilities = [a for a in availabilities if a.day_of_week == day_of_week]&#10;    # Collect intervals to subtract (bookings and time-offs)&#10;    subtract_intervals_list = []&#10;    for time_off, user_id in time_offs:&#10;        if time_off.start_date.date() &lt;= target_date &lt;= time_off.end_date.date():&#10;            subtract_intervals_list.append((time(time_off.start_date.hour,time_off.start_date.minute),&#10;                                            time(time_off.end_date.hour,time_off.end_date.minute)))&#10;    for booking in bookings:&#10;        if booking.start_at.date() == target_date:&#10;            subtract_intervals_list.append((booking.start_at.time(), booking.end_at.time()))&#10;    time_slots = []&#10;    for avail in day_availabilities:&#10;        available_intervals = subtract_intervals(avail.start_time, avail.end_time, subtract_intervals_list)&#10;        for start, end in available_intervals:&#10;            # If service_duration_minutes is provided, filter slots that don't have enough time&#10;            if service_duration_minutes:&#10;                # Calculate the duration of this slot in minutes&#10;                start_datetime = datetime.combine(target_date, start)&#10;                end_datetime = datetime.combine(target_date, end)&#10;                slot_duration_minutes = (end_datetime - start_datetime).total_seconds() / 60&#10;                &#10;                # Only include slots that have enough time for the service&#10;                # Adjust end_time to be service_duration_minutes before the actual end&#10;                if slot_duration_minutes &gt;= service_duration_minutes:&#10;                    # Calculate the last possible start time&#10;                    last_start_time = (datetime.combine(target_date, end) - timedelta(minutes=service_duration_minutes)).time()&#10;                    if start &lt; last_start_time:&#10;                        time_slots.append(TimeSlot(&#10;                            start_time=start,&#10;                            end_time=last_start_time,&#10;                            is_available=True&#10;                        ))&#10;            else:&#10;                # No service duration provided, include the full slot&#10;                if start &lt; end:&#10;                    time_slots.append(TimeSlot(&#10;                        start_time=start,&#10;                        end_time=end,&#10;                        is_available=True&#10;                    ))&#10;    return DailyAvailability(&#10;        date=target_date,&#10;        time_slots=time_slots&#10;    )&#10;&#10;def calculate_availability(&#10;    availabilities: List[UserAvailabilities],&#10;    time_offs: List[UserTimeOffs],&#10;    bookings: List[Any],&#10;    availability_type: AvailabilityType,&#10;    date_from: date,&#10;    service_duration_minutes: Optional[int] = None&#10;) -&gt; AvailabilityResponse:&#10;    &quot;&quot;&quot;Calculate availability based on working hours, time-offs, and bookings&quot;&quot;&quot;&#10;    try:&#10;        if not availabilities:&#10;            return AvailabilityResponse(&#10;                user_id=None,&#10;                availability_type=availability_type,&#10;                daily=None,&#10;                weekly=None,&#10;                monthly=None&#10;            )&#10;        if availability_type == AvailabilityType.DAILY:&#10;            daily = get_daily_slots(date_from, availabilities, time_offs, bookings, service_duration_minutes)&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                daily=daily&#10;            )&#10;        elif availability_type == AvailabilityType.WEEKLY:&#10;            week_start = date_from&#10;            week_end = week_start + timedelta(days=6)&#10;            daily_slots = []&#10;            current_date = week_start&#10;            while current_date &lt;= week_end:&#10;                daily_slots.append(get_daily_slots(current_date, availabilities, time_offs, bookings, service_duration_minutes))&#10;                current_date += timedelta(days=1)&#10;            weekly = WeeklyAvailability(&#10;                week_start_date=week_start,&#10;                week_end_date=week_end,&#10;                daily_slots=daily_slots&#10;            )&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                weekly=weekly&#10;            )&#10;        else:  # MONTHLY&#10;            month_start = date_from.replace(day=1)&#10;            if month_start.month == 12:&#10;                month_end = month_start.replace(year=month_start.year + 1, month=1, day=1) - timedelta(days=1)&#10;            else:&#10;                month_end = month_start.replace(month=month_start.month + 1, day=1) - timedelta(days=1)&#10;            weekly_slots = []&#10;            current_date = month_start&#10;            while current_date &lt;= month_end:&#10;                week_start = current_date - timedelta(days=current_date.weekday())&#10;                week_end = min(week_start + timedelta(days=6), month_end)&#10;                daily_slots = []&#10;                week_date = week_start&#10;                while week_date &lt;= week_end:&#10;                    if month_start &lt;= week_date &lt;= month_end:&#10;                        daily_slots.append(get_daily_slots(week_date, availabilities, time_offs, bookings, service_duration_minutes))&#10;                    week_date += timedelta(days=1)&#10;                weekly_slots.append(WeeklyAvailability(&#10;                    week_start_date=week_start,&#10;                    week_end_date=week_end,&#10;                    daily_slots=daily_slots&#10;                ))&#10;                current_date = week_end + timedelta(days=1)&#10;            monthly = MonthlyAvailability(&#10;                month=date_from.month,&#10;                year=date_from.year,&#10;                weekly_slots=weekly_slots&#10;            )&#10;&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                monthly=monthly&#10;            )&#10;    except Exception as ex:&#10;        print(f&quot;Error calculating availability: {ex}&quot;)&#10;        raise" />
              <option name="updatedContent" value="from typing import List, Optional, Any&#10;from datetime import datetime, date, time, timedelta&#10;from sqlalchemy.orm import Session&#10;import uuid&#10;from app.models.models import UserAvailabilities, UserTimeOffs&#10;from app.models.enums import AvailabilityType&#10;from app.schemas.schemas import (&#10;    TimeSlot,&#10;    DailyAvailability,&#10;    WeeklyAvailability,&#10;    MonthlyAvailability,&#10;    AvailabilityResponse,&#10;    UserAvailabilityCreate&#10;)&#10;from app.core.datetime_utils import utcnow&#10;&#10;&#10;def create_user_availability(db: Session, user_id: str, availability_in: UserAvailabilityCreate) -&gt; UserAvailabilities:&#10;    &quot;&quot;&quot;Create a new availability entry for a user&quot;&quot;&quot;&#10;    db_availability = UserAvailabilities(&#10;        id=str(uuid.uuid4()),&#10;        user_id=user_id,&#10;        day_of_week=availability_in.day_of_week,&#10;        start_time=availability_in.start_time,&#10;        end_time=availability_in.end_time,&#10;        is_available=availability_in.is_available,&#10;        created_at=utcnow(),&#10;        updated_at=utcnow()&#10;    )&#10;    db.add(db_availability)&#10;    db.commit()&#10;    db.refresh(db_availability)&#10;    return db_availability&#10;&#10;&#10;def bulk_create_user_availabilities(db: Session, user_id: str, availabilities: List[UserAvailabilityCreate]) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Create multiple availability entries for a user&quot;&quot;&quot;&#10;    db_availabilities = []&#10;    for availability_in in availabilities:&#10;        db_availability = UserAvailabilities(&#10;            id=str(uuid.uuid4()),&#10;            user_id=user_id,&#10;            day_of_week=availability_in.day_of_week,&#10;            start_time=availability_in.start_time,&#10;            end_time=availability_in.end_time,&#10;            is_available=availability_in.is_available,&#10;            created_at=utcnow(),&#10;            updated_at=utcnow()&#10;        )&#10;        db_availabilities.append(db_availability)&#10;    &#10;    db.add_all(db_availabilities)&#10;    db.commit()&#10;    for db_availability in db_availabilities:&#10;        db.refresh(db_availability)&#10;    return db_availabilities&#10;&#10;&#10;def delete_user_availabilities(db: Session, user_id: str) -&gt; bool:&#10;    &quot;&quot;&quot;Delete all availability entries for a user&quot;&quot;&quot;&#10;    db.query(UserAvailabilities).filter(UserAvailabilities.user_id == user_id).delete()&#10;    db.commit()&#10;    return True&#10;&#10;&#10;def update_user_availabilities(db: Session, user_id: str, availabilities: List[UserAvailabilityCreate]) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Replace all availability entries for a user with new ones&quot;&quot;&quot;&#10;    # Delete existing availabilities&#10;    delete_user_availabilities(db, user_id)&#10;    &#10;    # Create new availabilities&#10;    if availabilities:&#10;        return bulk_create_user_availabilities(db, user_id, availabilities)&#10;    return []&#10;&#10;&#10;def get_user_availabilities(db: Session, user_id: str) -&gt; List[UserAvailabilities]:&#10;    &quot;&quot;&quot;Get all availability entries for a user&quot;&quot;&quot;&#10;    return list(db.query(UserAvailabilities).filter(UserAvailabilities.user_id == user_id,&#10;                                                    UserAvailabilities.is_available == True).all())&#10;&#10;def get_user_time_offs(&#10;    db: Session,&#10;    user_id: str,&#10;    start_date: date,&#10;    end_date: date&#10;) -&gt; List[&quot;UserTimeOffs&quot;]:&#10;    &quot;&quot;&quot;Get all time-offs for a user within a date range&quot;&quot;&quot;&#10;    return db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.user_id == user_id,&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date).all()&#10;&#10;def get_all_availabilities(db: Session):&#10;    &quot;&quot;&quot;Get all available user availabilities&quot;&quot;&quot;&#10;    return db.query(UserAvailabilities).filter(UserAvailabilities.is_available == True).all()&#10;&#10;def get_all_time_offs(db: Session, start_date: date, end_date: date):&#10;    &quot;&quot;&quot;Get all time-offs within a date range&quot;&quot;&quot;&#10;    return db.query(UserTimeOffs).filter(&#10;        UserTimeOffs.start_date &lt;= end_date,&#10;        UserTimeOffs.end_date &gt;= start_date&#10;    ).all()&#10;&#10;def subtract_intervals(base_start: time, base_end: time, intervals: List[tuple]) -&gt; List[tuple]:&#10;    &quot;&quot;&quot;Subtract intervals (bookings/time-offs) from a base interval. Returns list of available intervals.&quot;&quot;&quot;&#10;    result = [(base_start, base_end)]&#10;    for interval_start, interval_end in intervals:&#10;        new_result = []&#10;        for avail_start, avail_end in result:&#10;            # If no overlap, keep as is&#10;            if interval_end &lt;= avail_start or interval_start &gt;= avail_end:&#10;                new_result.append((avail_start, avail_end))&#10;            else:&#10;                # Overlap: split interval&#10;                if interval_start &gt; avail_start:&#10;                    new_result.append((avail_start, interval_start))&#10;                if interval_end &lt; avail_end:&#10;                    new_result.append((interval_end, avail_end))&#10;        result = new_result&#10;    return result&#10;&#10;def get_daily_slots(target_date: date, availabilities: List[UserAvailabilities], time_offs: List[UserTimeOffs], bookings: List[Any], service_duration_minutes: Optional[int] = None) -&gt; DailyAvailability:&#10;    day_of_week = target_date.weekday()&#10;    day_availabilities = [a for a in availabilities if a.day_of_week == day_of_week]&#10;    # Collect intervals to subtract (bookings and time-offs)&#10;    subtract_intervals_list = []&#10;    for time_off, user_id in time_offs:&#10;        if time_off.start_date.date() &lt;= target_date &lt;= time_off.end_date.date():&#10;            subtract_intervals_list.append((time(time_off.start_date.hour,time_off.start_date.minute),&#10;                                            time(time_off.end_date.hour,time_off.end_date.minute)))&#10;    for booking in bookings:&#10;        if booking.start_at.date() == target_date:&#10;            subtract_intervals_list.append((booking.start_at.time(), booking.end_at.time()))&#10;    time_slots = []&#10;    for avail in day_availabilities:&#10;        available_intervals = subtract_intervals(avail.start_time, avail.end_time, subtract_intervals_list)&#10;        for start, end in available_intervals:&#10;            # If service_duration_minutes is provided, filter slots that don't have enough time&#10;            if service_duration_minutes:&#10;                # Calculate the duration of this slot in minutes&#10;                start_datetime = datetime.combine(target_date, start)&#10;                end_datetime = datetime.combine(target_date, end)&#10;                slot_duration_minutes = (end_datetime - start_datetime).total_seconds() / 60&#10;                &#10;                # Only include slots that have enough time for the service&#10;                # Adjust end_time to be service_duration_minutes before the actual end&#10;                if slot_duration_minutes &gt;= service_duration_minutes:&#10;                    # Calculate the last possible start time&#10;                    last_start_time = (datetime.combine(target_date, end) - timedelta(minutes=service_duration_minutes)).time()&#10;                    if start &lt; last_start_time:&#10;                        time_slots.append(TimeSlot(&#10;                            start_time=start,&#10;                            end_time=last_start_time,&#10;                            is_available=True&#10;                        ))&#10;            else:&#10;                # No service duration provided, include the full slot&#10;                if start &lt; end:&#10;                    time_slots.append(TimeSlot(&#10;                        start_time=start,&#10;                        end_time=end,&#10;                        is_available=True&#10;                    ))&#10;    return DailyAvailability(&#10;        date=target_date,&#10;        time_slots=time_slots&#10;    )&#10;&#10;def calculate_availability(&#10;    availabilities: List[UserAvailabilities],&#10;    time_offs: List[UserTimeOffs],&#10;    bookings: List[Any],&#10;    availability_type: AvailabilityType,&#10;    date_from: date,&#10;    service_duration_minutes: Optional[int] = None&#10;) -&gt; AvailabilityResponse:&#10;    &quot;&quot;&quot;Calculate availability based on working hours, time-offs, and bookings&quot;&quot;&quot;&#10;    try:&#10;        if not availabilities:&#10;            return AvailabilityResponse(&#10;                user_id=None,&#10;                availability_type=availability_type,&#10;                daily=None,&#10;                weekly=None,&#10;                monthly=None&#10;            )&#10;        if availability_type == AvailabilityType.DAILY:&#10;            daily = get_daily_slots(date_from, availabilities, time_offs, bookings, service_duration_minutes)&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                daily=daily&#10;            )&#10;        elif availability_type == AvailabilityType.WEEKLY:&#10;            week_start = date_from&#10;            week_end = week_start + timedelta(days=6)&#10;            daily_slots = []&#10;            current_date = week_start&#10;            while current_date &lt;= week_end:&#10;                daily_slots.append(get_daily_slots(current_date, availabilities, time_offs, bookings, service_duration_minutes))&#10;                current_date += timedelta(days=1)&#10;            weekly = WeeklyAvailability(&#10;                week_start_date=week_start,&#10;                week_end_date=week_end,&#10;                daily_slots=daily_slots&#10;            )&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                weekly=weekly&#10;            )&#10;        else:  # MONTHLY&#10;            month_start = date_from.replace(day=1)&#10;            if month_start.month == 12:&#10;                month_end = month_start.replace(year=month_start.year + 1, month=1, day=1) - timedelta(days=1)&#10;            else:&#10;                month_end = month_start.replace(month=month_start.month + 1, day=1) - timedelta(days=1)&#10;            weekly_slots = []&#10;            current_date = month_start&#10;            while current_date &lt;= month_end:&#10;                week_start = current_date - timedelta(days=current_date.weekday())&#10;                week_end = min(week_start + timedelta(days=6), month_end)&#10;                daily_slots = []&#10;                week_date = week_start&#10;                while week_date &lt;= week_end:&#10;                    if month_start &lt;= week_date &lt;= month_end:&#10;                        daily_slots.append(get_daily_slots(week_date, availabilities, time_offs, bookings, service_duration_minutes))&#10;                    week_date += timedelta(days=1)&#10;                weekly_slots.append(WeeklyAvailability(&#10;                    week_start_date=week_start,&#10;                    week_end_date=week_end,&#10;                    daily_slots=daily_slots&#10;                ))&#10;                current_date = week_end + timedelta(days=1)&#10;            monthly = MonthlyAvailability(&#10;                month=date_from.month,&#10;                year=date_from.year,&#10;                weekly_slots=weekly_slots&#10;            )&#10;&#10;            return AvailabilityResponse(&#10;                user_id=str(availabilities[0].user_id),&#10;                availability_type=availability_type,&#10;                monthly=monthly&#10;            )&#10;    except Exception as ex:&#10;        print(f&quot;Error calculating availability: {ex}&quot;)&#10;        raise" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs/subcategories_implementation.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/subcategories_implementation.md" />
              <option name="updatedContent" value="# Subcategories Implementation&#10;&#10;## Overview&#10;The subcategories feature allows companies to organize their services in a hierarchical structure with multiple levels of categories and subcategories.&#10;&#10;## Database Schema&#10;&#10;### CompanyCategories Table&#10;Added `parent_category_id` field:&#10;- **parent_category_id**: UUID (nullable, self-referencing foreign key)&#10;  - NULL for root/main categories&#10;  - Contains parent category ID for subcategories&#10;  - Foreign key constraint with CASCADE delete&#10;  - Indexed for performance&#10;&#10;## Business Rules&#10;&#10;### 1. Service Assignment Rules&#10;- **Services can ONLY be added to leaf categories** (categories without subcategories)&#10;- **If a category has subcategories, services cannot be added to it**&#10;- Services must be added to the deepest level subcategories&#10;&#10;### 2. Subcategory Creation Rules&#10;- **If a category already has services, you cannot add subcategories to it**&#10;- You must first remove all services before adding subcategories&#10;- Multiple levels of subcategories are allowed (no depth limit)&#10;&#10;### 3. Parent-Child Validation&#10;- When creating a subcategory, the parent category must:&#10;  - Exist&#10;  - Belong to the same company&#10;  - Not have any services assigned&#10;&#10;## API Endpoints&#10;&#10;### 1. Get Categories (Flat List)&#10;```&#10;GET /api/v1/services/companies/categories&#10;```&#10;Returns all categories in a flat list with basic information.&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;success&quot;: true,&#10;  &quot;data&quot;: [&#10;    {&#10;      &quot;id&quot;: &quot;uuid&quot;,&#10;      &quot;company_id&quot;: &quot;uuid&quot;,&#10;      &quot;parent_category_id&quot;: null,&#10;      &quot;name&quot;: &quot;Hair Services&quot;,&#10;      &quot;name_en&quot;: &quot;Hair Services&quot;,&#10;      &quot;name_ee&quot;: &quot;Juuksuriteenus&quot;,&#10;      &quot;name_ru&quot;: &quot;  &quot;,&#10;      &quot;description&quot;: &quot;All hair related services&quot;,&#10;      &quot;services_count&quot;: 0,&#10;      &quot;has_subcategories&quot;: true,&#10;      &quot;created_at&quot;: &quot;2026-02-09T10:00:00Z&quot;,&#10;      &quot;updated_at&quot;: &quot;2026-02-09T10:00:00Z&quot;&#10;    },&#10;    {&#10;      &quot;id&quot;: &quot;uuid&quot;,&#10;      &quot;company_id&quot;: &quot;uuid&quot;,&#10;      &quot;parent_category_id&quot;: &quot;parent-uuid&quot;,&#10;      &quot;name&quot;: &quot;Hair Cutting&quot;,&#10;      &quot;services_count&quot;: 3,&#10;      &quot;has_subcategories&quot;: false,&#10;      ...&#10;    }&#10;  ]&#10;}&#10;```&#10;&#10;### 2. Get Categories (Hierarchical)&#10;```&#10;GET /api/v1/services/companies/categories/hierarchical&#10;```&#10;Returns categories in a nested hierarchical structure.&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;success&quot;: true,&#10;  &quot;data&quot;: [&#10;    {&#10;      &quot;id&quot;: &quot;uuid&quot;,&#10;      &quot;company_id&quot;: &quot;uuid&quot;,&#10;      &quot;parent_category_id&quot;: null,&#10;      &quot;name&quot;: &quot;Hair Services&quot;,&#10;      &quot;description&quot;: &quot;All hair related services&quot;,&#10;      &quot;services_count&quot;: 0,&#10;      &quot;has_subcategories&quot;: true,&#10;      &quot;subcategories&quot;: [&#10;        {&#10;          &quot;id&quot;: &quot;sub-uuid-1&quot;,&#10;          &quot;parent_category_id&quot;: &quot;uuid&quot;,&#10;          &quot;name&quot;: &quot;Hair Cutting&quot;,&#10;          &quot;services_count&quot;: 3,&#10;          &quot;has_subcategories&quot;: false,&#10;          &quot;subcategories&quot;: []&#10;        },&#10;        {&#10;          &quot;id&quot;: &quot;sub-uuid-2&quot;,&#10;          &quot;parent_category_id&quot;: &quot;uuid&quot;,&#10;          &quot;name&quot;: &quot;Hair Coloring&quot;,&#10;          &quot;services_count&quot;: 0,&#10;          &quot;has_subcategories&quot;: true,&#10;          &quot;subcategories&quot;: [&#10;            {&#10;              &quot;id&quot;: &quot;sub-sub-uuid-1&quot;,&#10;              &quot;parent_category_id&quot;: &quot;sub-uuid-2&quot;,&#10;              &quot;name&quot;: &quot;Full Color&quot;,&#10;              &quot;services_count&quot;: 2,&#10;              &quot;has_subcategories&quot;: false,&#10;              &quot;subcategories&quot;: []&#10;            }&#10;          ]&#10;        }&#10;      ]&#10;    }&#10;  ]&#10;}&#10;```&#10;&#10;### 3. Get Company Services (Hierarchical with Services)&#10;```&#10;GET /api/v1/services/companies/{company_slug}/services&#10;```&#10;Returns categories with their services in hierarchical structure.&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;success&quot;: true,&#10;  &quot;data&quot;: [&#10;    {&#10;      &quot;id&quot;: &quot;uuid&quot;,&#10;      &quot;name&quot;: &quot;Hair Services&quot;,&#10;      &quot;description&quot;: &quot;All hair related services&quot;,&#10;      &quot;parent_category_id&quot;: null,&#10;      &quot;services&quot;: [],&#10;      &quot;subcategories&quot;: [&#10;        {&#10;          &quot;id&quot;: &quot;sub-uuid&quot;,&#10;          &quot;name&quot;: &quot;Hair Cutting&quot;,&#10;          &quot;parent_category_id&quot;: &quot;uuid&quot;,&#10;          &quot;services&quot;: [&#10;            {&#10;              &quot;id&quot;: &quot;service-uuid&quot;,&#10;              &quot;name&quot;: &quot;Women's Haircut&quot;,&#10;              &quot;duration&quot;: 30,&#10;              &quot;price&quot;: 5000,&#10;              &quot;discount_price&quot;: 4500,&#10;              ...&#10;            }&#10;          ],&#10;          &quot;subcategories&quot;: []&#10;        }&#10;      ]&#10;    }&#10;  ]&#10;}&#10;```&#10;&#10;### 4. Create Category/Subcategory&#10;```&#10;POST /api/v1/services/categories&#10;```&#10;&#10;**Request Body:**&#10;```json&#10;{&#10;  &quot;name&quot;: &quot;Hair Cutting&quot;,&#10;  &quot;name_en&quot;: &quot;Hair Cutting&quot;,&#10;  &quot;name_ee&quot;: &quot;Juukselikus&quot;,&#10;  &quot;name_ru&quot;: &quot;&quot;,&#10;  &quot;description&quot;: &quot;Professional hair cutting services&quot;,&#10;  &quot;parent_category_id&quot;: &quot;parent-uuid-optional&quot;&#10;}&#10;```&#10;&#10;**Validation:**&#10;- If `parent_category_id` is provided:&#10;  - Parent category must exist&#10;  - Parent category must belong to the same company&#10;  - Parent category must NOT have services&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;success&quot;: true,&#10;  &quot;message&quot;: &quot;Category created successfully&quot;,&#10;  &quot;data&quot;: {&#10;    &quot;id&quot;: &quot;new-uuid&quot;,&#10;    &quot;company_id&quot;: &quot;uuid&quot;,&#10;    &quot;parent_category_id&quot;: &quot;parent-uuid&quot;,&#10;    &quot;name&quot;: &quot;Hair Cutting&quot;,&#10;    ...&#10;  }&#10;}&#10;```&#10;&#10;**Error Cases:**&#10;```json&#10;{&#10;  &quot;success&quot;: false,&#10;  &quot;message&quot;: &quot;Cannot add subcategories to a category that already has services. Please remove the services first.&quot;,&#10;  &quot;status_code&quot;: 400&#10;}&#10;```&#10;&#10;### 5. Create Service&#10;```&#10;POST /api/v1/services&#10;Content-Type: multipart/form-data&#10;```&#10;&#10;**Request:**&#10;- `service_in` (JSON string): Service details including category_id&#10;- `image` (file, optional): Service image&#10;&#10;**Validation:**&#10;- Category must exist&#10;- Category must belong to the company&#10;- **Category must NOT have subcategories**&#10;&#10;**Response:**&#10;```json&#10;{&#10;  &quot;success&quot;: true,&#10;  &quot;message&quot;: &quot;Service created successfully&quot;,&#10;  &quot;data&quot;: {&#10;    &quot;id&quot;: &quot;service-uuid&quot;,&#10;    &quot;category_id&quot;: &quot;category-uuid&quot;,&#10;    &quot;name&quot;: &quot;Women's Haircut&quot;,&#10;    ...&#10;  }&#10;}&#10;```&#10;&#10;**Error Cases:**&#10;```json&#10;{&#10;  &quot;success&quot;: false,&#10;  &quot;message&quot;: &quot;Cannot add services to a category that has subcategories. Please add services to the subcategories instead.&quot;,&#10;  &quot;status_code&quot;: 400&#10;}&#10;```&#10;&#10;### 6. Update Category&#10;```&#10;PUT /api/v1/services/categories/{category_id}&#10;```&#10;&#10;Can update `parent_category_id` to move a category to a different parent or make it a root category (set to null).&#10;&#10;### 7. Delete Category&#10;```&#10;DELETE /api/v1/services/categories/{category_id}&#10;```&#10;&#10;**Cascade Behavior:**&#10;- Deleting a category will also delete all its subcategories (CASCADE)&#10;- All services in the deleted category and its subcategories will also be deleted&#10;&#10;## Model Properties&#10;&#10;### CompanyCategories Model&#10;New properties:&#10;- `parent_category_id`: UUID (nullable)&#10;- `subcategories`: Relationship to child categories&#10;- `parent`: Backref to parent category&#10;- `has_subcategories`: Hybrid property (boolean)&#10;&#10;## Schema Updates&#10;&#10;### CompanyCategoryBase&#10;- Added `parent_category_id: Optional[UUID4]`&#10;&#10;### CompanyCategoryHierarchical (New)&#10;Includes all category fields plus:&#10;- `subcategories: List[CompanyCategoryHierarchical]` (recursive)&#10;&#10;### CompanyCategoryWithServicesResponse&#10;Updated to include:&#10;- `parent_category_id: Optional[UUID4]`&#10;- `subcategories: List[CompanyCategoryWithServicesResponse]` (recursive)&#10;&#10;## CRUD Functions&#10;&#10;### New Functions&#10;1. **get_company_categories_hierarchical**: Returns categories in nested structure&#10;2. **category_has_subcategories**: Check if category has children&#10;3. **validate_service_category**: Validate if services can be added to category&#10;&#10;### Updated Functions&#10;1. **create_category**: Now accepts parent_category_id&#10;2. **create_service**: Now validates category doesn't have subcategories&#10;3. **get_company_services**: Returns hierarchical structure with subcategories&#10;&#10;## Use Cases&#10;&#10;### Example 1: Beauty Salon Structure&#10;```&#10;Hair Services (parent)&#10; Hair Cutting (subcategory)&#10;    Women's Haircut (service)&#10;    Men's Haircut (service)&#10;    Kids Haircut (service)&#10; Hair Coloring (subcategory)&#10;    Full Color (sub-subcategory)&#10;       Single Process Color (service)&#10;       Double Process Color (service)&#10;    Highlights (sub-subcategory)&#10;        Full Highlights (service)&#10;        Partial Highlights (service)&#10; Hair Treatment (subcategory)&#10;     Deep Conditioning (service)&#10;     Keratin Treatment (service)&#10;&#10;Nail Services (parent)&#10; Manicure (subcategory)&#10;    Basic Manicure (service)&#10;    Gel Manicure (service)&#10; Pedicure (subcategory)&#10;     Basic Pedicure (service)&#10;     Spa Pedicure (service)&#10;```&#10;&#10;### Example 2: Workflow&#10;&#10;#### Step 1: Create Main Categories&#10;```bash&#10;POST /api/v1/services/categories&#10;{&#10;  &quot;name&quot;: &quot;Hair Services&quot;,&#10;  &quot;parent_category_id&quot;: null&#10;}&#10;```&#10;&#10;#### Step 2: Create Subcategories&#10;```bash&#10;POST /api/v1/services/categories&#10;{&#10;  &quot;name&quot;: &quot;Hair Cutting&quot;,&#10;  &quot;parent_category_id&quot;: &quot;hair-services-uuid&quot;&#10;}&#10;```&#10;&#10;#### Step 3: Add Services to Leaf Categories&#10;```bash&#10;POST /api/v1/services&#10;{&#10;  &quot;category_id&quot;: &quot;hair-cutting-uuid&quot;,&#10;  &quot;name&quot;: &quot;Women's Haircut&quot;,&#10;  &quot;duration&quot;: 30,&#10;  &quot;price&quot;: 50.00&#10;}&#10;```&#10;&#10;####  Invalid: Add Service to Parent with Subcategories&#10;```bash&#10;POST /api/v1/services&#10;{&#10;  &quot;category_id&quot;: &quot;hair-services-uuid&quot;,  # Has subcategories!&#10;  &quot;name&quot;: &quot;Some Service&quot;&#10;}&#10;# Returns: 400 Bad Request&#10;# &quot;Cannot add services to a category that has subcategories&quot;&#10;```&#10;&#10;####  Invalid: Add Subcategory to Category with Services&#10;```bash&#10;POST /api/v1/services/categories&#10;{&#10;  &quot;name&quot;: &quot;New Subcategory&quot;,&#10;  &quot;parent_category_id&quot;: &quot;hair-cutting-uuid&quot;  # Has services!&#10;}&#10;# Returns: 400 Bad Request&#10;# &quot;Cannot add subcategories to a category that already has services&quot;&#10;```&#10;&#10;## Migration&#10;&#10;**File:** `alembic/versions/add_subcategories_support.py`&#10;&#10;**Changes:**&#10;1. Added `parent_category_id` column (UUID, nullable)&#10;2. Added foreign key constraint with CASCADE delete&#10;3. Added index on `parent_category_id` for performance&#10;&#10;**Run Migration:**&#10;```bash&#10;alembic upgrade head&#10;```&#10;&#10;**Rollback:**&#10;```bash&#10;alembic downgrade -1&#10;```&#10;&#10;## Frontend Integration Tips&#10;&#10;### Displaying Categories&#10;1. Use the hierarchical endpoint for tree views&#10;2. Use the flat endpoint for dropdowns/selects&#10;3. Filter by `has_subcategories` to determine if category can have services&#10;&#10;### Creating Services&#10;1. Only show categories where `has_subcategories == false` in category selector&#10;2. Disable parent categories in the UI&#10;3. Show validation messages clearly&#10;&#10;### Creating Subcategories&#10;1. Check `services_count` before allowing subcategory creation&#10;2. Show warning if category has services&#10;3. Allow moving/reassigning services before creating subcategories&#10;&#10;## Performance Considerations&#10;&#10;1. **Indexed Fields**: `parent_category_id` is indexed for fast queries&#10;2. **Cascade Deletes**: Use with caution - deleting a parent deletes all children&#10;3. **Hierarchical Queries**: May be slower for very deep trees (consider caching)&#10;4. **Eager Loading**: Consider using eager loading for subcategories in queries&#10;&#10;## Testing&#10;&#10;### Test Cases to Cover&#10;1.  Create root category (parent_category_id = null)&#10;2.  Create subcategory with valid parent&#10;3.  Create multiple levels of subcategories&#10;4.  Add service to leaf category&#10;5.  Add service to category with subcategories (should fail)&#10;6.  Add subcategory to category with services (should fail)&#10;7.  Get hierarchical categories&#10;8.  Get flat categories&#10;9.  Delete category with subcategories (cascade)&#10;10.  Update parent_category_id to move category&#10;&#10;## Future Enhancements&#10;&#10;1. **Depth Limit**: Add configurable max depth for category tree&#10;2. **Category Ordering**: Add order/position field for custom sorting&#10;3. **Bulk Operations**: Move multiple categories at once&#10;4. **Category Templates**: Pre-defined category structures for different business types&#10;5. **Category Icons**: Add icon field for better UI representation&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>